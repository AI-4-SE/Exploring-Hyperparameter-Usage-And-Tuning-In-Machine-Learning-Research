{
    "utils/clustering.py": {
        "sklearn": {
            "MeanShift_18": {
                "variable": {
                    "value": "ms",
                    "type": "variable",
                    "possible_values": []
                },
                "bandwidth": {
                    "value": "bandwidth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bandwidth",
                            "Method Argument"
                        ],
                        [
                            "bandwidth",
                            "Method Argument"
                        ],
                        [
                            "bandwidth",
                            "Method Argument"
                        ]
                    ]
                },
                "bin_seeding": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "utils/pointconv_util.py": {
        "sklearn": {
            "KDTree_37": {
                "variable": {
                    "value": "kdt",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xyz[batch_idx, ...]",
                            "Subscript"
                        ]
                    ]
                },
                "leaf_size": {
                    "value": "30",
                    "type": "int",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "py_func_99": {
                "variable": {
                    "value": "point_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "knn_kdtree",
                    "type": "variable",
                    "possible_values": [
                        [
                            "knn_kdtree",
                            "Call"
                        ]
                    ]
                },
                "inp": {
                    "value": "[K, src_xyz, q_xyz]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_100": {
                "variable": {
                    "value": "batch_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.range(batch_size), (-1, 1, 1, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(1, npoint, K, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_101": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_indices, tf.expand_dims(point_indices, axis=3)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_104": {
                "variable": {
                    "value": "grouped_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "src_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "src_xyz",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_ball_point(radius, N_points, pts, pts)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_indices, tf.expand_dims(point_indices, axis=3)], axis=3)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(feature, K, xyz, new_xyz)",
                            "Call"
                        ],
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(interpolated_points, K, xyz1, xyz1, use_xyz=use_xyz)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_107": {
                "variable": {
                    "value": "grouped_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "feature",
                            "Method Argument"
                        ],
                        [
                            "feature",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_ball_point(radius, N_points, pts, pts)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_indices, tf.expand_dims(point_indices, axis=3)], axis=3)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(feature, K, xyz, new_xyz)",
                            "Call"
                        ],
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(interpolated_points, K, xyz1, xyz1, use_xyz=use_xyz)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_49": {
                "variable": {
                    "value": "R",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sigma",
                            "Method Argument"
                        ],
                        [
                            "sigma",
                            "Method Argument"
                        ],
                        [
                            "sigma",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "div_50": {
                "variable": {
                    "value": "xRinv",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g_pts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "group_point(pts, idx)",
                            "Call"
                        ],
                        [
                            "g_pts - tf.tile(tf.expand_dims(pts, 2), [1, 1, N_points, 1])",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "R",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(sigma)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_51": {
                "variable": {
                    "value": "quadform",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(xRinv)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_53": {
                "variable": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-0.5 * quadform - logsqrtdetSigma - 3 * tf.log(2 * 3.1415926) / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_55": {
                "variable": {
                    "value": "(first_val, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-0.5 * quadform - logsqrtdetSigma - 3 * tf.log(2 * 3.1415926) / 2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mvnpdf, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.subtract(mvnpdf, val_to_sub)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[1, N_points - 1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_57": {
                "variable": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-0.5 * quadform - logsqrtdetSigma - 3 * tf.log(2 * 3.1415926) / 2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mvnpdf, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.subtract(mvnpdf, val_to_sub)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "expand_dims_59": {
                "variable": {
                    "value": "num_val_to_sub",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(tf.subtract(N_points, pts_cnt), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "multiply_61": {
                "variable": {
                    "value": "val_to_sub",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "first_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(mvnpdf, [1, N_points - 1], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_val_to_sub",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.cast(tf.subtract(N_points, pts_cnt), dtype=tf.float32), axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "subtract_63": {
                "variable": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-0.5 * quadform - logsqrtdetSigma - 3 * tf.log(2 * 3.1415926) / 2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mvnpdf, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.subtract(mvnpdf, val_to_sub)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "val_to_sub",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(first_val, num_val_to_sub)",
                            "Call"
                        ]
                    ]
                }
            },
            "div_65": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(tf.cast(pts_cnt, dtype=tf.float32), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_66": {
                "variable": {
                    "value": "density",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mvnpdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-0.5 * quadform - logsqrtdetSigma - 3 * tf.log(2 * 3.1415926) / 2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mvnpdf, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.subtract(mvnpdf, val_to_sub)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(1.0, tf.expand_dims(tf.cast(pts_cnt, dtype=tf.float32), axis=-1))",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_105": {
                "input": {
                    "value": "tf.expand_dims(q_xyz, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, K, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_109": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[grouped_xyz, grouped_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "div_200": {
                "variable": {
                    "value": "inverse_density",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(mvnpdf, scale)",
                            "Call"
                        ],
                        [
                            "tf.div(density, density_max)",
                            "Call"
                        ],
                        [
                            "kernel_density_estimation_ball(xyz, radius, sigma)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_201": {
                "variable": {
                    "value": "grouped_density",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "inverse_density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(1.0, density)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_ball_point(radius, N_points, pts, pts)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_indices, tf.expand_dims(point_indices, axis=3)], axis=3)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(feature, K, xyz, new_xyz)",
                            "Call"
                        ],
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(interpolated_points, K, xyz1, xyz1, use_xyz=use_xyz)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_203": {
                "variable": {
                    "value": "inverse_max_density",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "grouped_density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(inverse_density, idx)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "div_204": {
                "variable": {
                    "value": "density_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grouped_density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(inverse_density, idx)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "inverse_max_density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(grouped_density, axis=2, keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_223": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grouped_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(feature, idx)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(feature, K, xyz, new_xyz)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(grouped_feature, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv{}'.format(i), is_dist=is_dist, bn_decay=bn_decay, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(interpolated_points, K, xyz1, xyz1, use_xyz=use_xyz)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "density_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(grouped_density, inverse_max_density)",
                            "Call"
                        ],
                        [
                            "nonlinear_transform(density_scale, [16, 1], scope='density_net', is_training=is_training, bn_decay=bn_decay, weight_decay=weight_decay, is_dist=is_dist)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_225": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([grouped_xyz, grouped_feature], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_feature",
                            "variable"
                        ],
                        [
                            "tf.multiply(grouped_feature, density_scale)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.matmul(new_points, weight)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, mlp[-1], [1, new_points.get_shape()[2].value], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='after_conv', bn_decay=bn_decay, is_dist=is_dist, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.multiply(grouped_feature, weight)",
                            "Call"
                        ],
                        [
                            "tf_util.reduce_sum2d_conv(new_points, axis=2, scope='fp_sumpool', bn=True, is_dist=is_dist, bn_decay=bn_decay, is_training=is_training, keepdims=False)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_228": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([grouped_xyz, grouped_feature], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_feature",
                            "variable"
                        ],
                        [
                            "tf.multiply(grouped_feature, density_scale)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.matmul(new_points, weight)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, mlp[-1], [1, new_points.get_shape()[2].value], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='after_conv', bn_decay=bn_decay, is_dist=is_dist, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.multiply(grouped_feature, weight)",
                            "Call"
                        ],
                        [
                            "tf_util.reduce_sum2d_conv(new_points, axis=2, scope='fp_sumpool', bn=True, is_dist=is_dist, bn_decay=bn_decay, is_training=is_training, keepdims=False)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_net_hidden(grouped_xyz, [32], scope='weight_net', is_training=is_training, bn_decay=bn_decay, weight_decay=weight_decay, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "1.0 / dist / norm",
                            "BinOp"
                        ],
                        [
                            "weight_net(grouped_xyz, [32, grouped_feature.get_shape()[3].value], scope='decode_weight_net', is_training=is_training, bn_decay=bn_decay, weight_decay=weight_decay, is_dist=is_dist)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_236": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([grouped_xyz, grouped_feature], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_feature",
                            "variable"
                        ],
                        [
                            "tf.multiply(grouped_feature, density_scale)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.matmul(new_points, weight)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, mlp[-1], [1, new_points.get_shape()[2].value], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='after_conv', bn_decay=bn_decay, is_dist=is_dist, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.multiply(grouped_feature, weight)",
                            "Call"
                        ],
                        [
                            "tf_util.reduce_sum2d_conv(new_points, axis=2, scope='fp_sumpool', bn=True, is_dist=is_dist, bn_decay=bn_decay, is_training=is_training, keepdims=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_257": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_258": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1.0 / dist",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_259": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_269": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grouped_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(feature, idx)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(feature, K, xyz, new_xyz)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(grouped_feature, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv{}'.format(i), is_dist=is_dist, bn_decay=bn_decay, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "pointconv_grouping(interpolated_points, K, xyz1, xyz1, use_xyz=use_xyz)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_net_hidden(grouped_xyz, [32], scope='weight_net', is_training=is_training, bn_decay=bn_decay, weight_decay=weight_decay, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "1.0 / dist / norm",
                            "BinOp"
                        ],
                        [
                            "weight_net(grouped_xyz, [32, grouped_feature.get_shape()[3].value], scope='decode_weight_net', is_training=is_training, bn_decay=bn_decay, weight_decay=weight_decay, is_dist=is_dist)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_279": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=-1, values=[new_points, points1])",
                            "Call"
                        ],
                        [
                            "new_points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points1, 2)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points1, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, is_dist=is_dist, scope='conv_%d' % i, bn_decay=bn_decay, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points1, [2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_285": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=-1, values=[new_points, points1])",
                            "Call"
                        ],
                        [
                            "new_points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points1, 2)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points1, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, is_dist=is_dist, scope='conv_%d' % i, bn_decay=bn_decay, weight_decay=weight_decay)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points1, [2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "ComputeDensity",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_47": {
                "input": {
                    "value": "tf.expand_dims(pts, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, N_points, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_70": {
                "variable": {
                    "value": "density_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(mvnpdf, scale)",
                            "Call"
                        ],
                        [
                            "tf.div(density, density_max)",
                            "Call"
                        ],
                        [
                            "kernel_density_estimation_ball(xyz, radius, sigma)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "div_71": {
                "variable": {
                    "value": "density",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "density",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(mvnpdf, scale)",
                            "Call"
                        ],
                        [
                            "tf.div(density, density_max)",
                            "Call"
                        ],
                        [
                            "kernel_density_estimation_ball(xyz, radius, sigma)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "density_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(density, axis=1, keep_dims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_100": {
                "tensor": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 1, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "expand_dims_105": {
                "input": {
                    "value": "q_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "q_xyz",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_118": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_133": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_154": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_190": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_255": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_276": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_points, points1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_47": {
                "input": {
                    "value": "pts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pts",
                            "Method Argument"
                        ],
                        [
                            "pts",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_51": {
                "x": {
                    "value": "xRinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(g_pts, R)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_52": {
                "x": {
                    "value": "R",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(sigma)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_59": {
                "x": {
                    "value": "tf.subtract(N_points, pts_cnt)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_65": {
                "input": {
                    "value": "tf.cast(pts_cnt, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_101": {
                "input": {
                    "value": "point_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.py_func(knn_kdtree, [K, src_xyz, q_xyz], tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_59": {
                "x": {
                    "value": "N_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "128",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "pts_cnt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_ball_point(radius, N_points, pts, pts)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_65": {
                "x": {
                    "value": "pts_cnt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_ball_point(radius, N_points, pts, pts)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_53": {
                "x": {
                    "value": "2 * 3.1415926",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "models/JISS/model.py": {
        "tensorflow": {
            "placeholder_15": {
                "variable": {
                    "value": "pointclouds_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point, num_dims)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_16": {
                "variable": {
                    "value": "labels_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_17": {
                "variable": {
                    "value": "sem_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, num_point)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "add_51": {
                "variable": {
                    "value": "net_sem_0",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.concat([l0_points_sem, l1_points_sem_up], axis=-1, name='sem_up_concat')",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "l2_points_sem_up",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pointnet_upsample(l0_xyz, l2_xyz, l2_points_sem, scope='sem_up1')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "sem_up_add",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_57": {
                "variable": {
                    "value": "net_ins_0",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.concat([l0_points_ins, l1_points_ins_up], axis=-1, name='ins_up_concat')",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "l2_points_ins_up",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pointnet_upsample(l0_xyz, l2_xyz, l2_points_ins, scope='ins_up1')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "ins_up_add",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_64": {
                "variable": {
                    "value": "net_ins_2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_ins_0, net_ins_1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "net_ins_2_concat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_65": {
                "variable": {
                    "value": "net_ins_atten",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(net_ins_2, axis=-1, keep_dims=True, name='ins_reduce')",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "ins_atten",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_70": {
                "variable": {
                    "value": "net_ins_cache_1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "net_ins_cache_0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_util.conv1d(net_ins_3, 128, 1, padding='VALID', bn=True, is_training=is_training, is_dist=is_dist, scope='ins_cache_1', bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "ins_cache_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_71": {
                "variable": {
                    "value": "net_ins_cache_1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net_ins_cache_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(net_ins_cache_0, axis=1, keep_dims=True, name='ins_cache_2')",
                            "Call"
                        ],
                        [
                            "tf.tile(net_ins_cache_1, [1, num_point, 1], name='ins_cache_tile')",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, num_point, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "ins_cache_tile",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_74": {
                "variable": {
                    "value": "net_sem_2",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[net_sem_0, net_sem_1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "net_sem_2_concat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_75": {
                "variable": {
                    "value": "net_sem_atten",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(net_sem_2, axis=-1, keep_dims=True, name='sem_reduce')",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "sem_atten",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_97": {
                "variable": {
                    "value": "classify_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "sem_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sem_label",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "pred_sem",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pred_sem",
                            "Method Argument"
                        ]
                    ]
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_98": {
                "name": {
                    "value": "classify loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "classify_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.losses.sparse_softmax_cross_entropy(labels=sem_label, logits=pred_sem, weights=weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_114": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "classify_loss + disc_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_120": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(32, 2048, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_51": {
                "values": {
                    "value": "[l0_points_sem, l1_points_sem_up]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "sem_up_concat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_57": {
                "values": {
                    "value": "[l0_points_ins, l1_points_ins_up]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "ins_up_concat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_65": {
                "input_tensor": {
                    "value": "net_ins_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([net_ins_0, net_ins_1], axis=-1, name='net_ins_2_concat')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "ins_reduce",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_75": {
                "input_tensor": {
                    "value": "net_sem_2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([net_sem_0, net_sem_1], axis=-1, name='net_sem_2_concat')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "sem_reduce",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_121": {
                "value": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "models/JISS/test.py": {
        "tensorflow": {
            "ConfigProto_98": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_102": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_85": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_88": {
                "variable": {
                    "value": "is_training_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "softmax_92": {
                "variable": {
                    "value": "pred_sem_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "pred_sem",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_model(pointclouds_pl, is_training_pl, NUM_CLASSES)",
                            "Call"
                        ],
                        [
                            "np.squeeze(pred_sem_label_val, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_93": {
                "variable": {
                    "value": "pred_sem_label",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_sem_softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(pred_sem)",
                            "Call"
                        ],
                        [
                            "np.squeeze(pred_sem_softmax_val, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Saver_95": {
                "variable": {
                    "value": "loader",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_86": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "models/JISS/train.py": {
        "tensorflow": {
            "exponential_decay_80": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BASE_LEARNING_RATE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.learning_rate",
                            "Attribute"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "DECAY_STEP",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_step",
                            "Attribute"
                        ],
                        [
                            "int(DECAY_STEP / (BATCH_SIZE / 24))",
                            "Call"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "DECAY_RATE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.decay_rate",
                            "Attribute"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "maximum_86": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "exponential_decay_91": {
                "variable": {
                    "value": "bn_momentum",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "BN_INIT_DECAY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                },
                "global_step": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('batch', [], initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "BN_DECAY_DECAY_STEP",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float(DECAY_STEP)",
                            "Call"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "BN_DECAY_DECAY_RATE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "float"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "minimum_97": {
                "variable": {
                    "value": "bn_decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "BN_DECAY_CLIP",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.99",
                            "float"
                        ]
                    ]
                },
                "y": {
                    "value": "1 - bn_momentum",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_108": {
                "variable": {
                    "value": "is_training_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_112": {
                "variable": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "batch",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "softmax_118": {
                "variable": {
                    "value": "pred_sem_softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "pred_sem",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_model(pointclouds_pl, is_training_pl, NUM_CLASSES, bn_decay=bn_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_119": {
                "variable": {
                    "value": "pred_sem_label",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_sem_softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(pred_sem)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Saver_140": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ConfigProto_143": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_149": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_all_152": {
                "variable": {
                    "value": "merged",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_153": {
                "variable": {
                    "value": "train_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "os.path.join(LOG_DIR, 'train')",
                    "type": "Call",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_156": {
                "variable": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_checkpoint_state_159": {
                "variable": {
                    "value": "ckptstate",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "PRETRAINED_MODEL_PATH",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.restore_model",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Graph_106": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_106": {
                "device_name": {
                    "value": "'/gpu:' + str(GPU_INDEX)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_114": {
                "name": {
                    "value": "bn_decay",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "bn_decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(BN_DECAY_CLIP, 1 - bn_momentum)",
                            "Call"
                        ],
                        [
                            "get_bn_decay(batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_123": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_loss(pred_ins, labels_pl, pred_sem_label, pred_sem, sem_labels_pl)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_124": {
                "name": {
                    "value": "sem_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "sem_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_loss(pred_ins, labels_pl, pred_sem_label, pred_sem, sem_labels_pl)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_125": {
                "name": {
                    "value": "disc_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "disc_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_loss(pred_ins, labels_pl, pred_sem_label, pred_sem, sem_labels_pl)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_126": {
                "name": {
                    "value": "l_var",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_loss(pred_ins, labels_pl, pred_sem_label, pred_sem, sem_labels_pl)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_127": {
                "name": {
                    "value": "l_dist",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "l_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_loss(pred_ins, labels_pl, pred_sem_label, pred_sem, sem_labels_pl)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_131": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "MomentumOptimizer_133": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "MOMENTUM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.momentum",
                            "Attribute"
                        ]
                    ]
                }
            },
            "AdamOptimizer_135": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(BASE_LEARNING_RATE, batch, DECAY_STEP, DECAY_RATE, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, 1e-05)",
                            "Call"
                        ],
                        [
                            "get_learning_rate(batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_112": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "trainable_variables_137": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_165": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tf_ops/3d_interpolation/tf_interpolate.py": {
        "tensorflow": {
            "load_op_library_8": {
                "variable": {
                    "value": "interpolate_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_interpolate_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_38": {
                "op_type": {
                    "value": "ThreeInterpolate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_55": {
                "variable": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.random((32, 128, 64)).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_56": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tmp1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.random((32, 512, 3)).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_57": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tmp2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.random((32, 128, 3)).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "device_54": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_61": {
                "target": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ones_like_59": {
                "input": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "tf_ops/3d_interpolation/tf_interpolate_op_test.py": {
        "tensorflow": {
            "main_26": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_12": {
                "variable": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.random((1, 8, 16)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_14": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.random((1, 128, 3)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_15": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.random((1, 8, 3)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "compute_gradient_error_20": {
                "variable": {
                    "value": "err",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.random.random((1, 8, 16)).astype('float32'))",
                            "Call"
                        ]
                    ]
                },
                "x_shape": {
                    "value": "(1, 8, 16)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y": {
                    "value": "interpolated_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_interpolate(points, idx, weight)",
                            "Call"
                        ]
                    ]
                },
                "y_shape": {
                    "value": "(1, 128, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_like_17": {
                "input": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "tf_ops/3d_interpolation/visu_interpolation.py": {
        "tensorflow": {
            "constant_19": {
                "variable": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(pts2, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_20": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(xyz1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_21": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.expand_dims(xyz2, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "maximum_24": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_25": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1.0 / dist",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_26": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "device_18": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_30": {
                "target": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "tf_ops/grouping/tf_grouping.py": {
        "tensorflow": {
            "load_op_library_8": {
                "variable": {
                    "value": "grouping_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_grouping_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_55": {
                "op_type": {
                    "value": "GroupPoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_78": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(xyz1, (b, 1, n, c))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, m, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_79": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(xyz2, (b, m, 1, c))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, n, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_80": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(xyz1 - xyz2) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "top_k_86": {
                "variable": {
                    "value": "(val, idx)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "-dist",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "k": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "k",
                            "Method Argument"
                        ],
                        [
                            "k",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_100": {
                "variable": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.random((32, 512, 64)).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_101": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tmp1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.random((32, 512, 3)).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_102": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tmp2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.random((32, 128, 3)).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_78": {
                "tensor": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(tmp1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(xyz1, (b, 1, n, c)), [1, m, 1, 1])",
                            "Call"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ],
                        [
                            "xyz1",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(b, 1, n, c)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_79": {
                "tensor": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(tmp2)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(xyz2, (b, m, 1, c)), [1, 1, n, 1])",
                            "Call"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ],
                        [
                            "xyz2",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(b, m, 1, c)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "device_99": {
                "device_name": {
                    "value": "/gpu:1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_113": {
                "target": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "tf_ops/grouping/tf_grouping_op_test.py": {
        "tensorflow": {
            "main_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_12": {
                "variable": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.random((1, 128, 16)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_14": {
                "variable": {
                    "value": "xyz1",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.random((1, 128, 3)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_15": {
                "variable": {
                    "value": "xyz2",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.random((1, 8, 3)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "compute_gradient_error_24": {
                "variable": {
                    "value": "err",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.random.random((1, 128, 16)).astype('float32'))",
                            "Call"
                        ]
                    ]
                },
                "x_shape": {
                    "value": "(1, 128, 16)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y": {
                    "value": "grouped_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "group_point(points, idx)",
                            "Call"
                        ]
                    ]
                },
                "y_shape": {
                    "value": "(1, 8, 32, 16)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "device_11": {
                "device_name": {
                    "value": "/gpu:0",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "tf_ops/sampling/tf_sampling.py": {
        "tensorflow": {
            "load_op_library_13": {
                "variable": {
                    "value": "sampling_module",
                    "type": "variable",
                    "possible_values": []
                },
                "library_filename": {
                    "value": "os.path.join(BASE_DIR, 'tf_sampling_so.so')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RegisterGradient_52": {
                "op_type": {
                    "value": "GatherPoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_78": {
                "variable": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "triangles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.rand(1, 5, 3, 3).astype('float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_82": {
                "variable": {
                    "value": "areas",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.cross(trib - tria, tric - tria) ** 2, 2) + 1e-09",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_77": {
                "device_name": {
                    "value": "/gpu:1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_99": {
                "target": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "abs_90": {
                "x": {
                    "value": "us + vs - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_82": {
                "input_tensor": {
                    "value": "tf.cross(trib - tria, tric - tria) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_95": {
                "input": {
                    "value": "vs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform((1, 8192))",
                            "Call"
                        ],
                        [
                            "(uplusv - uminusv) * 0.5",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_94": {
                "input": {
                    "value": "us",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform((1, 8192))",
                            "Call"
                        ],
                        [
                            "(uplusv + uminusv) * 0.5",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cross_82": {
                "a": {
                    "value": "trib - tria",
                    "type": "BinOp",
                    "possible_values": []
                },
                "b": {
                    "value": "tric - tria",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "utils/loss.py": {
        "tensorflow": {
            "reshape_24": {
                "variable": {
                    "value": "reshaped_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prediction",
                            "Method Argument"
                        ],
                        [
                            "prediction",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, feature_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unique_with_counts_27": {
                "variable": {
                    "value": "(unique_labels, unique_id, counts)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "correct_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "correct_label",
                            "Method Argument"
                        ],
                        [
                            "correct_label",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_29": {
                "variable": {
                    "value": "counts",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "counts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ],
                        [
                            "tf.cast(counts, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_30": {
                "variable": {
                    "value": "num_instances",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "unique_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_32": {
                "variable": {
                    "value": "segmented_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "reshaped_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(prediction, [-1, feature_dim])",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "unique_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_instances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(unique_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "div_34": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "segmented_sum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_sum(reshaped_pred, unique_id, num_instances)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.reshape(counts, (-1, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_37": {
                "variable": {
                    "value": "mu_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(segmented_sum, tf.reshape(counts, (-1, 1)))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "unique_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ]
                    ]
                }
            },
            "norm_43": {
                "variable": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tmp_distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshaped_pred - mu_expand",
                            "BinOp"
                        ]
                    ]
                },
                "ord": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_45": {
                "variable": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(tmp_distance, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(distance, delta_v)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(distance, 0.0, distance)",
                            "Call"
                        ],
                        [
                            "tf.square(distance)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "delta_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "delta_v",
                            "Method Argument"
                        ],
                        [
                            "delta_v",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clip_by_value_46": {
                "variable": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(tmp_distance, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(distance, delta_v)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(distance, 0.0, distance)",
                            "Call"
                        ],
                        [
                            "tf.square(distance)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(tmp_distance, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(distance, delta_v)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(distance, 0.0, distance)",
                            "Call"
                        ],
                        [
                            "tf.square(distance)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_47": {
                "variable": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(tmp_distance, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(distance, delta_v)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(distance, 0.0, distance)",
                            "Call"
                        ],
                        [
                            "tf.square(distance)",
                            "Call"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_49": {
                "variable": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "distance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(tmp_distance, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(distance, delta_v)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(distance, 0.0, distance)",
                            "Call"
                        ],
                        [
                            "tf.square(distance)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "unique_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_instances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(unique_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "div_50": {
                "variable": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_sum(distance, unique_id, num_instances)",
                            "Call"
                        ],
                        [
                            "tf.div(l_var, counts)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(l_var)",
                            "Call"
                        ],
                        [
                            "tf.divide(l_var, tf.cast(num_instances, tf.float32))",
                            "Call"
                        ],
                        [
                            "param_var * l_var",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(out_var_op)",
                            "Call"
                        ],
                        [
                            "discriminative_loss_single(prediction[i], correct_label[i], feature_dim, delta_v, delta_d, param_var, param_dist)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "counts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ],
                        [
                            "tf.cast(counts, tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_51": {
                "variable": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_sum(distance, unique_id, num_instances)",
                            "Call"
                        ],
                        [
                            "tf.div(l_var, counts)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(l_var)",
                            "Call"
                        ],
                        [
                            "tf.divide(l_var, tf.cast(num_instances, tf.float32))",
                            "Call"
                        ],
                        [
                            "param_var * l_var",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(out_var_op)",
                            "Call"
                        ],
                        [
                            "discriminative_loss_single(prediction[i], correct_label[i], feature_dim, delta_v, delta_d, param_var, param_dist)",
                            "Call"
                        ]
                    ]
                }
            },
            "divide_52": {
                "variable": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_sum(distance, unique_id, num_instances)",
                            "Call"
                        ],
                        [
                            "tf.div(l_var, counts)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(l_var)",
                            "Call"
                        ],
                        [
                            "tf.divide(l_var, tf.cast(num_instances, tf.float32))",
                            "Call"
                        ],
                        [
                            "param_var * l_var",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(out_var_op)",
                            "Call"
                        ],
                        [
                            "discriminative_loss_single(prediction[i], correct_label[i], feature_dim, delta_v, delta_d, param_var, param_dist)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.cast(num_instances, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_67": {
                "variable": {
                    "value": "mu_interleaved_rep",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(segmented_sum, tf.reshape(counts, (-1, 1)))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[num_instances, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_68": {
                "variable": {
                    "value": "mu_band_rep",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(segmented_sum, tf.reshape(counts, (-1, 1)))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, num_instances]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_69": {
                "variable": {
                    "value": "mu_band_rep",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu_band_rep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(mu, [1, num_instances])",
                            "Call"
                        ],
                        [
                            "tf.reshape(mu_band_rep, (num_instances * num_instances, feature_dim))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(num_instances * num_instances, feature_dim)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "subtract_71": {
                "variable": {
                    "value": "mu_diff",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu_band_rep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(mu, [1, num_instances])",
                            "Call"
                        ],
                        [
                            "tf.reshape(mu_band_rep, (num_instances * num_instances, feature_dim))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mu_interleaved_rep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(mu, [num_instances, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "eye_74": {
                "variable": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": []
                },
                "num_rows": {
                    "value": "num_instances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(unique_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_75": {
                "variable": {
                    "value": "zero",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_76": {
                "variable": {
                    "value": "diff_cluster_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "eye",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.eye(num_instances)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "zero",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros(1, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_77": {
                "variable": {
                    "value": "diff_cluster_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "diff_cluster_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(eye, zero)",
                            "Call"
                        ],
                        [
                            "tf.reshape(diff_cluster_mask, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_78": {
                "variable": {
                    "value": "mu_diff_bool",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(mu_band_rep, mu_interleaved_rep)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "diff_cluster_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(eye, zero)",
                            "Call"
                        ],
                        [
                            "tf.reshape(diff_cluster_mask, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "norm_80": {
                "variable": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mu_diff_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(mu_diff, diff_cluster_mask)",
                            "Call"
                        ]
                    ]
                },
                "ord": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_81": {
                "variable": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "2.0 * delta_d",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(mu_diff_bool, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(2.0 * delta_d, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(mu_norm, 0.0, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.square(mu_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_82": {
                "variable": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(mu_diff_bool, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(2.0 * delta_d, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(mu_norm, 0.0, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.square(mu_norm)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(mu_diff_bool, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(2.0 * delta_d, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(mu_norm, 0.0, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.square(mu_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_83": {
                "variable": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(mu_diff_bool, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(2.0 * delta_d, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(mu_norm, 0.0, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.square(mu_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_85": {
                "variable": {
                    "value": "l_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mu_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(mu_diff_bool, ord=1, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.subtract(2.0 * delta_d, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(mu_norm, 0.0, mu_norm)",
                            "Call"
                        ],
                        [
                            "tf.square(mu_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_91": {
                "variable": {
                    "value": "l_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(1, num_instances)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "rt_0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rt_0",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "rt_l_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rt_l_dist",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorArray_120": {
                "variable": {
                    "value": "output_ta_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dynamic_size": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TensorArray_121": {
                "variable": {
                    "value": "output_ta_var",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dynamic_size": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TensorArray_122": {
                "variable": {
                    "value": "output_ta_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dynamic_size": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "while_loop_124": {
                "variable": {
                    "value": "(_, _, out_loss_op, out_var_op, out_dist_op, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "cond",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cond",
                            "Call"
                        ]
                    ]
                },
                "body": {
                    "value": "body",
                    "type": "variable",
                    "possible_values": [
                        [
                            "body",
                            "Call"
                        ]
                    ]
                },
                "loop_vars": {
                    "value": "[correct_label, prediction, output_ta_loss, output_ta_var, output_ta_dist, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_129": {
                "variable": {
                    "value": "disc_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_loss_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.while_loop(cond, body, [correct_label, prediction, output_ta_loss, output_ta_var, output_ta_dist, 0])",
                            "Call"
                        ],
                        [
                            "out_loss_op.stack()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_130": {
                "variable": {
                    "value": "l_var",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_var_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.while_loop(cond, body, [correct_label, prediction, output_ta_loss, output_ta_var, output_ta_dist, 0])",
                            "Call"
                        ],
                        [
                            "out_var_op.stack()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_131": {
                "variable": {
                    "value": "l_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "out_dist_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.while_loop(cond, body, [correct_label, prediction, output_ta_loss, output_ta_var, output_ta_dist, 0])",
                            "Call"
                        ],
                        [
                            "out_dist_op.stack()",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_34": {
                "tensor": {
                    "value": "counts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique_with_counts(correct_label)",
                            "Call"
                        ],
                        [
                            "tf.cast(counts, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_52": {
                "x": {
                    "value": "num_instances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(unique_labels)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_91": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "num_instances",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(unique_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_108": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "i",
                            "Method Argument"
                        ],
                        [
                            "i",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(batch)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_108": {
                "input": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch",
                            "Method Argument"
                        ],
                        [
                            "batch",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "utils/pointnet_util.py": {
        "tensorflow": {
            "constant_75": {
                "variable": {
                    "value": "new_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.tile(np.array([0, 0, 0]).reshape((1, 1, 3)), (batch_size, 1, 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_77": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.tile(np.array(range(nsample)).reshape((1, 1, nsample)), (batch_size, 1, 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_78": {
                "variable": {
                    "value": "grouped_xyz",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xyz",
                            "Method Argument"
                        ],
                        [
                            "xyz",
                            "Method Argument"
                        ],
                        [
                            "xyz",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, 1, nsample, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tile_48": {
                "input": {
                    "value": "tf.expand_dims(new_xyz, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, nsample, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_84": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_158": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_175": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ],
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_176": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1.0 / dist",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_177": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_185": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=2, values=[interpolated_points, points1])",
                            "Call"
                        ],
                        [
                            "interpolated_points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points1, 2)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points1, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_%d' % i, bn_decay=bn_decay, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points1, [2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_192": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(axis=2, values=[interpolated_points, points1])",
                            "Call"
                        ],
                        [
                            "interpolated_points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points1, 2)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points1, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_%d' % i, bn_decay=bn_decay, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points1, [2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_207": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ],
                        [
                            "three_nn(xyz1, xyz2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(dist, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_208": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1.0 / dist",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_209": {
                "variable": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(1.0 / dist, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(norm, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_48": {
                "input": {
                    "value": "new_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gather_point(xyz, farthest_point_sample(npoint, xyz))",
                            "Call"
                        ],
                        [
                            "tf.constant(np.tile(np.array([0, 0, 0]).reshape((1, 1, 3)), (batch_size, 1, 1)), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_52": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[grouped_xyz, grouped_points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_81": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[xyz, points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_111": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_120": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_127": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_131": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "maxpool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_173": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_182": {
                "variable": {
                    "value": "new_points1",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[interpolated_points, points1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_205": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_133": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "avgpool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_149": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_156": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "norm_136": {
                "variable": {
                    "value": "dists",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "grouped_xyz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "group_point(xyz, idx)",
                            "Call"
                        ],
                        [
                            "grouped_xyz - tf.tile(tf.expand_dims(new_xyz, 2), [1, 1, nsample, 1])",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(xyz, (batch_size, 1, nsample, 3))",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "exp_137": {
                "variable": {
                    "value": "exp_dists",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-dists * 5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_141": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_143": {
                "variable": {
                    "value": "max_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "maxpool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_144": {
                "variable": {
                    "value": "avg_points",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([grouped_xyz, grouped_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "grouped_points",
                            "variable"
                        ],
                        [
                            "grouped_xyz",
                            "variable"
                        ],
                        [
                            "tf.concat([xyz, points], axis=2)",
                            "Call"
                        ],
                        [
                            "points",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(new_points, 1)",
                            "Call"
                        ],
                        [
                            "sample_and_group_all(xyz, points, use_xyz)",
                            "Call"
                        ],
                        [
                            "sample_and_group(npoint, radius, nsample, xyz, points, knn, use_xyz)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(new_points, axis=[2], keep_dims=True, name='maxpool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(new_points, axis=[2], keep_dims=True, name='avgpool')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(new_points, [2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "new_points * weights",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(new_points, axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.concat([avg_points, max_points], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf_util.conv2d(new_points, num_out_channel, [1, 1], padding='VALID', stride=[1, 1], bn=bn, is_training=is_training, scope='conv_post_%d' % i, bn_decay=bn_decay, data_format=data_format, is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "tf.transpose(new_points, [0, 2, 3, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "avgpool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_145": {
                "variable": {
                    "value": "new_points",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[avg_points, max_points]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_135": {
                "name_or_scope": {
                    "value": "weighted_avg",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_138": {
                "input_tensor": {
                    "value": "exp_dists",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-dists * 5)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "utils/tf_util.py": {
        "tensorflow": {
            "set_random_seed_17": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seed",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_31": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.xavier_initializer()",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal_initializer(stddev=stddev)",
                            "Call"
                        ],
                        [
                            "initializer",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float16 if use_fp16 else tf.float32",
                            "IfExp"
                        ]
                    ]
                },
                "trainable": {
                    "value": "trainable",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "truncated_normal_initializer_55": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stddev",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "multiply_58": {
                "variable": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.l2_loss(var)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "wd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wd",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "weight_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv1d_106": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ],
                        [
                            "[2",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_111": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs, axis=axis, keep_dims=keepdims, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(initial_bias))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_169": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_175": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs, axis=axis, keep_dims=keepdims, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(initial_bias))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_233": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_transpose_311": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size, out_height, out_width, num_output_channels]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_316": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs, axis=axis, keep_dims=keepdims, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(initial_bias))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv3d_372": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ],
                        [
                            "_variable_with_weight_decay('weights', shape=kernel_shape, use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_377": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs, axis=axis, keep_dims=keepdims, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(initial_bias))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_415": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_with_weight_decay('weights', shape=[num_input_units, num_outputs], use_xavier=use_xavier, stddev=stddev, wd=weight_decay)",
                            "Call"
                        ]
                    ]
                }
            },
            "bias_add_418": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs, axis=axis, keep_dims=keepdims, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(initial_bias))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_439": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "keepdims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_441": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(inputs, kernel, stride=stride, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv1d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(inputs, kernel, [1, stride_h, stride_w, 1], padding=padding, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d_transpose(inputs, kernel, output_shape, [1, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv3d(inputs, kernel, [1, stride_d, stride_h, stride_w, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv3d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_fc(outputs, is_training, bn_decay, 'bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs, axis=axis, keep_dims=keepdims, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(outputs, biases)",
                            "Call"
                        ],
                        [
                            "batch_norm_for_conv2d(outputs, is_training, bn_decay=bn_decay, scope='bn', is_dist=is_dist)",
                            "Call"
                        ],
                        [
                            "activation_fn(outputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool(inputs, ksize=[1, kernel_h, kernel_w, 1], strides=[1, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.max_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.nn.avg_pool3d(inputs, ksize=[1, kernel_d, kernel_h, kernel_w, 1], strides=[1, stride_d, stride_h, stride_w, 1], padding=padding, name=sc.name)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, lambda : tf.nn.dropout(inputs, keep_prob, noise_shape), lambda : inputs)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(initial_bias))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_outputs], tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('biases', [num_output_channels], tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pool_469": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_495": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool3d_521": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool3d_547": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, kernel_d, kernel_h, kernel_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, stride_d, stride_h, stride_w, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "'VALID'",
                            "Method Argument"
                        ],
                        [
                            "padding",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "sc.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_570": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(0.0, shape=[num_channels])",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_573": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(1.0, shape=[num_channels])",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "moments_576": {
                "variable": {
                    "value": "(batch_mean, batch_var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "moments_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "moments_dims",
                            "Method Argument"
                        ],
                        [
                            "moments_dims",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "moments",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_578": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_decay if bn_decay is not None else 0.9",
                            "IfExp"
                        ],
                        [
                            "bn_decay if bn_decay is not None else 0.9",
                            "IfExp"
                        ]
                    ]
                }
            },
            "cond_580": {
                "variable": {
                    "value": "ema_apply_op",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : ema.apply([batch_mean, batch_var])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.no_op()",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_590": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "mean_var_with_update",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mean_var_with_update",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : (ema.average(batch_mean), ema.average(batch_var))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "batch_normalization_593": {
                "variable": {
                    "value": "normed",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(is_training, mean_var_with_update, lambda : (ema.average(batch_mean), ema.average(batch_var)))",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, mean_var_with_update, lambda : (ema.average(batch_mean), ema.average(batch_var)))",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='beta', initializer=tf.constant(0.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('beta', [num_channels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='gamma', initializer=tf.constant(1.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('gamma', [num_channels], initializer=tf.ones_initializer())",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cond_627": {
                "variable": {
                    "value": "normed",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "train_bn_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "train_bn_op",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "test_bn_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "test_bn_op",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_723": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(inputs, keep_prob, noise_shape)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "device_29": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_59": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_decay",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(tf.nn.l2_loss(var), wd, name='weight_loss')",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_97": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_158": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_222": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_283": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_361": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_408": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_437": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_466": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_492": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_518": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_544": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_568": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_608": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "moments_617": {
                "variable": {
                    "value": "(batch_mean, batch_var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "moments_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "moments_dims",
                            "Method Argument"
                        ],
                        [
                            "moments_dims",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "moments",
                    "type": "str",
                    "possible_values": []
                }
            },
            "assign_619": {
                "variable": {
                    "value": "train_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "pop_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('pop_mean', [num_channels], initializer=tf.zeros_initializer(), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "pop_mean * decay + batch_mean * (1 - decay)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assign_620": {
                "variable": {
                    "value": "train_var",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "pop_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('pop_var', [num_channels], initializer=tf.ones_initializer(), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "pop_var * decay + batch_var * (1 - decay)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_722": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ],
                        [
                            "scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "l2_loss_58": {
                "t": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, shape, initializer=initializer, dtype=dtype, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu(name, shape, initializer)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, mean_var_with_update, lambda : (ema.average(batch_mean), ema.average(batch_var)))",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_110": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_174": {
                "value": {
                    "value": "initial_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_315": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_376": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_417": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_440": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "batch_normalization_625": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "pop_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('pop_mean', [num_channels], initializer=tf.zeros_initializer(), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "pop_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_variable_on_cpu('pop_var', [num_channels], initializer=tf.ones_initializer(), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='beta', initializer=tf.constant(0.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('beta', [num_channels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='gamma', initializer=tf.constant(1.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('gamma', [num_channels], initializer=tf.ones_initializer())",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_571": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_574": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "no_op_582": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_586": {
                "control_inputs": {
                    "value": "[ema_apply_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_610": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_611": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_613": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_614": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_621": {
                "control_inputs": {
                    "value": "[train_mean, train_var]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_normalization_622": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "batch_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, moments_dims, name='moments')",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, moments_dims, name='moments')",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "batch_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, moments_dims, name='moments')",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, moments_dims, name='moments')",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='beta', initializer=tf.constant(0.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('beta', [num_channels], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='gamma', initializer=tf.constant(1.0, shape=[num_channels]), trainable=True)",
                            "Call"
                        ],
                        [
                            "_variable_on_cpu('gamma', [num_channels], initializer=tf.ones_initializer())",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "dropout_724": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "identity_587": {
                "input": {
                    "value": "batch_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, moments_dims, name='moments')",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, moments_dims, name='moments')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}