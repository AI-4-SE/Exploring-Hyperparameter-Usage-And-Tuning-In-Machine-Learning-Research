{
    "dagan_architectures.py": {
        "tensorflow": {
            "concat_127": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "current_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[input]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "[input]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_186": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "current_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[input]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "[input]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_216": {
                "variable": {
                    "value": "conditional_input",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "conditional_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(conditional_input)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(conditional_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_361": {
                "variable": {
                    "value": "self.variables",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_448": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "current_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[input]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "[input]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ],
                        [
                            "[input, skip_connect_layer]",
                            "List"
                        ],
                        [
                            "remove_duplicates(current_layers)",
                            "Call"
                        ],
                        [
                            "[outputs]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_471": {
                "variable": {
                    "value": "conditional_input",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "conditional_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(conditional_input)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(conditional_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_472": {
                "variable": {
                    "value": "generated_input",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "generated_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(generated_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_534": {
                "variable": {
                    "value": "self.variables",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "resize_nearest_neighbor_54": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "(h_size, w_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "conv2d_transpose_73": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ],
                        [
                            "num_filters / 2",
                            "BinOp"
                        ],
                        [
                            "int(num_filters)",
                            "Call"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "filter_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_131": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_135": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_138": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "leaky_relu_191": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_196": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_200": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "resize_nearest_neighbor_397": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "(h * scale, w * scale)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "conv2d_transpose_412": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "num_filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ],
                        [
                            "num_filters / 2",
                            "BinOp"
                        ],
                        [
                            "int(num_filters)",
                            "Call"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "filter_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_451": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_453": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ],
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "leaky_relu_456": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_474": {
                "variable": {
                    "value": "concat_images",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[conditional_input, generated_input]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv2d_77": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "num_filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ],
                        [
                            "num_filters / 2",
                            "BinOp"
                        ],
                        [
                            "int(num_filters)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_217": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "self.reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_358": {
                "variable": {
                    "value": "gan_decoder",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "outputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_415": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "num_filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "int"
                        ],
                        [
                            "num_filters / 2",
                            "BinOp"
                        ],
                        [
                            "int(num_filters)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_473": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "self.reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_528": {
                "variable": {
                    "value": "feature_level_dense",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "feature_level_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(encoder_layers[-1], axis=[1, 2])",
                            "Call"
                        ],
                        [
                            "tf.concat(mean_encoder_layers, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "leaky_relu",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "concat_529": {
                "variable": {
                    "value": "combo_level_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[feature_level_dense, location_level_flatten]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_531": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "combo_level_flatten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([feature_level_dense, location_level_flatten], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "outputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_222": {
                "name_or_scope": {
                    "value": "conv_layers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_259": {
                "name_or_scope": {
                    "value": "vector_expansion",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_271": {
                "variable": {
                    "value": "z_dense",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "z_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "h * w * num_filters",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_272": {
                "variable": {
                    "value": "z_reshape_noise",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "z_dense",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(z_inputs, h * w * num_filters)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, h, w, num_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_281": {
                "name_or_scope": {
                    "value": "g_deconv_layers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "leaky_relu_347": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_357": {
                "name_or_scope": {
                    "value": "g_tanh",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_478": {
                "name_or_scope": {
                    "value": "conv_layers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_515": {
                "name_or_scope": {
                    "value": "discriminator_dense_block",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_522": {
                "variable": {
                    "value": "feature_level_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "mean_encoder_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_523": {
                "variable": {
                    "value": "location_level_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "concat_encoder_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_525": {
                "variable": {
                    "value": "feature_level_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "encoder_layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "flatten_526": {
                "variable": {
                    "value": "location_level_flatten",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "encoder_layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_530": {
                "name_or_scope": {
                    "value": "discriminator_out_block",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_284": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z_layers[i], outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_293": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[outputs, conditional_input]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_226": {
                "name_or_scope": {
                    "value": "'g_conv{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "leaky_relu_230": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_296": {
                "name_or_scope": {
                    "value": "'g_deconv{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_339": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[outputs, encoder_layers[idx - 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_481": {
                "name_or_scope": {
                    "value": "'g_conv{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "leaky_relu_485": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.upscale(inputs, h_size=h_size, w_size=w_size)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(outputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=True, w_size=w_size, h_size=h_size)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "conditional_input",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, training=training, name='encoder_layer_{}_{}'.format(i, j), layer_to_skip_connect=current_layers, num_features=self.layer_sizes[i], dim_reduce=False, local_inner_layers=encoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_layer_{}'.format(i), training=training, layer_to_skip_connect=current_layers, local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dim_reduce=True, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "g_conv_encoder",
                            "variable"
                        ],
                        [
                            "tf.concat([z_layers[i], outputs], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, conditional_input], axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.layer_sizes[0], [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "batch_norm(outputs, decay=0.99, scale=True, center=True, is_training=training, renorm=True)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, self.num_channels, [3, 3], strides=(1, 1), transpose=False)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=False, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.add_decoder_layer(input=outputs, name='decoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers, num_features=num_features, dim_upscale=True, local_inner_layers=decoder_inner_layers, w_size=upscale_shape[1], h_size=upscale_shape[2], dropout_rate=dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.concat([outputs, encoder_layers[idx - 1]], axis=3)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs, num_filters, filter_size, strides=strides, padding='SAME', activation=activation)",
                            "Call"
                        ],
                        [
                            "tf.concat(current_layers, axis=3)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(outputs, rate=dropout_rate, training=training)",
                            "Call"
                        ],
                        [
                            "self.conv_layer(outputs, num_features, [3, 3], strides=(1, 1))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "concat_images",
                            "variable"
                        ],
                        [
                            "self.conv_layer(outputs, num_filters=64, filter_size=(3, 3), strides=(2, 2))",
                            "Call"
                        ],
                        [
                            "leaky_relu(features=outputs)",
                            "Call"
                        ],
                        [
                            "layer_norm(inputs=outputs, center=True, scale=True)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_inner_conv_{}_{}'.format(i, j), training=training, layer_to_skip_connect=current_layers[-2], num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=False, local_inner_layers=encoder_inner_layers)",
                            "Call"
                        ],
                        [
                            "self.add_encoder_layer(input=outputs, name='encoder_outer_conv_{}'.format(i), training=training, layer_to_skip_connect=current_layers[-2], local_inner_layers=encoder_inner_layers, num_features=self.layer_sizes[i], dropout_rate=dropout_rate, dim_reduce=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(combo_level_flatten, 1, name='outputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_520": {
                "input_tensor": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_layers",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "flatten_521": {
                "structure": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_layers",
                            "variable"
                        ]
                    ]
                }
            }
        }
    },
    "dagan_networks_wgan.py": {
        "tensorflow": {
            "unstack_55": {
                "variable": {
                    "value": "random_variable",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.random_uniform([1], minval=0, maxval=4, dtype=tf.int32, seed=None, name=None)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "rot90_56": {
                "variable": {
                    "value": "image_a",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.rot90(image_a, k=random_variable[0])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "random_variable[0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.unstack(tf.random_uniform([1], minval=0, maxval=4, dtype=tf.int32, seed=None, name=None))",
                            "Call"
                        ]
                    ]
                }
            },
            "rot90_57": {
                "variable": {
                    "value": "image_b",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image_b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.rot90(image_b, k=random_variable[0])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "random_variable[0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.unstack(tf.random_uniform([1], minval=0, maxval=4, dtype=tf.int32, seed=None, name=None))",
                            "Call"
                        ]
                    ]
                }
            },
            "unstack_104": {
                "variable": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.random_uniform([1], minval=0, maxval=2, dtype=tf.int32, seed=None, name=None)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_105": {
                "variable": {
                    "value": "rotate_boolean",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(tf.random_uniform([1], minval=0, maxval=2, dtype=tf.int32, seed=None, name=None))",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "check-rotate-boolean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_106": {
                "variable": {
                    "value": "[image_a, image_b]",
                    "type": "List",
                    "possible_values": []
                },
                "pred": {
                    "value": "rotate_boolean[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : self.rotate_data(image_a, image_b)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : [image_a, image_b]",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_117": {
                "variable": {
                    "value": "[images_a, images_b]",
                    "type": "List",
                    "possible_values": []
                },
                "pred": {
                    "value": "self.augment",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : self.rotate_batch(batch_images_a, batch_images_b)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : [batch_images_a, batch_images_b]",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "get_collection_213": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_all_253": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "unstack_71": {
                "variable": {
                    "value": "batch_images_unpacked_a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "batch_images_a",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_72": {
                "variable": {
                    "value": "batch_images_unpacked_b",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "batch_images_b",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_80": {
                "variable": {
                    "value": "new_images_a",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "new_images_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(new_images_a)",
                            "Call"
                        ],
                        [
                            "tf.reshape(new_images_a, (batch_size, x, y, c))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_81": {
                "variable": {
                    "value": "new_images_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "new_images_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(new_images_a)",
                            "Call"
                        ],
                        [
                            "tf.reshape(new_images_a, (batch_size, x, y, c))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, x, y, c)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "stack_82": {
                "variable": {
                    "value": "new_images_b",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "new_images_b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(new_images_b)",
                            "Call"
                        ],
                        [
                            "tf.reshape(new_images_b, (batch_size, x, y, c))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_83": {
                "variable": {
                    "value": "new_images_b",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "new_images_b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(new_images_b)",
                            "Call"
                        ],
                        [
                            "tf.reshape(new_images_b, (batch_size, x, y, c))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, x, y, c)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_133": {
                "variable": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "unstack_136": {
                "variable": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features[i], shape=(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels))",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=4)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(activations_features, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_137": {
                "variable": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features[i], shape=(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels))",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=4)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(activations_features, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_138": {
                "variable": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features[i], shape=(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels))",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=4)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(activations_features, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_139": {
                "variable": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features[i], shape=(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels))",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=4)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(activations_features, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_140": {
                "variable": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features[i], shape=(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels))",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=4)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(activations_features, axis=3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_178": {
                "variable": {
                    "value": "differences_g",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "differences_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_g - input_b",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(differences_g, (self.batch_size, input_shape[1] * input_shape[2] * input_shape[3]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(self.batch_size, input_shape[1] * input_shape[2] * input_shape[3])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "sqrt_184": {
                "variable": {
                    "value": "slopes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(gradients), reduction_indices=[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_185": {
                "variable": {
                    "value": "gradient_penalty",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(slopes - 1.0) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_249": {
                "variable": {
                    "value": "losses[key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses[key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_250": {
                "variable": {
                    "value": "opts[key.replace(losses, opt)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "beta1": {
                    "value": "beta1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "beta2": {
                    "value": "beta2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Method Argument"
                        ]
                    ]
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_70": {
                "name": {
                    "value": "augment",
                    "type": "str",
                    "possible_values": []
                }
            },
            "image_141": {
                "name": {
                    "value": "'{}_{}'.format(name, i)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "activations_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features[i], shape=(shape_in[0], shape_in[1], shape_in[2], y_channels, x_channels))",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=4)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.unstack(activations_features, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(activations_features, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(activations_features, axis=3)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_150": {
                "name": {
                    "value": "'losses_{}'.format(gpu_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collection_188": {
                "name": {
                    "value": "g_losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "g_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(d_fake)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "add_to_collection_189": {
                "name": {
                    "value": "d_losses",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "d_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(d_fake) - tf.reduce_mean(d_real)",
                            "BinOp"
                        ],
                        [
                            "d_loss + 10 * gradient_penalty",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_190": {
                "name": {
                    "value": "g_losses",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "g_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(d_fake)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "scalar_191": {
                "name": {
                    "value": "d_losses",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "d_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(d_fake) - tf.reduce_mean(d_real)",
                            "BinOp"
                        ],
                        [
                            "d_loss + 10 * gradient_penalty",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_193": {
                "name": {
                    "value": "d_loss_real",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(d_real)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_194": {
                "name": {
                    "value": "d_loss_fake",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(d_fake)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_195": {
                "name": {
                    "value": "output_generated_images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "[tf.concat(tf.unstack(x_g, axis=0), axis=0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_196": {
                "name": {
                    "value": "output_input_a",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "[tf.concat(tf.unstack(input_a, axis=0), axis=0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_197": {
                "name": {
                    "value": "output_input_b",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "[tf.concat(tf.unstack(input_b, axis=0), axis=0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_200": {
                "inputs": {
                    "value": "tf.get_collection('g_losses')",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "total_g_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_n_201": {
                "inputs": {
                    "value": "tf.get_collection('d_losses')",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "total_d_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_214": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_167": {
                "input_tensor": {
                    "value": "d_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "t_same_class_outputs",
                            "variable"
                        ]
                    ]
                }
            },
            "reduce_mean_168": {
                "input_tensor": {
                    "value": "d_fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g_same_class_outputs",
                            "variable"
                        ]
                    ]
                }
            },
            "reshape_179": {
                "tensor": {
                    "value": "alpha * differences_g",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.batch_size, input_shape[1], input_shape[2], input_shape[3])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "gradients_183": {
                "ys": {
                    "value": "pre_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "xs": {
                    "value": "[interpolates_g, input_a]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_184": {
                "input_tensor": {
                    "value": "tf.square(gradients)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_193": {
                "input_tensor": {
                    "value": "d_real",
                    "type": "variable",
                    "possible_values": [
                        [
                            "t_same_class_outputs",
                            "variable"
                        ]
                    ]
                }
            },
            "reduce_mean_194": {
                "input_tensor": {
                    "value": "d_fake",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g_same_class_outputs",
                            "variable"
                        ]
                    ]
                }
            },
            "get_collection_200": {
                "key": {
                    "value": "g_losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_201": {
                "key": {
                    "value": "d_losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_240": {
                "device_name": {
                    "value": "device_id",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_184": {
                "x": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(pre_grads, [interpolates_g, input_a])[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_195": {
                "values": {
                    "value": "tf.unstack(x_g, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_196": {
                "values": {
                    "value": "tf.unstack(input_a, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_197": {
                "values": {
                    "value": "tf.unstack(input_b, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_195": {
                "value": {
                    "value": "x_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate(input_a)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_196": {
                "value": {
                    "value": "input_a",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_197": {
                "value": {
                    "value": "input_b",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "experiment_builder.py": {
        "tensorflow": {}
    },
    "generation_builder.py": {
        "tensorflow": {}
    }
}