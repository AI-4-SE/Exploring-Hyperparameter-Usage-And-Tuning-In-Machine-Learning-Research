{
    "antigen-classification-problem/model/comparisons/dnn-handcrafted-early-stopping/dataset.py": {
        "sklearn": {
            "DictVectorizer_55": {
                "variable": {
                    "value": "onehot_encoder",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/dnn-handcrafted-early-stopping/train_val_test.py": {
        "sklearn": {},
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/mr-handcrafter-early-stopping/dataset.py": {
        "sklearn": {
            "DictVectorizer_55": {
                "variable": {
                    "value": "onehot_encoder",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/mr-handcrafter-early-stopping/train_val_test.py": {
        "sklearn": {},
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/rf-handcrafted/dataset.py": {
        "sklearn": {
            "DictVectorizer_55": {
                "variable": {
                    "value": "onehot_encoder",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/rf-handcrafted/train_test.py": {
        "sklearn": {
            "RandomForestClassifier_72": {
                "variable": {
                    "value": "predictor",
                    "type": "variable",
                    "possible_values": []
                },
                "n_estimators": {
                    "value": "200",
                    "type": "int",
                    "possible_values": []
                }
            },
            "accuracy_score_89": {
                "variable": {
                    "value": "a_train",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "label_float2int(ys_train, num_tags)",
                    "type": "Call",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "ps_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predictor.predict(xs_train)",
                            "Call"
                        ]
                    ]
                },
                "sample_weight": {
                    "value": "fs_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_datasets(args.database, [args.table_train, args.table_test], args.tags, permute=args.permute)",
                            "Call"
                        ]
                    ]
                }
            },
            "accuracy_score_94": {
                "variable": {
                    "value": "a_test",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "label_float2int(ys_test, num_tags)",
                    "type": "Call",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "ps_test",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predictor.predict(xs_test)",
                            "Call"
                        ]
                    ]
                },
                "sample_weight": {
                    "value": "fs_test",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_datasets(args.database, [args.table_train, args.table_test], args.tags, permute=args.permute)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "antigen-classification-problem/model/Alignment.py": {
        "tensorflow": {
            "any_54": {
                "a": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_61": {
                "variable": {
                    "value": "lengths_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "K.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_62": {
                "variable": {
                    "value": "lengths_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.weight_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_63": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "lengths_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.sum(K.cast(mask, dtype=inputs.dtype), axis=1, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "lengths_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.cast(self.weight_steps, inputs.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_61": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_64": {
                "x": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.minimum(lengths_feature, lengths_weight)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "antigen-classification-problem/model/Length.py": {
        "tensorflow": {
            "sum_18": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "K.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "any_16": {
                "a": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_18": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/NormalizeInitialization.py": {
        "tensorflow": {
            "expand_dims_43": {
                "variable": {
                    "value": "weights_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "weighted_moments_45": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "frequency_weights": {
                    "value": "weights_expand",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(weights, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sign_48": {
                "variable": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "counter - K.ones_like(counter)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_53": {
                "variable": {
                    "value": "mean_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.weighted_moments(inputs, [0], weights_expand)",
                            "Call"
                        ],
                        [
                            "K.update(self.mean, init * self.mean + (1.0 - init) * mean)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_54": {
                "variable": {
                    "value": "variance_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.weighted_moments(inputs, [0], weights_expand)",
                            "Call"
                        ],
                        [
                            "K.update(self.variance, init * self.variance + (1.0 - init) * variance)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_42": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ones_like_47": {
                "input": {
                    "value": "self.counter",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_56": {
                "x": {
                    "value": "variance_expand + self.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_like_48": {
                "input": {
                    "value": "counter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.update_add(self.counter, K.ones_like(self.counter))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "antigen-classification-problem/model/alignment_score.py": {
        "tensorflow": {
            "where_31": {
                "variable": {
                    "value": "scores[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "masks[:, i - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "scores[i - 1][0] + penalties_feature",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "scores[i - 1][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tensordot_43": {
                "variable": {
                    "value": "similarities",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "features[:, i - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "weights[j - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_44": {
                "variable": {
                    "value": "scores_update",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack([scores[i - 1][j - 1] + similarities, scores[i][j - 1] + penalties_weight, scores[i - 1][j] + penalties_feature], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_55": {
                "variable": {
                    "value": "scores[i][j]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "masks[:, i - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "scores_update",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(tf.stack([scores[i - 1][j - 1] + similarities, scores[i][j - 1] + penalties_weight, scores[i - 1][j] + penalties_feature], axis=1), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "scores[i - 1][j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_15": {
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_25": {
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.shape(features)[0]] + list(weights.get_shape()[2:])",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "stack_45": {
                "values": {
                    "value": "[scores[i - 1][j - 1] + similarities, scores[i][j - 1] + penalties_weight, scores[i - 1][j] + penalties_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/cnn-shallow/GlobalPool.py": {
        "tensorflow": {
            "expand_dims_16": {
                "variable": {
                    "value": "indicators",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_18": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs + penalties",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_any_14": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_16": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/cnn-shallow/MaskCopy.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/cnn-shallow/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/cnn/GlobalPool.py": {
        "tensorflow": {
            "expand_dims_16": {
                "variable": {
                    "value": "indicators",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_18": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs + penalties",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_any_14": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_16": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/cnn/MaskCopy.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/cnn/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/dkm-kmer/KMer.py": {
        "tensorflow": {
            "stack_34": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "kmers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_17": {
                "values": {
                    "value": "[tf.expand_dims(mask[:, 0], axis=1), mask[:, self.k:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_19": {
                "input": {
                    "value": "mask[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_29": {
                "values": {
                    "value": "[inputs[:, i + j] for j in range(self.k)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/comparisons/dkm-kmer/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/gru/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/lstm/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/comparisons/nn-tcrdist3/dataset.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/dataset.py": {
        "tensorflow": {
            "convert_to_tensor_190": {
                "variable": {
                    "value": "features_tra_cdr3",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_tra_cdr3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, max_steps, num_features_cdr3], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "features_tra_cdr3[indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(features_tra_cdr3, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_191": {
                "variable": {
                    "value": "features_tra_vgene",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_tra_vgene",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, num_features_tra_vgene], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "features_tra_vgene[indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(features_tra_vgene, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_192": {
                "variable": {
                    "value": "features_tra_jgene",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_tra_jgene",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, num_features_tra_jgene], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "features_tra_jgene[indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(features_tra_jgene, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_193": {
                "variable": {
                    "value": "features_trb_cdr3",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_trb_cdr3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, max_steps, num_features_cdr3], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "features_trb_cdr3[indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(features_trb_cdr3, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_194": {
                "variable": {
                    "value": "features_trb_vgene",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_trb_vgene",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, num_features_trb_vgene], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "features_trb_vgene[indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(features_trb_vgene, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_195": {
                "variable": {
                    "value": "features_trb_jgene",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features_trb_jgene",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, num_features_trb_jgene], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "features_trb_jgene[indices]",
                            "Subscript"
                        ],
                        [
                            "tf.convert_to_tensor(features_trb_jgene, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_196": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_samples, num_categories], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(labels, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_197": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "weights / num_categories",
                            "BinOp"
                        ],
                        [
                            "np.zeros([num_samples], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(weights, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/dump_model.py": {
        "tensorflow": {
            "global_variables_initializer_79": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_87": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/metrics.py": {
        "tensorflow": {
            "reduce_sum_12": {
                "variable": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights * costs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_16": {
                "variable": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_18": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.argmax(labels, axis=1), tf.argmax(probabilities, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "probabilities.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_25": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights * corrects",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_30": {
                "variable": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_34": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.argmax(labels, axis=1), tf.argmax(probabilities, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "probabilities.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argsort_42": {
                "variable": {
                    "value": "indices_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_43": {
                "variable": {
                    "value": "entropies_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(entropies, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_44": {
                "variable": {
                    "value": "corrects_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.equal(tf.argmax(labels, axis=1), tf.argmax(probabilities, axis=1)), probabilities.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.equal(tf.argmax(labels, axis=1), tf.argmax(probabilities, axis=1)), probabilities.dtype)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.equal(tf.argmax(labels, axis=1), tf.argmax(probabilities, axis=1)), probabilities.dtype)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(entropies, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_45": {
                "variable": {
                    "value": "weights_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argsort(entropies, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_47": {
                "variable": {
                    "value": "numerators_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights_sorted * corrects_sorted",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_48": {
                "variable": {
                    "value": "denominators_sorted",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(weights, indices_sorted)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_52": {
                "variable": {
                    "value": "indices_threshold",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "accuracies_sorted > tf.constant(target_accuracy, accuracies_sorted.dtype)",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.cumsum(tf.ones_like(accuracies_sorted, dtype=tf.int64), axis=0) - 1",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(range)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_57": {
                "variable": {
                    "value": "index_threshold",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "indices_threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(accuracies_sorted > tf.constant(target_accuracy, accuracies_sorted.dtype), range, tf.zeros_like(range))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_59": {
                "variable": {
                    "value": "entropy_threshold",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "entropies_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(entropies, indices_sorted)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "index_threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(indices_threshold)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_65": {
                "variable": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_69": {
                "variable": {
                    "value": "corrects",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.argmax(labels, axis=1), tf.argmax(probabilities, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "probabilities.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_77": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "entropies <= threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(entropies)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(entropies)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_83": {
                "variable": {
                    "value": "accuracy_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(weights * masks * corrects)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(weights * masks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_92": {
                "variable": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_98": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "entropies <= threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(entropies)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(entropies)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_104": {
                "variable": {
                    "value": "cost_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(weights * masks * costs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(weights * masks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_113": {
                "variable": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_118": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "entropies <= threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(entropies)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(entropies)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_124": {
                "variable": {
                    "value": "fraction_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights * masks",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_10": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_11": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_17": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "equal_19": {
                "x": {
                    "value": "tf.argmax(labels, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(probabilities, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_31": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_33": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_35": {
                "x": {
                    "value": "tf.argmax(labels, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(probabilities, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cumsum_51": {
                "x": {
                    "value": "tf.ones_like(accuracies_sorted, dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_55": {
                "input": {
                    "value": "range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.cumsum(tf.ones_like(accuracies_sorted, dtype=tf.int64), axis=0) - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_66": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_68": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_70": {
                "x": {
                    "value": "tf.argmax(labels, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(probabilities, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_79": {
                "input": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_80": {
                "input": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_84": {
                "input_tensor": {
                    "value": "weights * masks * corrects",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_85": {
                "input_tensor": {
                    "value": "weights * masks",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_93": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_95": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_96": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_like_100": {
                "input": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_101": {
                "input": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_105": {
                "input_tensor": {
                    "value": "weights * masks * costs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_106": {
                "input_tensor": {
                    "value": "weights * masks",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_114": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights / tf.reduce_sum(weights)",
                            "BinOp"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ],
                        [
                            "weights",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_116": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_like_120": {
                "input": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_like_121": {
                "input": {
                    "value": "entropies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "-tf.reduce_sum(probabilities * logits, axis=1) + tf.reduce_logsumexp(logits, axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_11": {
                "input_tensor": {
                    "value": "labels * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_20": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_21": {
                "input": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_33": {
                "input_tensor": {
                    "value": "probabilities * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_36": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_37": {
                "input": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_like_51": {
                "input": {
                    "value": "accuracies_sorted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerators_sorted / denominators_sorted",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_53": {
                "value": {
                    "value": "target_accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "target_accuracy",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "accuracies_sorted.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_68": {
                "input_tensor": {
                    "value": "probabilities * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_71": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ],
                        [
                            "labels",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_72": {
                "input": {
                    "value": "probabilities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ],
                        [
                            "tf.math.softmax(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_95": {
                "input_tensor": {
                    "value": "probabilities * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_96": {
                "input_tensor": {
                    "value": "labels * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_116": {
                "input_tensor": {
                    "value": "probabilities * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/simplified-codebase/model.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/simplified-codebase/test.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/simplified-codebase/train_val.py": {
        "tensorflow": {}
    },
    "antigen-classification-problem/model/test.py": {
        "tensorflow": {
            "softmax_89": {
                "variable": {
                    "value": "probabilities_test",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_test",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_tra_cdr3_test, features_tra_vgene_test, features_tra_jgene_test, features_trb_cdr3_test, features_trb_vgene_test, features_trb_jgene_test, weights_test])",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_95": {
                "variable": {
                    "value": "threshold_test",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits_test.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_102": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "antigen-classification-problem/model/train_val.py": {
        "tensorflow": {
            "softmax_91": {
                "variable": {
                    "value": "probabilities_train",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_tra_cdr3_train, features_tra_vgene_train, features_tra_jgene_train, features_trb_cdr3_train, features_trb_vgene_train, features_trb_jgene_train, weights_train])",
                            "Call"
                        ]
                    ]
                }
            },
            "Variable_104": {
                "variable": {
                    "value": "index_step",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "AdamOptimizer_105": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "softmax_116": {
                "variable": {
                    "value": "probabilities_val",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_val",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_tra_cdr3_val, features_tra_vgene_val, features_tra_jgene_val, features_trb_cdr3_val, features_trb_vgene_val, features_trb_jgene_val, weights_val])",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_122": {
                "variable": {
                    "value": "threshold_val",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "accuracy_val.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_129": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_141": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/Abundance.py": {
        "tensorflow": {
            "expand_dims_16": {
                "variable": {
                    "value": "inputs_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_17": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs_expand",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.expand_dims(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "repertoire-classification-problem/model/Aggregate.py": {
        "tensorflow": {
            "reduce_max_12": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "top_k_20": {
                "variable": {
                    "value": "(matches_trans, indices_trans)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.transpose(inputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "k": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_35": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack([matches_trans_0[:, 0] + matches_trans_0[:, 0] + penalties_trans, matches_trans_0[:, 0] + matches_trans_0[:, 1], matches_trans_0[:, 1] + matches_trans_0[:, 0]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_21": {
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_30": {
                "x": {
                    "value": "tf.equal(indices_trans_0[:, 0], indices_trans_1[:, 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_36": {
                "values": {
                    "value": "[matches_trans_0[:, 0] + matches_trans_0[:, 0] + penalties_trans, matches_trans_0[:, 0] + matches_trans_0[:, 1], matches_trans_0[:, 1] + matches_trans_0[:, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_31": {
                "x": {
                    "value": "indices_trans_0[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "indices_trans_1[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/Alignment.py": {
        "tensorflow": {
            "any_54": {
                "a": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_61": {
                "variable": {
                    "value": "lengths_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "K.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_62": {
                "variable": {
                    "value": "lengths_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.weight_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_63": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "lengths_feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.sum(K.cast(mask, dtype=inputs.dtype), axis=1, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "lengths_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.cast(self.weight_steps, inputs.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_61": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_64": {
                "x": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "K.minimum(lengths_feature, lengths_weight)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "repertoire-classification-problem/model/BatchExpand.py": {
        "tensorflow": {
            "ones_like_15": {
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/FullFlatten.py": {
        "tensorflow": {
            "reshape_14": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/Length.py": {
        "tensorflow": {
            "sum_18": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "K.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "any_16": {
                "a": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_18": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/NormalizeInitialization.py": {
        "tensorflow": {
            "reshape_42": {
                "variable": {
                    "value": "level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(self.level, level_.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_44": {
                "variable": {
                    "value": "weights_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_46": {
                "variable": {
                    "value": "numerator_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights_expand * inputs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_47": {
                "variable": {
                    "value": "numerator_sq_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights_expand * inputs ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_48": {
                "variable": {
                    "value": "denominator_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights_expand",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(weights, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_50": {
                "variable": {
                    "value": "indicator",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(level, level_)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "numerator_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_58": {
                "variable": {
                    "value": "mean_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / denominator",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_59": {
                "variable": {
                    "value": "variance_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator_sq / denominator - mean ** 2",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_42": {
                "x": {
                    "value": "self.level",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "level_.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_50": {
                "x": {
                    "value": "level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.cast(self.level, level_.dtype), [1])",
                            "Call"
                        ],
                        [
                            "level",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "level_",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_61": {
                "x": {
                    "value": "variance_expand + self.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/alignment_score.py": {
        "tensorflow": {
            "where_31": {
                "variable": {
                    "value": "scores[i][0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "masks[:, i - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "scores[i - 1][0] + penalties_feature",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "scores[i - 1][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tensordot_43": {
                "variable": {
                    "value": "similarities",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "features[:, i - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "weights[j - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_44": {
                "variable": {
                    "value": "scores_update",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack([scores[i - 1][j - 1] + similarities, scores[i][j - 1] + penalties_weight, scores[i - 1][j] + penalties_feature], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_55": {
                "variable": {
                    "value": "scores[i][j]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "condition": {
                    "value": "masks[:, i - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "scores_update",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(tf.stack([scores[i - 1][j - 1] + similarities, scores[i][j - 1] + penalties_weight, scores[i - 1][j] + penalties_feature], axis=1), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "scores[i - 1][j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_15": {
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_25": {
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.shape(features)[0]] + list(weights.get_shape()[2:])",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "stack_45": {
                "values": {
                    "value": "[scores[i - 1][j - 1] + similarities, scores[i][j - 1] + penalties_weight, scores[i - 1][j] + penalties_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/dkm-1sequence-32steps/BatchExpand.py": {
        "tensorflow": {
            "ones_like_15": {
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/dkm-1sequence-32steps/GlobalPool.py": {
        "tensorflow": {
            "expand_dims_16": {
                "variable": {
                    "value": "indicators",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_18": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs + penalties",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_any_14": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_16": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/dkm-1sequence-32steps/MaskCopy.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/comparisons/dkm-1sequence-32steps/model.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/comparisons/dkm-1sequence-32steps/train_val.py": {
        "tensorflow": {
            "placeholder_80": {
                "variable": {
                    "value": "features_cdr3_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(xs_train[first]['cdr3'].shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_81": {
                "variable": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_83": {
                "variable": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_84": {
                "variable": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "level_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_90": {
                "variable": {
                    "value": "features_age_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_91": {
                "variable": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(label_block, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_fits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "weight_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_110": {
                "variable": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_114": {
                "variable": {
                    "value": "error_block",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_117": {
                "variable": {
                    "value": "corrects_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.round(labels_block), tf.round(probabilities_block))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "costs",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "costs_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "costs_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracies",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "accuracies_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "accuracies_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmin_145": {
                "variable": {
                    "value": "index_bestfit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_149": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "group_157": {
                "variable": {
                    "value": "accumulate_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grads[index].assign_add(grad) for (index, (grad, param)) in enumerate(grads_params_sample)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_160": {
                "variable": {
                    "value": "reset_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grad.assign(tf.zeros_like(grad)) for grad in grads]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "global_variables_initializer_170": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_89": {
                "input_tensor": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_92": {
                "tensor": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_118": {
                "x": {
                    "value": "tf.round(labels_block)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.round(probabilities_block)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_142": {
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_143": {
                "input": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('accuracies', shape=accuracies_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=accuracies_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_150": {
                "input_tensor": {
                    "value": "costs_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_block_ * error_block",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Variable_153": {
                "initial_value": {
                    "value": "tf.zeros_like(param.initialized_value())",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "param.initialized_value().dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_183": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "round_119": {
                "x": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "round_120": {
                "x": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.sigmoid(logits_block)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_130": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_135": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "trainable_variables_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_153": {
                "input": {
                    "value": "param.initialized_value()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_161": {
                "input": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/dkm-2sequences-8steps/model.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/comparisons/dkm-2sequences-8steps/train_val.py": {
        "tensorflow": {
            "placeholder_80": {
                "variable": {
                    "value": "features_cdr3_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(xs_train[first]['cdr3'].shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_81": {
                "variable": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_83": {
                "variable": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_84": {
                "variable": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "level_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_90": {
                "variable": {
                    "value": "features_age_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_91": {
                "variable": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(label_block, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_fits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "weight_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_110": {
                "variable": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_114": {
                "variable": {
                    "value": "error_block",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_117": {
                "variable": {
                    "value": "corrects_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.round(labels_block), tf.round(probabilities_block))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "costs",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "costs_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "costs_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracies",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "accuracies_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "accuracies_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmin_145": {
                "variable": {
                    "value": "index_bestfit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_149": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "group_157": {
                "variable": {
                    "value": "accumulate_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grads[index].assign_add(grad) for (index, (grad, param)) in enumerate(grads_params_sample)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_160": {
                "variable": {
                    "value": "reset_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grad.assign(tf.zeros_like(grad)) for grad in grads]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "global_variables_initializer_170": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_89": {
                "input_tensor": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_92": {
                "tensor": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_118": {
                "x": {
                    "value": "tf.round(labels_block)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.round(probabilities_block)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_142": {
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_143": {
                "input": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('accuracies', shape=accuracies_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=accuracies_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_150": {
                "input_tensor": {
                    "value": "costs_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_block_ * error_block",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Variable_153": {
                "initial_value": {
                    "value": "tf.zeros_like(param.initialized_value())",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "param.initialized_value().dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_183": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "round_119": {
                "x": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "round_120": {
                "x": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.sigmoid(logits_block)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_130": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_135": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "trainable_variables_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_153": {
                "input": {
                    "value": "param.initialized_value()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_161": {
                "input": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/max-snippet-model/BatchExpand.py": {
        "tensorflow": {
            "ones_like_15": {
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/max-snippet-model/GlobalPool.py": {
        "tensorflow": {
            "expand_dims_16": {
                "variable": {
                    "value": "indicators",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(mask, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_18": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs + penalties",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_any_14": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_16": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/comparisons/max-snippet-model/MaskCopy.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/comparisons/max-snippet-model/model.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/comparisons/max-snippet-model/train_val.py": {
        "tensorflow": {
            "placeholder_80": {
                "variable": {
                    "value": "features_cdr3_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(xs_train[first]['cdr3'].shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_81": {
                "variable": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_83": {
                "variable": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_84": {
                "variable": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "level_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_90": {
                "variable": {
                    "value": "features_age_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_91": {
                "variable": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(label_block, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_fits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "weight_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_110": {
                "variable": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_114": {
                "variable": {
                    "value": "error_block",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_117": {
                "variable": {
                    "value": "corrects_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.round(labels_block), tf.round(probabilities_block))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "costs",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "costs_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "costs_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracies",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "accuracies_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "accuracies_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmin_145": {
                "variable": {
                    "value": "index_bestfit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_149": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "group_157": {
                "variable": {
                    "value": "accumulate_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grads[index].assign_add(grad) for (index, (grad, param)) in enumerate(grads_params_sample)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_160": {
                "variable": {
                    "value": "reset_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grad.assign(tf.zeros_like(grad)) for grad in grads]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "global_variables_initializer_170": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_89": {
                "input_tensor": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_92": {
                "tensor": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_118": {
                "x": {
                    "value": "tf.round(labels_block)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.round(probabilities_block)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_142": {
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_143": {
                "input": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('accuracies', shape=accuracies_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=accuracies_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_150": {
                "input_tensor": {
                    "value": "costs_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_block_ * error_block",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Variable_153": {
                "initial_value": {
                    "value": "tf.zeros_like(param.initialized_value())",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "param.initialized_value().dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_183": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "round_119": {
                "x": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "round_120": {
                "x": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.sigmoid(logits_block)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_130": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_135": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "trainable_variables_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_153": {
                "input": {
                    "value": "param.initialized_value()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_161": {
                "input": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/dataset.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/dump_model.py": {
        "tensorflow": {
            "placeholder_69": {
                "variable": {
                    "value": "features_cdr3_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(xs[first]['cdr3'].shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_70": {
                "variable": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_71": {
                "variable": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_72": {
                "variable": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_73": {
                "variable": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_74": {
                "variable": {
                    "value": "level_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_79": {
                "variable": {
                    "value": "features_age_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_80": {
                "variable": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(label_block, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_fits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_84": {
                "variable": {
                    "value": "weight_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_101": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_78": {
                "input_tensor": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_81": {
                "tensor": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_113": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/model.py": {
        "tensorflow": {}
    },
    "repertoire-classification-problem/model/test.py": {
        "tensorflow": {
            "placeholder_75": {
                "variable": {
                    "value": "features_cdr3_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(xs_test[first]['cdr3'].shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_76": {
                "variable": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_77": {
                "variable": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_78": {
                "variable": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_79": {
                "variable": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_80": {
                "variable": {
                    "value": "level_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_85": {
                "variable": {
                    "value": "features_age_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_86": {
                "variable": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(label_block, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_fits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_90": {
                "variable": {
                    "value": "weight_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_105": {
                "variable": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_109": {
                "variable": {
                    "value": "error_block",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_112": {
                "variable": {
                    "value": "corrects_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.round(labels_block), tf.round(probabilities_block))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_123": {
                "variable": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "costs",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "costs_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "costs_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracies",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "accuracies_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "accuracies_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmin_140": {
                "variable": {
                    "value": "index_bestfit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_144": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "group_152": {
                "variable": {
                    "value": "accumulate_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grads[index].assign_add(grad) for (index, (grad, param)) in enumerate(grads_params_sample)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_155": {
                "variable": {
                    "value": "reset_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grad.assign(tf.zeros_like(grad)) for grad in grads]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "global_variables_initializer_165": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_84": {
                "input_tensor": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_87": {
                "tensor": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_113": {
                "x": {
                    "value": "tf.round(labels_block)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.round(probabilities_block)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_137": {
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_138": {
                "input": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('accuracies', shape=accuracies_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=accuracies_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_145": {
                "input_tensor": {
                    "value": "costs_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_block_ * error_block",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Variable_148": {
                "initial_value": {
                    "value": "tf.zeros_like(param.initialized_value())",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "param.initialized_value().dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_177": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "round_114": {
                "x": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "round_115": {
                "x": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.sigmoid(logits_block)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_125": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_130": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "trainable_variables_145": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_148": {
                "input": {
                    "value": "param.initialized_value()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_156": {
                "input": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "repertoire-classification-problem/model/train_val.py": {
        "tensorflow": {
            "placeholder_80": {
                "variable": {
                    "value": "features_cdr3_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + list(xs_train[first]['cdr3'].shape[1:])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_81": {
                "variable": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_83": {
                "variable": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_84": {
                "variable": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "level_block",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_90": {
                "variable": {
                    "value": "features_age_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features_age_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_91": {
                "variable": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(label_block, [1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_fits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "weight_block_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weight_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_110": {
                "variable": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_114": {
                "variable": {
                    "value": "error_block",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model([features_cdr3_block, features_quantity_block_, features_age_block_, weight_block_, level_block])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_117": {
                "variable": {
                    "value": "corrects_block",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.round(labels_block), tf.round(probabilities_block))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "costs",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "costs_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "costs_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "accuracies",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "accuracies_block.get_shape()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "accuracies_block.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmin_145": {
                "variable": {
                    "value": "index_bestfit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_149": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.001",
                            "float"
                        ]
                    ]
                }
            },
            "group_157": {
                "variable": {
                    "value": "accumulate_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grads[index].assign_add(grad) for (index, (grad, param)) in enumerate(grads_params_sample)]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_160": {
                "variable": {
                    "value": "reset_gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[grad.assign(tf.zeros_like(grad)) for grad in grads]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "global_variables_initializer_170": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_89": {
                "input_tensor": {
                    "value": "features_quantity_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_92": {
                "tensor": {
                    "value": "label_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_118": {
                "x": {
                    "value": "tf.round(labels_block)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.round(probabilities_block)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_142": {
                "input": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('costs', shape=costs_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=costs_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_143": {
                "input": {
                    "value": "accuracies",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('accuracies', shape=accuracies_block.get_shape(), initializer=tf.constant_initializer(0.0), dtype=accuracies_block.dtype, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_150": {
                "input_tensor": {
                    "value": "costs_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "weight_block_ * error_block",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Variable_153": {
                "initial_value": {
                    "value": "tf.zeros_like(param.initialized_value())",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "param.initialized_value().dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_183": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "round_119": {
                "x": {
                    "value": "labels_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(label_block, [1]), [num_fits])",
                            "Call"
                        ]
                    ]
                }
            },
            "round_120": {
                "x": {
                    "value": "probabilities_block",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.sigmoid(logits_block)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_130": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_135": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "trainable_variables_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_153": {
                "input": {
                    "value": "param.initialized_value()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_161": {
                "input": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    }
}