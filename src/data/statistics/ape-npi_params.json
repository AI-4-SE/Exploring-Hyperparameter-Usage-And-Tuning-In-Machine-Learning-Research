{
    "scripts/post_editing/noisify.py": {
        "sklearn": {}
    },
    "translate/__main__.py": {
        "tensorflow": {
            "ConfigProto_254": {
                "variable": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": []
                },
                "log_device_placement": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_random_seed_204": {
                "seed": {
                    "value": "config.tf_seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_222": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "'/cpu:0'",
                            "str"
                        ],
                        [
                            "'/gpu:{}'.format(config.gpu_id)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_231": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_259": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_263": {
                "config": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(log_device_placement=False, allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_uniform_initializer_225": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-config.weight_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "config.weight_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_normal_initializer_227": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "config.weight_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_243": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_273": {
                "config": {
                    "value": "tf_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(log_device_placement=False, allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "translate/beam_search.py": {
        "tensorflow": {
            "cumsum_10": {
                "variable": {
                    "value": "cumsum",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.to_float(tf.not_equal(sequence, eos_id))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_12": {
                "variable": {
                    "value": "range_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(range_, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(sequence)[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_13": {
                "x": {
                    "value": "range_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(start=1, limit=tf.shape(sequence)[1] + 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(range_, axis=0), [tf.shape(sequence)[0], 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_27": {
                "variable": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(src, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, beam_size] + [1] * len(shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_28": {
                "variable": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(src, axis=1), [1, beam_size] + [1] * len(shape))",
                            "Call"
                        ],
                        [
                            "tf.reshape(src, tf.stack([batch_size * beam_size] + shape))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([batch_size * beam_size] + shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unstack_35": {
                "variable": {
                    "value": "dynamic_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.shape(tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_54": {
                "variable": {
                    "value": "flat_first",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[shape[0] * shape[1]] + shape[2:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_55": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(indices)",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.tile(tf.expand_dims(tf.range(batch_size), axis=1), [1, beam_size]), indices], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_57": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.range(shape[0]) * shape[1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "offset_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[shape[0]] + [1] * (indices.shape.ndims - 1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_58": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flat_first",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tensor, [shape[0] * shape[1]] + shape[2:])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices + offset",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_max_64": {
                "variable": {
                    "value": "my_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x / T",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_86": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(states, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.split(states, num_or_size_splits=state_sizes, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_gather(state, beam_ids) for state in new_states], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_88": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones(shape=[batch_size, 1]), tf.zeros(shape=[batch_size, beam_size - 1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_91": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(shape=[batch_size, 1]), tf.zeros(shape=[batch_size, beam_size - 1])], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.log(scores)",
                            "Call"
                        ],
                        [
                            "scores / length ** len_normalization",
                            "BinOp"
                        ]
                    ]
                }
            },
            "tile_93": {
                "variable": {
                    "value": "ids",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[[utils.BOS_ID]]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_94": {
                "variable": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile([[utils.BOS_ID]], [batch_size, beam_size])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_96": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, beam_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_97": {
                "variable": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "time",
                    "type": "str",
                    "possible_values": []
                }
            },
            "while_loop_148": {
                "variable": {
                    "value": "(_, mask, hypotheses, states, ids, scores)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "cond",
                    "type": "variable",
                    "possible_values": []
                },
                "body": {
                    "value": "time_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "loop_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[time, mask, hypotheses, states, ids, scores]",
                            "List"
                        ]
                    ]
                },
                "shape_invariants": {
                    "value": "shapes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.TensorShape([None] * len(var.shape)) for var in loop_vars]",
                            "ListComp"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "16",
                            "Method Argument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_18": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones(tf.stack(shape)), weights]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_20": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(cumsum, tf.to_float(range_)))",
                            "Call"
                        ],
                        [
                            "weights[:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([tf.ones(tf.stack(shape)), weights], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_84": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(initial_state, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, beam_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_100": {
                "variable": {
                    "value": "token_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "token_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(token_ids, [batch_size * beam_size])",
                            "Call"
                        ],
                        [
                            "indices % num_classes",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_101": {
                "variable": {
                    "value": "token_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, beam_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_104": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(states, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.split(states, num_or_size_splits=state_sizes, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_gather(state, beam_ids) for state in new_states], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "state_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.shape(state)[1] for state in initial_states]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_121": {
                "variable": {
                    "value": "mask1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([batch_size, beam_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "get_weights(sel_ids_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "batch_gather(mask, beam_ids) * tf.to_float(tf.not_equal(token_ids, utils.EOS_ID))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_122": {
                "variable": {
                    "value": "mask2",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[utils.EOS_ID]]",
                    "type": "List",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(token_scores)[2]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(logits)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "top_k_127": {
                "variable": {
                    "value": "(scores, indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(sum_logprobs, [batch_size, num_classes * beam_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "k": {
                    "value": "beam_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(dst)[0] // batch_size",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_134": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_gather(state, beam_ids) for state in new_states]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_135": {
                "variable": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_gather(hypotheses, beam_ids), tf.expand_dims(token_ids, axis=2)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_161": {
                "variable": {
                    "value": "sel_ids_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(ids, axis=2)",
                            "Call"
                        ],
                        [
                            "hypotheses[:, :, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(hypotheses, indices)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_gather(hypotheses, beam_ids), tf.expand_dims(token_ids, axis=2)], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * n, sequence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_163": {
                "variable": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([batch_size, beam_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "get_weights(sel_ids_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "batch_gather(mask, beam_ids) * tf.to_float(tf.not_equal(token_ids, utils.EOS_ID))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_164": {
                "variable": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(mask, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(length, shape=[batch_size, n])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, n]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "top_k_166": {
                "variable": {
                    "value": "(scores, indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(shape=[batch_size, 1]), tf.zeros(shape=[batch_size, beam_size - 1])], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.log(scores)",
                            "Call"
                        ],
                        [
                            "scores / length ** len_normalization",
                            "BinOp"
                        ]
                    ]
                },
                "k": {
                    "value": "beam_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(dst)[0] // batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_167": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.tile(tf.expand_dims(tf.range(batch_size), axis=1), [1, beam_size]), indices]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_168": {
                "variable": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(ids, axis=2)",
                            "Call"
                        ],
                        [
                            "hypotheses[:, :, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(hypotheses, indices)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_gather(hypotheses, beam_ids), tf.expand_dims(token_ids, axis=2)], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(indices)",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.tile(tf.expand_dims(tf.range(batch_size), axis=1), [1, beam_size]), indices], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_10": {
                "x": {
                    "value": "tf.not_equal(sequence, eos_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_12": {
                "input": {
                    "value": "range_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(start=1, limit=tf.shape(sequence)[1] + 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(range_, axis=0), [tf.shape(sequence)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_13": {
                "x": {
                    "value": "cumsum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cumsum(tf.to_float(tf.not_equal(sequence, eos_id)), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(range_)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_24": {
                "input": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(src, axis=1), [1, beam_size] + [1] * len(shape))",
                            "Call"
                        ],
                        [
                            "tf.reshape(src, tf.stack([batch_size * beam_size] + shape))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_27": {
                "input": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(src, axis=1), [1, beam_size] + [1] * len(shape))",
                            "Call"
                        ],
                        [
                            "tf.reshape(src, tf.stack([batch_size * beam_size] + shape))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_28": {
                "values": {
                    "value": "[batch_size * beam_size] + shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_35": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_79": {
                "input": {
                    "value": "initial_states[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_107": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=1), [1, beam_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(state, [batch_size * beam_size, state_size])",
                            "Call"
                        ],
                        [
                            "tf.reshape(state, [batch_size, beam_size, state_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * beam_size, state_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_113": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=1), [1, beam_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(state, [batch_size * beam_size, state_size])",
                            "Call"
                        ],
                        [
                            "tf.reshape(state, [batch_size, beam_size, state_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, beam_size, state_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_117": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(logits, [batch_size, beam_size, num_classes])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, beam_size, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_141": {
                "dims": {
                    "value": "[None] * len(var.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_146": {
                "x": {
                    "value": "p1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "time < sequence_length",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "p2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.reduce_sum(1 - mask)) < batch_size * beam_size",
                            "Compare"
                        ]
                    ]
                }
            },
            "not_equal_10": {
                "x": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "eos_id",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_25": {
                "input": {
                    "value": "dst",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "log_65": {
                "x": {
                    "value": "tf.reduce_sum(tf.exp(x / T - my_max), axis, keep_dims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_81": {
                "input": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=1), [1, beam_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(state, [batch_size * beam_size, state_size])",
                            "Call"
                        ],
                        [
                            "tf.reshape(state, [batch_size, beam_size, state_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_84": {
                "input": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initial_states",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_89": {
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_90": {
                "shape": {
                    "value": "[batch_size, beam_size - 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_120": {
                "input": {
                    "value": "token_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, beam_size, 1])",
                            "Call"
                        ],
                        [
                            "token_scores * mask1 + (1 - mask1) * (1 - mask2) * -1e+30",
                            "BinOp"
                        ],
                        [
                            "token_scores + log_softmax(logits, axis=2, temperature=temperature)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_125": {
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.ones(shape=[batch_size, 1]), tf.zeros(shape=[batch_size, beam_size - 1])], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.log(scores)",
                            "Call"
                        ],
                        [
                            "scores / length ** len_normalization",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_128": {
                "tensor": {
                    "value": "sum_logprobs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(scores, axis=2) + token_scores",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, num_classes * beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_137": {
                "x": {
                    "value": "tf.not_equal(token_ids, utils.EOS_ID)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_int32_145": {
                "x": {
                    "value": "tf.reduce_sum(1 - mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_159": {
                "input": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(ids, axis=2)",
                            "Call"
                        ],
                        [
                            "hypotheses[:, :, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(hypotheses, indices)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_gather(hypotheses, beam_ids), tf.expand_dims(token_ids, axis=2)], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_160": {
                "input": {
                    "value": "hypotheses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(ids, axis=2)",
                            "Call"
                        ],
                        [
                            "hypotheses[:, :, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(hypotheses, indices)",
                            "Call"
                        ],
                        [
                            "tf.concat([batch_gather(hypotheses, beam_ids), tf.expand_dims(token_ids, axis=2)], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_12": {
                "input": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_17": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(cumsum, tf.to_float(range_)))",
                            "Call"
                        ],
                        [
                            "weights[:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([tf.ones(tf.stack(shape)), weights], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_18": {
                "shape": {
                    "value": "tf.stack(shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_65": {
                "input_tensor": {
                    "value": "tf.exp(x / T - my_max)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_scope_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_110": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable_scope() if len(update_funs) == 1 else 'model_{}'.format(k + 1)",
                            "IfExp"
                        ]
                    ]
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_116": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(logits, [batch_size, beam_size, num_classes])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_135": {
                "input": {
                    "value": "token_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(token_ids, [batch_size * beam_size])",
                            "Call"
                        ],
                        [
                            "indices % num_classes",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "not_equal_137": {
                "x": {
                    "value": "token_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(token_ids, [batch_size * beam_size])",
                            "Call"
                        ],
                        [
                            "indices % num_classes",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.EOS_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_145": {
                "input_tensor": {
                    "value": "1 - mask",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_167": {
                "input": {
                    "value": "tf.expand_dims(tf.range(batch_size), axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_11": {
                "input": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_18": {
                "values": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.shape(weights)[0], 1]",
                            "List"
                        ],
                        [
                            "get_shape(src)[1:]",
                            "Subscript"
                        ],
                        [
                            "get_shape(tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_65": {
                "x": {
                    "value": "x / T - my_max",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_167": {
                "input": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "range_167": {}
        }
    },
    "translate/conv_lstm.py": {
        "tensorflow": {
            "get_variable_113": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[filter_size[0], filter_size[1], total_arg_size_depth, num_features]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "get_variable_121": {
                "variable": {
                    "value": "bias_term",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_features]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(bias_start, dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_50": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [batch_size, self.height, self.width, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.height, self.width, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_51": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(c, [batch_size, self.height, self.width, self.num_features])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.height, self.width, self.num_features]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_52": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(h, [batch_size, self.height, self.width, self.num_features])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.height, self.width, self.num_features]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_57": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_conv_linear([inputs, h], self.filter_size, self.num_features * 4, True)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_63": {
                "variable": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._activation(new_c) * tf.nn.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(new_h, [batch_size, self._num_units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_64": {
                "variable": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "c * tf.nn.sigmoid(f + self._forget_bias) + tf.nn.sigmoid(i) * self._activation(j)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(new_c, [batch_size, self._num_units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_82": {
                "shape": {
                    "value": "[batch_size, self._num_units * 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_112": {
                "name_or_scope": {
                    "value": "scope or 'Conv'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "conv2d_116": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "args[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "filters": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Matrix', [filter_size[0], filter_size[1], total_arg_size_depth, num_features], dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_118": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat(axis=3, values=args)",
                    "type": "Call",
                    "possible_values": []
                },
                "filters": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('Matrix', [filter_size[0], filter_size[1], total_arg_size_depth, num_features], dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_33": {
                "c": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_42": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "split_47": {
                "variable": {
                    "value": "(c, h)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_67": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "c * tf.nn.sigmoid(f + self._forget_bias) + tf.nn.sigmoid(i) * self._activation(j)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(new_c, [batch_size, self._num_units])",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._activation(new_c) * tf.nn.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(new_h, [batch_size, self._num_units])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_69": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_c, new_h]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_49": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [batch_size, self.height, self.width, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_61": {
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "concat_118": {
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "values": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_initializer_124": {
                "value": {
                    "value": "bias_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sigmoid_59": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "translate/import_graph.py": {
        "tensorflow": {
            "Graph_13": {
                "variable": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_14": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_17": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Saver_42": {
                "var_list": {
                    "value": "variables",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "import_meta_graph_23": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "ckpt_name + '.meta'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "trainable_variables_29": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "translate/models.py": {
        "tensorflow": {
            "concat_367": {
                "variable": {
                    "value": "encoder_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "encoder_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_387": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, size, activation=tf.nn.relu, use_bias=True, name='y')",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=not encoder.layer_norm, name='W_a')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(y, scope='layer_norm_state')",
                            "Call"
                        ],
                        [
                            "y + dense(conv, encoder.attn_size, use_bias=False, name='C_a')",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_445": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([batch_size, 0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_446": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, tf.shape(hidden_states)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_452": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(encoder_input_length, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sequence_mask_453": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "encoder_input_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.expand_dims(encoder_input_length, axis=1))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.to_int32(tf.reduce_sum(weights, axis=1))]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(hidden_states)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_455": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hidden_states * tf.expand_dims(weights, axis=2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_460": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "encoder_input_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "tf.shape(hidden_states)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_461": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_463": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hidden_states * tf.expand_dims(weights, axis=2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_565": {
                "variable": {
                    "value": "context_vector",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "context_vectors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_654": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_842": {
                "variable": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "time",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorArray_843": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_844": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_845": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "unstack_845": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.to_int64(tf.transpose(decoder_inputs))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorArray_847": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_848": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_849": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "zeros_853": {
                "variable": {
                    "value": "initial_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_854": {
                "variable": {
                    "value": "initial_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(attention_states[align_encoder_id])[:2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_855": {
                "variable": {
                    "value": "zero_context",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(attention_states[align_encoder_id][:, 0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_860": {
                "variable": {
                    "value": "initial_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[initial_state, initial_context, tf.expand_dims(initial_pos, axis=1), initial_weights]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_969": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "outputs.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(outputs, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "outputs.write(time, output_)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "outputs.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(outputs, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "outputs.write(time, output_)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_970": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_971": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_972": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_973": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.int64, size=time_steps)",
                            "Call"
                        ],
                        [
                            "samples.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(samples)",
                            "Call"
                        ],
                        [
                            "samples.write(time, predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.int64, size=time_steps)",
                            "Call"
                        ],
                        [
                            "samples.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(samples)",
                            "Call"
                        ],
                        [
                            "samples.write(time, predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1030": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_1241": {
                "variable": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "time",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorArray_1242": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_1243": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_1244": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "unstack_1244": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.to_int64(tf.transpose(decoder_inputs))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorArray_1246": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_1247": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "TensorArray_1248": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "zeros_1255": {
                "variable": {
                    "value": "initial_lm_state",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, cell_state_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_1259": {
                "variable": {
                    "value": "initial_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_1260": {
                "variable": {
                    "value": "initial_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(attention_states[align_encoder_id])[:2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_1261": {
                "variable": {
                    "value": "zero_context",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(attention_states[align_encoder_id][:, 0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_1267": {
                "variable": {
                    "value": "initial_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[initial_state, initial_context, initial_lm_state, tf.expand_dims(initial_pos, axis=1), initial_weights]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_1403": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "outputs.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(outputs, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "outputs.write(time, output_)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "outputs.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(outputs, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "outputs.write(time, output_)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_1404": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_1405": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_1406": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "(1, 0, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_1407": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.int64, size=time_steps)",
                            "Call"
                        ],
                        [
                            "samples.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(samples)",
                            "Call"
                        ],
                        [
                            "samples.write(time, predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.int64, size=time_steps)",
                            "Call"
                        ],
                        [
                            "samples.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(samples)",
                            "Call"
                        ],
                        [
                            "samples.write(time, predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_1527": {
                "variable": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "encoder_input_length[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "max_src_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(reconstructed_weights)[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_1528": {
                "variable": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,ik->ijk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.sequence_mask(source_length, maxlen=src_len))",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length[0], maxlen=max_src_len, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,ik->ijk', src_mask, src_mask)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.sequence_mask(source_length, maxlen=src_len))",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length[0], maxlen=max_src_len, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,ik->ijk', src_mask, src_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1565": {
                "variable": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pad, decoder_inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1671": {
                "variable": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pad, decoder_inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_1753": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_1764": {
                "variable": {
                    "value": "logits_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([time_steps * batch_size, logits.get_shape()[2].value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_1765": {
                "variable": {
                    "value": "targets_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets[0]",
                            "Subscript"
                        ],
                        [
                            "targets[0]",
                            "Subscript"
                        ],
                        [
                            "targets[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([time_steps * batch_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_1767": {
                "variable": {
                    "value": "crossent",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(logits, tf.stack([time_steps * batch_size, logits.get_shape()[2].value]))",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "targets_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(targets, tf.stack([time_steps * batch_size]))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_1768": {
                "variable": {
                    "value": "crossent",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "crossent",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits_, labels=targets_)",
                            "Call"
                        ],
                        [
                            "tf.reshape(crossent, tf.stack([batch_size, time_steps]))",
                            "Call"
                        ],
                        [
                            "crossent * tf.stop_gradient(rewards)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([batch_size, time_steps])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_1773": {
                "variable": {
                    "value": "log_perp",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "crossent * weights",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1780": {
                "variable": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_perp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(crossent * weights, axis=1)",
                            "Call"
                        ],
                        [
                            "log_perp / total_size",
                            "BinOp"
                        ]
                    ]
                }
            },
            "squeeze_1803": {
                "variable": {
                    "value": "baseline",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "baseline",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense(tf.stop_gradient(decoder_states), units=1, activation=None, name='reward_baseline', kernel_initializer=tf.constant_initializer(0.01))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(baseline, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1817": {
                "variable": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cost * weights",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1824": {
                "variable": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(log_perp)",
                            "Call"
                        ],
                        [
                            "rewards ** 2",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(cost * weights, axis=1)",
                            "Call"
                        ],
                        [
                            "cost / tf.to_float(batch_size)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(cost)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_55": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self.num_splits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_377": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "encoder.attn_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "state_noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, tf.shape(state)[1]] if encoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dropout_379": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(hidden, keep_prob=encoder.attn_keep_prob, noise_shape=hidden_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(hidden, encoder.attn_size, use_bias=False, name='hidden')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(hidden, center=False, scope='layer_norm_hidden')",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(hidden, state)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "encoder.attn_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "hidden_noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, tf.shape(hidden)[2]] if encoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "tile_396": {
                "variable": {
                    "value": "src_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(time_steps), axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_397": {
                "variable": {
                    "value": "trg_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(time, [1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, time_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_398": {
                "variable": {
                    "value": "src_len",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(input_length, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, time_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_399": {
                "variable": {
                    "value": "pos_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.stack([src_pos, trg_pos, src_len], axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_400": {
                "variable": {
                    "value": "pos_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 + pos_feats",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_407": {
                "variable": {
                    "value": "prev_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "prev_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(prev_weights, tf.stack([batch_size, time_steps, 1, 1]))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([batch_size, time_steps, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_408": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "prev_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(prev_weights, tf.stack([batch_size, time_steps, 1, 1]))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('filter_{}'.format(k), [filter_height, filter_width, in_channels, out_channels])",
                            "Call"
                        ],
                        [
                            "get_variable('filter_{}'.format(w), [w, encoder.embedding_size, filter_size])",
                            "Call"
                        ],
                        [
                            "get_variable('filter', filter_shape)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_409": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(prev_weights, filter_, [1, 1, 1, 1], 'SAME')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(conv, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_414": {
                "input_tensor": {
                    "value": "v * tf.tanh(y)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sequence_mask_423": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "encoder_input_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.expand_dims(encoder_input_length, axis=1))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.to_int32(tf.reduce_sum(weights, axis=1))]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(hidden_states)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_438": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(weights, 2) * hidden_states",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_472": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_477": {
                "variable": {
                    "value": "encoder_input_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(encoder_input_length, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_595": {
                "variable": {
                    "value": "context_vector",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.stack(attns, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_597": {
                "variable": {
                    "value": "context_vector",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "embedding_lookup_662": {
                "variable": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ],
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([input_, context], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.concat([input_, context, lm_state], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_760": {
                "variable": {
                    "value": "is_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.KEEP_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_761": {
                "variable": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.DEL_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_or_762": {
                "variable": {
                    "value": "is_not_ins",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "is_keep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_780": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "projection_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[state, context]",
                            "List"
                        ],
                        [
                            "[state, context]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_819": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(get_initial_state(),) * encoder.layers",
                            "BinOp"
                        ],
                        [
                            "get_initial_state()",
                            "Call"
                        ],
                        [
                            "get_variable(name, initializer=tf.zeros(cell_state_size))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.initial_state_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_929": {
                "variable": {
                    "value": "use_target",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time < time_steps - 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.random_uniform([]) >= feed_previous",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "case_930": {
                "variable": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(use_target, target), (tf.logical_not(feed_argmax), softmax)]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "argmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda : tf.argmax(output_, 1)",
                            "Lambda"
                        ],
                        [
                            "lambda : tf.argmax(logits, 1)",
                            "Lambda"
                        ],
                        [
                            "lambda : tf.argmax(output_, 1)",
                            "Lambda"
                        ]
                    ]
                }
            },
            "stop_gradient_936": {
                "variable": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case([(use_target, target), (tf.logical_not(feed_argmax), softmax)], default=argmax)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.case([(use_target, target), (tf.logical_not(feed_argmax), softmax)], default=argmax)",
                            "Call"
                        ],
                        [
                            "tf.case([(use_target, target), (tf.logical_not(feed_argmax), softmax)], default=argmax)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "while_loop_954": {
                "variable": {
                    "value": "(_, _, _, new_pos, new_state, _, outputs, states, weights, attns, new_weights, samples, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda time, *_: time < time_steps",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "_time_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "(time, initial_input, initial_symbol, initial_pos, initial_state, initial_output, outputs, weights, states, attns, initial_weights, samples, initial_context)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "decoder.parallel_iterations",
                    "type": "Attribute",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "decoder.swap_memory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "embedding_lookup_1038": {
                "variable": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ],
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([input_, context], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.concat([input_, context, lm_state], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_1138": {
                "variable": {
                    "value": "is_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.KEEP_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_1139": {
                "variable": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.DEL_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_or_1140": {
                "variable": {
                    "value": "is_not_ins",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "is_keep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1158": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "projection_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[state, context]",
                            "List"
                        ],
                        [
                            "[state, context]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_1200": {
                "variable": {
                    "value": "is_keep",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.KEEP_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_1201": {
                "variable": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.DEL_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_or_1202": {
                "variable": {
                    "value": "is_not_ins",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "is_keep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.KEEP_ID)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_1204": {
                "variable": {
                    "value": "new_input",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_not_ins",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "embed(input)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "embed(symbol)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_1218": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(get_initial_state(),) * encoder.layers",
                            "BinOp"
                        ],
                        [
                            "get_initial_state()",
                            "Call"
                        ],
                        [
                            "get_variable(name, initializer=tf.zeros(cell_state_size))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.initial_state_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_1356": {
                "variable": {
                    "value": "use_target",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time < time_steps - 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.random_uniform([]) >= feed_previous",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "case_1357": {
                "variable": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(use_target, target), (tf.logical_not(feed_argmax), softmax)]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "argmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda : tf.argmax(output_, 1)",
                            "Lambda"
                        ],
                        [
                            "lambda : tf.argmax(logits, 1)",
                            "Lambda"
                        ],
                        [
                            "lambda : tf.argmax(output_, 1)",
                            "Lambda"
                        ]
                    ]
                }
            },
            "stop_gradient_1363": {
                "variable": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case([(use_target, target), (tf.logical_not(feed_argmax), softmax)], default=argmax)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.case([(use_target, target), (tf.logical_not(feed_argmax), softmax)], default=argmax)",
                            "Call"
                        ],
                        [
                            "tf.case([(use_target, target), (tf.logical_not(feed_argmax), softmax)], default=argmax)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_1366": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[index_range, tf.cast(pos, tf.int32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_1367": {
                "variable": {
                    "value": "current_mt_symbol",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "mt_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "indices": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([index_range, tf.cast(pos, tf.int32)], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "while_loop_1388": {
                "variable": {
                    "value": "(_, _, _, new_pos, new_state, _, outputs, states, weights, attns, new_weights, samples, _, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda time, *_: time < time_steps",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "_time_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "(time, initial_input, initial_symbol, initial_pos, initial_state, initial_output, outputs, weights, states, attns, initial_weights, samples, initial_context, initial_lm_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "decoder.parallel_iterations",
                    "type": "Attribute",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "decoder.swap_memory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_1443": {
                "variable": {
                    "value": "baseline_loss_",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "tile_1459": {
                "variable": {
                    "value": "src_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.range(src_len), shape=[1, 1, src_len])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, trg_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_1460": {
                "variable": {
                    "value": "trg_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.range(trg_len), shape=[1, trg_len, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1, src_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_1463": {
                "variable": {
                    "value": "target_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(trg_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_1467": {
                "variable": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.sequence_mask(source_length, maxlen=src_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_1468": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.expand_dims(trg_mask, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.expand_dims(src_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_1470": {
                "variable": {
                    "value": "monotonous",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(true_trg_len * src_indices - true_src_len * trg_indices) ** 2 / (true_trg_len ** 2 + true_src_len ** 2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_1472": {
                "variable": {
                    "value": "monotonous",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "monotonous < monotonicity_dist",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "to_float_1529": {
                "x": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.sequence_mask(source_length, maxlen=src_len))",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length[0], maxlen=max_src_len, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,ik->ijk', src_mask, src_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_1588": {
                "variable": {
                    "value": "other_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "other_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.stop_gradient(other_inputs)",
                            "Call"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.stop_gradient(other_inputs)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_1597": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_1598": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_1599": {
                "variable": {
                    "value": "decoder_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "states[:, :, size // 2:]",
                            "Subscript"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(decoder_outputs)",
                            "Call"
                        ],
                        [
                            "states[:, :, size // 2:]",
                            "Subscript"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(decoder_outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1602": {
                "variable": {
                    "value": "attention_states[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[attention_states[0], attns]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_1695": {
                "variable": {
                    "value": "other_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "other_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.stop_gradient(other_inputs)",
                            "Call"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.stop_gradient(other_inputs)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_1705": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_1706": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "states.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(states, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "states.write(time, state)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(states)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_1707": {
                "variable": {
                    "value": "decoder_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "states[:, :, size // 2:]",
                            "Subscript"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(decoder_outputs)",
                            "Call"
                        ],
                        [
                            "states[:, :, size // 2:]",
                            "Subscript"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.stop_gradient(decoder_outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1710": {
                "variable": {
                    "value": "attention_states[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[attention_states[0], attns]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1776": {
                "variable": {
                    "value": "total_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1820": {
                "variable": {
                    "value": "total_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_331": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(batch_size), encoder_input_length_ - 1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_332": {
                "variable": {
                    "value": "last_forward",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "encoder_outputs_[:, :, :cell_output_size]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_size), encoder_input_length_ - 1], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_372": {
                "input": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(hidden, keep_prob=encoder.attn_keep_prob, noise_shape=hidden_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(hidden, encoder.attn_size, use_bias=False, name='hidden')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(hidden, center=False, scope='layer_norm_hidden')",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(hidden, state)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_373": {
                "input": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(hidden, keep_prob=encoder.attn_keep_prob, noise_shape=hidden_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(hidden, encoder.attn_size, use_bias=False, name='hidden')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(hidden, center=False, scope='layer_norm_hidden')",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(hidden, state)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_384": {
                "equation": {
                    "value": "ijk,ik->ij",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(hidden, keep_prob=encoder.attn_keep_prob, noise_shape=hidden_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(hidden, encoder.attn_size, use_bias=False, name='hidden')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(hidden, center=False, scope='layer_norm_hidden')",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(hidden, state)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_418": {
                "name_or_scope": {
                    "value": "scope or 'attention_{}'.format(encoder.name)",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "concat_420": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_444": {
                "input": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_452": {
                "input": {
                    "value": "encoder_input_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.expand_dims(encoder_input_length, axis=1))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.to_int32(tf.reduce_sum(weights, axis=1))]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_454": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_outputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_inputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.equal(m, 0.0))",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.expand_dims(trg_mask, axis=2), tf.expand_dims(src_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_468": {
                "input": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_469": {
                "input": {
                    "value": "hidden_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_476": {
                "name_or_scope": {
                    "value": "scope or 'attention_{}'.format(encoder.name)",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "reshape_480": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_481": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "encoder_input_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_487": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_498": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.expand_dims(weights, 2) * hidden_states, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=tf.stack([batch_size, 0]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(hidden_states * tf.expand_dims(weights, axis=2), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(hidden_states * tf.expand_dims(weights, axis=2), axis=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.reduce_sum(tf.expand_dims(weights, axis=2) * hidden_states, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(weighted_average, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(weighted_average, encoder.attn_size)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.expand_dims(weights, axis=2) * hidden_states, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_643": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-weight_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "weight_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.embedding_weight_scale or encoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ]
                    ]
                }
            },
            "random_normal_initializer_645": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "weight_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.embedding_weight_scale or encoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ]
                    ]
                }
            },
            "device_647": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_666": {
                "variable": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.word_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dropout_670": {
                "variable": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.embedding_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "concat_712": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, input_]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_715": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_737": {
                "variable": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_, context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_748": {
                "variable": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.DEL_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_749": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(is_del, state, new_state)",
                            "Call"
                        ],
                        [
                            "tf.where(is_del, state, new_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_767": {
                "x": {
                    "value": "is_not_ins",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_769": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(max_pos)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_821": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ],
                        [
                            "scope_name + ('/' + '_'.join((encoder.name for encoder in encoders)))",
                            "BinOp"
                        ],
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_825": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(initial_state, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int64_845": {
                "x": {
                    "value": "tf.transpose(decoder_inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_857": {
                "name_or_scope": {
                    "value": "'decoder_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_866": {
                "variable": {
                    "value": "(state, context, pos, prev_weights)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[cell_state_size, context_size, 1, -1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_869": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_870": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(time, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : pos",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_902": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_903": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, context, pos, new_weights]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_953": {
                "name_or_scope": {
                    "value": "'decoder_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_1019": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-weight_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "weight_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.embedding_weight_scale or encoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ]
                    ]
                }
            },
            "random_normal_initializer_1021": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "weight_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.embedding_weight_scale or encoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ]
                    ]
                }
            },
            "device_1023": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_1042": {
                "variable": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.word_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dropout_1046": {
                "variable": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.embedding_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "concat_1088": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, input_]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1091": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1115": {
                "variable": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_, context, lm_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_1126": {
                "variable": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "symbol",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "utils.DEL_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_1127": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(is_del, state, new_state)",
                            "Call"
                        ],
                        [
                            "tf.where(is_del, state, new_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_1145": {
                "x": {
                    "value": "is_not_ins",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(is_keep, is_del)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_1147": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.to_float(max_pos)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_1213": {
                "variable": {
                    "value": "new_lm_state",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_del",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ],
                        [
                            "tf.equal(symbol, utils.DEL_ID)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "lm_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "new_lm_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(is_del, lm_state, new_lm_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_1220": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ],
                        [
                            "scope_name + ('/' + '_'.join((encoder.name for encoder in encoders)))",
                            "BinOp"
                        ],
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_1224": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(initial_state, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int64_1244": {
                "x": {
                    "value": "tf.transpose(decoder_inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_1263": {
                "name_or_scope": {
                    "value": "'decoder_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_1274": {
                "variable": {
                    "value": "(state, context, lm_state, pos, prev_weights)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[cell_state_size, context_size, lm_state_size, 1, -1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_1277": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_1278": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(time, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : pos",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "logical_and_1315": {
                "variable": {
                    "value": "use_target",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time < time_steps - 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.random_uniform([]) >= feed_previous",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "case_1316": {
                "variable": {
                    "value": "predicted_symbol",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(use_target, target), (tf.logical_not(feed_argmax), softmax)]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "argmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda : tf.argmax(output_, 1)",
                            "Lambda"
                        ],
                        [
                            "lambda : tf.argmax(logits, 1)",
                            "Lambda"
                        ],
                        [
                            "lambda : tf.argmax(output_, 1)",
                            "Lambda"
                        ]
                    ]
                }
            },
            "expand_dims_1324": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_1325": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state, context, lm_state, pos, new_weights]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_1386": {
                "name_or_scope": {
                    "value": "'decoder_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stop_gradient_1477": {
                "variable": {
                    "value": "decay",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0.5 ** (tf.to_float(global_step) / monotonicity_decay)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_int32_1508": {
                "x": {
                    "value": "tf.reduce_sum(target_weights, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_1522": {
                "input": {
                    "value": "reconstructed_weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_1523": {
                "input": {
                    "value": "reconstructed_weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_1525": {
                "a": {
                    "value": "reconstructed_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "attention_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[attention_weights, reconstructed_weights]",
                            "List"
                        ]
                    ]
                }
            },
            "eye_1525": {
                "num_rows": {
                    "value": "max_src_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(reconstructed_weights)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "norm_1531": {
                "tensor": {
                    "value": "attn_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(attention_weights * tf.stop_gradient(non_monotonous)) / tf.to_float(batch_size)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(reconstructed_weights, attention_weights) - tf.eye(max_src_len)",
                            "BinOp"
                        ],
                        [
                            "attn_loss * tf.to_float(src_mask)",
                            "BinOp"
                        ],
                        [
                            "tf.norm(attn_loss) / tf.to_float(batch_size)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_float_1531": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attention_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstructed_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(rewards)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_1562": {
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_1564": {
                "shape": {
                    "value": "tf.stack([batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_1604": {
                "variable": {
                    "value": "attention_states[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[attention_states[0], states]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_1668": {
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_1670": {
                "shape": {
                    "value": "tf.stack([batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_1712": {
                "variable": {
                    "value": "attention_states[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[attention_states[0], states]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_1757": {
                "t": {
                    "value": "tf.reduce_sum(e, axis=dim, keep_dims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "1e-36",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1e+38",
                    "type": "float",
                    "possible_values": []
                }
            },
            "shape_1761": {
                "input": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets[0]",
                            "Subscript"
                        ],
                        [
                            "targets[0]",
                            "Subscript"
                        ],
                        [
                            "targets[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_1762": {
                "input": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets[0]",
                            "Subscript"
                        ],
                        [
                            "targets[0]",
                            "Subscript"
                        ],
                        [
                            "targets[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "stack_1764": {
                "values": {
                    "value": "[time_steps * batch_size, logits.get_shape()[2].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_1765": {
                "values": {
                    "value": "[time_steps * batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_1768": {
                "values": {
                    "value": "[batch_size, time_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stop_gradient_1771": {
                "input": {
                    "value": "rewards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_1801": {
                "input": {
                    "value": "decoder_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_1814": {
                "input": {
                    "value": "rewards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_1827": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attention_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstructed_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(rewards)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_57": {
                "values": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(is_del, state, new_state)",
                            "Call"
                        ],
                        [
                            "tf.where(is_del, state, new_state)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_87": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-weight_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "weight_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.embedding_weight_scale or encoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ]
                    ]
                }
            },
            "random_normal_initializer_89": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "weight_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.embedding_weight_scale or encoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ],
                        [
                            "decoder.embedding_weight_scale or decoder.weight_scale",
                            "BoolOp"
                        ]
                    ]
                }
            },
            "device_91": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_112": {
                "name_or_scope": {
                    "value": "'encoder_{}'.format(encoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_142": {
                "variable": {
                    "value": "flat_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.multiply(batch_size, time_steps)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "embedding_lookup_143": {
                "variable": {
                    "value": "flat_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_variable('embedding_{}'.format(encoder.name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "flat_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(encoder_inputs_, [tf.multiply(batch_size, time_steps)])",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embeddings, flat_inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_144": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "flat_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(encoder_inputs_, [tf.multiply(batch_size, time_steps)])",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embeddings, flat_inputs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "embedding_lookup_148": {
                "variable": {
                    "value": "pos_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "pos_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('pos_embedding_{}'.format(encoder.name), shape=pos_embedding_shape, initializer=initializer)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "ids": {
                    "value": "pos_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(time_steps, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(pos_embeddings, pos_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(pos_inputs_, axis=0), [batch_size, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_149": {
                "variable": {
                    "value": "pos_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(pos_inputs_, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_150": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoder_inputs_, pos_inputs_]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_153": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoder_inputs_, other_inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_157": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "encoder.word_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dropout_162": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "encoder.embedding_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "expand_dims_182": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_207": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, time_steps, feature_size * channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "embedding_lookup_222": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "get_variable('embedding_{}'.format(encoder.name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "utils.BOS_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_223": {
                "input": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embeddings, utils.BOS_ID)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(pad, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.tile(pad, [batch_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros([batch_size, k, tf.shape(encoder_inputs_)[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_224": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embeddings, utils.BOS_ID)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(pad, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.tile(pad, [batch_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros([batch_size, k, tf.shape(encoder_inputs_)[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_244": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.int64, size=time_steps).unstack(tf.to_int64(tf.transpose(decoder_inputs)))",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.int64, size=time_steps).unstack(tf.to_int64(tf.transpose(decoder_inputs)))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_246": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "zeros_254": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, k, tf.shape(encoder_inputs_)[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_255": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoder_inputs_, pad]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pool_256": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "window_shape": {
                    "value": "[stride]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "MAX",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[stride]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_258": {
                "variable": {
                    "value": "encoder_input_length_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ceil(encoder_input_length_ / stride)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_336": {
                "variable": {
                    "value": "encoder_state_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "encoder_states_",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_396": {
                "input": {
                    "value": "tf.range(time_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_397": {
                "tensor": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_398": {
                "input": {
                    "value": "input_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "beam_search.resize_like(input_length, state)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_399": {
                "values": {
                    "value": "[src_pos, trg_pos, src_len]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_407": {
                "values": {
                    "value": "[batch_size, time_steps, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_414": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, size, activation=tf.nn.relu, use_bias=True, name='y')",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=not encoder.layer_norm, name='W_a')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(y, scope='layer_norm_state')",
                            "Call"
                        ],
                        [
                            "y + dense(conv, encoder.attn_size, use_bias=False, name='C_a')",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_429": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "e * mask",
                            "BinOp"
                        ],
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.exp(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_445": {
                "values": {
                    "value": "[batch_size, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_455": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_460": {
                "input": {
                    "value": "hidden_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_463": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_477": {
                "input": {
                    "value": "encoder_input_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.expand_dims(encoder_input_length, axis=1))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.to_int32(tf.reduce_sum(weights, axis=1))]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_492": {
                "variable": {
                    "value": "pos_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pos + offset",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos_, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.maximum(pos_, 0)",
                            "Call"
                        ],
                        [
                            "pos[i] if pos is not None else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[pos if i == align_encoder_id else None for i in range(len(encoders))]",
                            "ListComp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[pos if i == align_encoder_id else None for i in range(len(encoders))]",
                            "ListComp"
                        ]
                    ]
                },
                "y": {
                    "value": "encoder_input_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_493": {
                "variable": {
                    "value": "pos_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pos + offset",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos_, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.maximum(pos_, 0)",
                            "Call"
                        ],
                        [
                            "pos[i] if pos is not None else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[pos if i == align_encoder_id else None for i in range(len(encoders))]",
                            "ListComp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[pos if i == align_encoder_id else None for i in range(len(encoders))]",
                            "ListComp"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_494": {
                "variable": {
                    "value": "weights_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(tf.to_int32(tf.squeeze(pos_, axis=1)), depth=attn_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_495": {
                "variable": {
                    "value": "weighted_average_",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(weights_, axis=2) * hidden_states",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_501": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_502": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(weights, axis=2) * hidden_states",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_508": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "floor_509": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_input_length * pos",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_510": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_511": {
                "variable": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "encoder_input_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_513": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.to_float(tf.range(attn_length))",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.stack([batch_size])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_514": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.to_float(tf.range(attn_length)), tf.stack([batch_size]))",
                            "Call"
                        ],
                        [
                            "tf.reshape(idx, [-1, attn_length])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, attn_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_519": {
                "variable": {
                    "value": "mlow",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "idx < low",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "to_float_520": {
                "variable": {
                    "value": "mhigh",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "idx > high",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "to_float_524": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(m, 0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_538": {
                "variable": {
                    "value": "weighted_average",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(weights, axis=2) * hidden_states",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_569": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scope or 'attention_{}'.format(encoder.name)",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_595": {
                "values": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "attns.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(attns, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "attns.write(time, context)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(attns)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "DropoutWrapper_694": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicConvLSTMCell([feature_size, channels], encoder.conv_lstm_size, 1)",
                            "Call"
                        ],
                        [
                            "MultiRNNCell([get_cell(input_size if j == 0 else cell_output_size) for j in range(encoder.layers)])",
                            "Call"
                        ],
                        [
                            "get_cell(input_size)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(encoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(encoder.cell_size, reuse=reuse, fact_size=encoder.lstm_fact_size, proj_size=encoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=encoder.rnn_input_keep_prob, output_keep_prob=encoder.rnn_output_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob, variational_recurrent=encoder.pervasive_dropout, dtype=tf.float32, input_size=input_size)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm, input_size=input_size, input_keep_prob=encoder.rnn_input_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "decoder.rnn_input_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "output_keep_prob": {
                    "value": "decoder.rnn_output_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "state_keep_prob": {
                    "value": "decoder.rnn_state_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "variational_recurrent": {
                    "value": "decoder.pervasive_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_size": {
                    "value": "input_size_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_size if j == 0 else cell_output_size",
                            "IfExp"
                        ],
                        [
                            "input_size if j == 0 else cell_output_size",
                            "IfExp"
                        ]
                    ]
                }
            },
            "variable_scope_741": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(encoder.cell_size) if encoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dropout_793": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.deep_layer_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "zeros_827": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, cell_state_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_845": {
                "a": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_854": {
                "input": {
                    "value": "attention_states[align_encoder_id]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_855": {
                "input": {
                    "value": "attention_states[align_encoder_id][:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_860": {
                "input": {
                    "value": "initial_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.zeros([batch_size], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_865": {
                "name_or_scope": {
                    "value": "'decoder_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_924": {
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_926": {
                "input": {
                    "value": "tf.multinomial(tf.log(tf.nn.softmax(output_)), num_samples=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "DropoutWrapper_1070": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicConvLSTMCell([feature_size, channels], encoder.conv_lstm_size, 1)",
                            "Call"
                        ],
                        [
                            "MultiRNNCell([get_cell(input_size if j == 0 else cell_output_size) for j in range(encoder.layers)])",
                            "Call"
                        ],
                        [
                            "get_cell(input_size)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(encoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(encoder.cell_size, reuse=reuse, fact_size=encoder.lstm_fact_size, proj_size=encoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=encoder.rnn_input_keep_prob, output_keep_prob=encoder.rnn_output_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob, variational_recurrent=encoder.pervasive_dropout, dtype=tf.float32, input_size=input_size)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm, input_size=input_size, input_keep_prob=encoder.rnn_input_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "decoder.rnn_input_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "output_keep_prob": {
                    "value": "decoder.rnn_output_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "state_keep_prob": {
                    "value": "decoder.rnn_state_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "variational_recurrent": {
                    "value": "decoder.pervasive_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_size": {
                    "value": "input_size_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_size if j == 0 else cell_output_size",
                            "IfExp"
                        ],
                        [
                            "input_size if j == 0 else cell_output_size",
                            "IfExp"
                        ]
                    ]
                }
            },
            "variable_scope_1119": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(encoder.cell_size) if encoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dropout_1171": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "decoder.deep_layer_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, time_steps, 1] if encoder.pervasive_dropout else [batch_size, time_steps, 1]",
                            "IfExp"
                        ],
                        [
                            "[1, 1, size] if encoder.pervasive_dropout else [batch_size, time_steps, size]",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ],
                        [
                            "[1, 1] if decoder.pervasive_dropout else [tf.shape(input_)[0], 1]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else [tf.shape(input_)[0], size]",
                            "IfExp"
                        ],
                        [
                            "[1, size] if decoder.pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "variable_scope_1207": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(encoder.cell_size) if encoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "zeros_1226": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, cell_state_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_1244": {
                "a": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs[0][:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, decoder_inputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1260": {
                "input": {
                    "value": "attention_states[align_encoder_id]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_1261": {
                "input": {
                    "value": "attention_states[align_encoder_id][:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_1267": {
                "input": {
                    "value": "initial_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.zeros([batch_size], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_1273": {
                "name_or_scope": {
                    "value": "'decoder_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_1351": {
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_1353": {
                "input": {
                    "value": "tf.multinomial(tf.log(tf.nn.softmax(output_)), num_samples=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_1368": {
                "name_or_scope": {
                    "value": "rnn_lm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_1455": {
                "input": {
                    "value": "attention_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[attention_weights, reconstructed_weights]",
                            "List"
                        ]
                    ]
                }
            },
            "shape_1456": {
                "input": {
                    "value": "attention_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[attention_weights, reconstructed_weights]",
                            "List"
                        ]
                    ]
                }
            },
            "shape_1457": {
                "input": {
                    "value": "attention_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[attention_weights, reconstructed_weights]",
                            "List"
                        ]
                    ]
                }
            },
            "reshape_1459": {
                "tensor": {
                    "value": "tf.range(src_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, src_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1460": {
                "tensor": {
                    "value": "tf.range(trg_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, trg_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_1463": {
                "input_tensor": {
                    "value": "trg_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_weights(targets[:, 1:], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_1464": {
                "tensor": {
                    "value": "source_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_input_length[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1465": {
                "tensor": {
                    "value": "target_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.reduce_sum(trg_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "[tf.to_int32(tf.reduce_sum(target_weights, axis=1))]",
                            "List"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sequence_mask_1467": {
                "lengths": {
                    "value": "source_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_input_length[0]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "src_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(input_length, axis=1), [1, time_steps])",
                            "Call"
                        ],
                        [
                            "tf.shape(attention_weights)[2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "expand_dims_1468": {
                "input": {
                    "value": "src_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.sequence_mask(source_length, maxlen=src_len))",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length[0], maxlen=max_src_len, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ij,ik->ijk', src_mask, src_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1474": {
                "input_tensor": {
                    "value": "attention_weights * tf.stop_gradient(non_monotonous)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_1474": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attention_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstructed_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(rewards)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_int32_1495": {
                "x": {
                    "value": "tf.reduce_sum(weights, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_1508": {
                "input_tensor": {
                    "value": "target_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_weights(targets[0][:, 1:], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(targets[1][:, 1:], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(targets[:, 1:], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(targets[:, 1:], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_1552": {
                "x": {
                    "value": "tf.reduce_sum(weights, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_int32_1657": {
                "x": {
                    "value": "tf.reduce_sum(weights, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_1757": {
                "input_tensor": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "e * mask",
                            "BinOp"
                        ],
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.exp(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "to_float_1783": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attention_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstructed_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(rewards)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_initializer_1802": {
                "value": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "DropoutWrapper_131": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicConvLSTMCell([feature_size, channels], encoder.conv_lstm_size, 1)",
                            "Call"
                        ],
                        [
                            "MultiRNNCell([get_cell(input_size if j == 0 else cell_output_size) for j in range(encoder.layers)])",
                            "Call"
                        ],
                        [
                            "get_cell(input_size)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(encoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(encoder.cell_size, reuse=reuse, fact_size=encoder.lstm_fact_size, proj_size=encoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=encoder.rnn_input_keep_prob, output_keep_prob=encoder.rnn_output_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob, variational_recurrent=encoder.pervasive_dropout, dtype=tf.float32, input_size=input_size)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm, input_size=input_size, input_keep_prob=encoder.rnn_input_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "encoder.rnn_input_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "output_keep_prob": {
                    "value": "encoder.rnn_output_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "state_keep_prob": {
                    "value": "encoder.rnn_state_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "variational_recurrent": {
                    "value": "encoder.pervasive_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_size": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_.get_shape()[2].value",
                            "Attribute"
                        ],
                        [
                            "input_.get_shape()[1].value",
                            "Attribute"
                        ],
                        [
                            "input_.get_shape()[1].value",
                            "Attribute"
                        ],
                        [
                            "new_input.get_shape()[1].value",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_138": {
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "shape_139": {
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "conv2d_193": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('filter_{}'.format(k), [filter_height, filter_width, in_channels, out_channels])",
                            "Call"
                        ],
                        [
                            "get_variable('filter_{}'.format(w), [w, encoder.embedding_size, filter_size])",
                            "Call"
                        ],
                        [
                            "get_variable('filter', filter_shape)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.conv_strides or [1, 1]",
                            "BoolOp"
                        ],
                        [
                            "[1] + strides + [1]",
                            "BinOp"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_int32_201": {
                "variable": {
                    "value": "encoder_input_length_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ceil(encoder_input_length_ / strides[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_212": {
                "variable": {
                    "value": "(encoder_inputs_, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicConvLSTMCell([feature_size, channels], encoder.conv_lstm_size, 1)",
                            "Call"
                        ],
                        [
                            "MultiRNNCell([get_cell(input_size if j == 0 else cell_output_size) for j in range(encoder.layers)])",
                            "Call"
                        ],
                        [
                            "get_cell(input_size)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(encoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(encoder.cell_size, reuse=reuse, fact_size=encoder.lstm_fact_size, proj_size=encoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=encoder.rnn_input_keep_prob, output_keep_prob=encoder.rnn_output_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob, variational_recurrent=encoder.pervasive_dropout, dtype=tf.float32, input_size=input_size)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm, input_size=input_size, input_keep_prob=encoder.rnn_input_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicConvLSTMCell([feature_size, channels], encoder.conv_lstm_size, 1)",
                            "Call"
                        ],
                        [
                            "MultiRNNCell([get_cell(input_size if j == 0 else cell_output_size) for j in range(encoder.layers)])",
                            "Call"
                        ],
                        [
                            "get_cell(input_size)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(encoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(encoder.cell_size, reuse=reuse, fact_size=encoder.lstm_fact_size, proj_size=encoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=encoder.rnn_input_keep_prob, output_keep_prob=encoder.rnn_output_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob, variational_recurrent=encoder.pervasive_dropout, dtype=tf.float32, input_size=input_size)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm, input_size=input_size, input_keep_prob=encoder.rnn_input_keep_prob, state_keep_prob=encoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(encoder.cell_size, reuse=reuse, layer_norm=encoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ],
                        [
                            "CellWrapper(BasicLSTMCell(decoder.cell_size, reuse=reuse))",
                            "Call"
                        ],
                        [
                            "PLSTM(decoder.cell_size, reuse=reuse, fact_size=decoder.lstm_fact_size, proj_size=decoder.lstm_proj_size)",
                            "Call"
                        ],
                        [
                            "DropoutWrapper(cell, input_keep_prob=decoder.rnn_input_keep_prob, output_keep_prob=decoder.rnn_output_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob, variational_recurrent=decoder.pervasive_dropout, dtype=tf.float32, input_size=input_size_)",
                            "Call"
                        ],
                        [
                            "DropoutGRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm, input_size=input_size_, input_keep_prob=decoder.rnn_input_keep_prob, state_keep_prob=decoder.rnn_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "GRUCell(decoder.cell_size, reuse=reuse, layer_norm=decoder.layer_norm)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_216": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convolution_241": {
                "variable": {
                    "value": "inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([pad_left, encoder_inputs_, pad_right], axis=1)",
                            "Call"
                        ],
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "tf.nn.convolution(inputs_, filter=filter_, padding='VALID')",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "filter_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('filter_{}'.format(k), [filter_height, filter_width, in_channels, out_channels])",
                            "Call"
                        ],
                        [
                            "get_variable('filter_{}'.format(w), [w, encoder.embedding_size, filter_size])",
                            "Call"
                        ],
                        [
                            "get_variable('filter', filter_shape)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MultiRNNCell_315": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cells": {
                    "value": "[get_cell(input_size if j == 0 else cell_output_size) for j in range(encoder.layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "sequence_mask_338": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "encoder_input_length_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_input_length[i]",
                            "Subscript"
                        ],
                        [
                            "tf.to_int32(tf.ceil(encoder_input_length_ / stride))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(tf.ceil(encoder_input_length_ / strides[1]))",
                            "Call"
                        ],
                        [
                            "(encoder_input_length_ + stride - 1) // stride",
                            "BinOp"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(encoder_outputs_)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_339": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_outputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_inputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.equal(m, 0.0))",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.expand_dims(trg_mask, axis=2), tf.expand_dims(src_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_431": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.argmax(e, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "tf.shape(e)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_438": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_453": {
                "input": {
                    "value": "hidden_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "one_hot_487": {
                "indices": {
                    "value": "tf.to_int32(tf.squeeze(pos, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "attn_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden_states)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_float_522": {
                "x": {
                    "value": "idx >= encoder_input_length",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "truediv_532": {
                "variable": {
                    "value": "div",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "numerator",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.pow(idx - pos, tf.convert_to_tensor(2, dtype=tf.float32))",
                            "UnaryOp"
                        ]
                    ]
                },
                "y": {
                    "value": "2 * sigma ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_668": {
                "input": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "MultiRNNCell_704": {
                "cells": {
                    "value": "cells",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_727": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ],
                        [
                            "scope_name + ('/' + '_'.join((encoder.name for encoder in encoders)))",
                            "BinOp"
                        ],
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_741": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_769": {
                "x": {
                    "value": "max_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "beam_search.resize_like(max_pos, symbol)",
                            "Call"
                        ],
                        [
                            "time_steps",
                            "variable"
                        ],
                        [
                            "beam_search.resize_like(max_pos, symbol)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pool_799": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(output_, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "window_shape": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "MAX",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_801": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_803": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "*tf.split(output_, num_or_size_splits=2, axis=1)",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "matmul_813": {
                "a": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(embedding)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_825": {
                "input": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(get_initial_state(),) * encoder.layers",
                            "BinOp"
                        ],
                        [
                            "get_initial_state()",
                            "Call"
                        ],
                        [
                            "get_variable(name, initializer=tf.zeros(cell_state_size))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_870": {
                "x": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_909": {
                "name_or_scope": {
                    "value": "conditional_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_917": {
                "name_or_scope": {
                    "value": "conditional_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multinomial_926": {
                "logits": {
                    "value": "tf.log(tf.nn.softmax(output_))",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_1044": {
                "input": {
                    "value": "embedded_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedding, input_)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_input, keep_prob=decoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "MultiRNNCell_1080": {
                "cells": {
                    "value": "cells",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_1104": {
                "name_or_scope": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ],
                        [
                            "scope_name + ('/' + '_'.join((encoder.name for encoder in encoders)))",
                            "BinOp"
                        ],
                        [
                            "'decoder_{}'.format(decoder.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_1119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_1147": {
                "x": {
                    "value": "max_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "beam_search.resize_like(max_pos, symbol)",
                            "Call"
                        ],
                        [
                            "time_steps",
                            "variable"
                        ],
                        [
                            "beam_search.resize_like(max_pos, symbol)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pool_1177": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(output_, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "window_shape": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "pooling_type": {
                    "value": "MAX",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "strides": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_1179": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_1181": {
                "variable": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "*tf.split(output_, num_or_size_splits=2, axis=1)",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "matmul_1191": {
                "a": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(embedding)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_scope_1207": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_1224": {
                "input": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(get_initial_state(),) * encoder.layers",
                            "BinOp"
                        ],
                        [
                            "get_initial_state()",
                            "Call"
                        ],
                        [
                            "get_variable(name, initializer=tf.zeros(cell_state_size))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_1278": {
                "x": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_1310": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_1312": {
                "input": {
                    "value": "tf.multinomial(tf.log(tf.nn.softmax(logits)), num_samples=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_1321": {
                "name_or_scope": {
                    "value": "rnn_lm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_1331": {
                "name_or_scope": {
                    "value": "conditional_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_1342": {
                "name_or_scope": {
                    "value": "conditional_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multinomial_1353": {
                "logits": {
                    "value": "tf.log(tf.nn.softmax(output_))",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_1366": {
                "x": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_1423": {
                "x": {
                    "value": "tf.reduce_sum(mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_1495": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1552": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_1564": {
                "values": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_1617": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "map_attns/matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ]
                    ]
                }
            },
            "get_variable_1618": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "map_attns/bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape[-1:]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_sum_1657": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_1670": {
                "values": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_1725": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "map_attns/matrix",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ]
                    ]
                }
            },
            "get_variable_1726": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "map_attns/bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape[-1:]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[-1], attention_states[0].get_shape()[-1]]",
                            "List"
                        ]
                    ]
                }
            },
            "stack_145": {
                "values": {
                    "value": "[batch_size, time_steps, flat_inputs.get_shape()[1].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_149": {
                "input": {
                    "value": "pos_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(time_steps, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(pos_embeddings, pos_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(pos_inputs_, axis=0), [batch_size, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_160": {
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "batch_normalization_173": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'input_batch_norm_{}'.format(j + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_179": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "encoder.input_layer_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "batch_normalization_196": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'conv_batch_norm_{}'.format(k)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_199": {
                "variable": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "shape_205": {
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "tile_235": {
                "variable": {
                    "value": "pad_right",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embeddings, utils.BOS_ID)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(pad, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.tile(pad, [batch_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros([batch_size, k, tf.shape(encoder_inputs_)[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, right, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_236": {
                "variable": {
                    "value": "pad_left",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(embeddings, utils.BOS_ID)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(pad, axis=0), axis=1)",
                            "Call"
                        ],
                        [
                            "tf.tile(pad, [batch_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros([batch_size, k, tf.shape(encoder_inputs_)[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ],
                        [
                            "tf.ones(shape=tf.stack([batch_size, 1]), dtype=tf.int32) * utils.BOS_ID",
                            "BinOp"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, left, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_237": {
                "variable": {
                    "value": "inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pad_left, encoder_inputs_, pad_right]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_253": {
                "x": {
                    "value": "tf.ceil(time_steps / stride) * stride",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ceil_258": {
                "x": {
                    "value": "encoder_input_length_ / stride",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dense_266": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "g * y + (1 - g) * x",
                            "BinOp"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[2]",
                            "Subscript"
                        ],
                        [
                            "x.shape[2].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(embedded_input)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(output_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(embedded_input)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(output_)[1]",
                            "Subscript"
                        ],
                        [
                            "states.get_shape()[2].value",
                            "Attribute"
                        ],
                        [
                            "states.get_shape()[2].value",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "g",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_267": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "g * y + (1 - g) * x",
                            "BinOp"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[2]",
                            "Subscript"
                        ],
                        [
                            "x.shape[2].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(embedded_input)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(output_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(embedded_input)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(output_)[1]",
                            "Subscript"
                        ],
                        [
                            "states.get_shape()[2].value",
                            "Attribute"
                        ],
                        [
                            "states.get_shape()[2].value",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "y",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_289": {
                "input": {
                    "value": "tf.expand_dims(initial_state, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_305": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(encoder.cell_size) if encoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.random_uniform_initializer(minval=-weight_scale, maxval=weight_scale)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_scale)",
                            "Call"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ],
                        [
                            "CellInitializer(decoder.cell_size) if decoder.orthogonal_init else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "range_331": {},
            "sequence_mask_342": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "encoder_input_length_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_input_length[i]",
                            "Subscript"
                        ],
                        [
                            "tf.to_int32(tf.ceil(encoder_input_length_ / stride))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(tf.ceil(encoder_input_length_ / strides[1]))",
                            "Call"
                        ],
                        [
                            "(encoder_input_length_ + stride - 1) // stride",
                            "BinOp"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(encoder_inputs_)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_343": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_outputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_inputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.equal(m, 0.0))",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.expand_dims(trg_mask, axis=2), tf.expand_dims(src_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_376": {
                "input": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_378": {
                "input": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(hidden, keep_prob=encoder.attn_keep_prob, noise_shape=hidden_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(hidden, encoder.attn_size, use_bias=False, name='hidden')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(hidden, center=False, scope='layer_norm_hidden')",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(hidden, state)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_423": {
                "input": {
                    "value": "hidden_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_max_433": {
                "input_tensor": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "e * mask",
                            "BinOp"
                        ],
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.exp(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_446": {
                "input": {
                    "value": "hidden_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_487": {
                "x": {
                    "value": "tf.squeeze(pos, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "one_hot_494": {
                "indices": {
                    "value": "tf.to_int32(tf.squeeze(pos_, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "attn_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden_states)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_501": {
                "indices": {
                    "value": "tf.to_int32(tf.squeeze(pos, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "attn_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden_states)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "matmul_508": {
                "a": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(state, keep_prob=encoder.attn_keep_prob, noise_shape=state_noise_shape)",
                            "Call"
                        ],
                        [
                            "dense(state, encoder.attn_size, use_bias=False, name='state')",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, input_], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([state, context], axis=1)",
                            "Call"
                        ],
                        [
                            "state[:, -cell_output_size:]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([state, context, lm_state, pos, new_weights], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.split(value=state, num_or_size_splits=self.num_splits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "wp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('Wp', [state_size, state_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_513": {
                "x": {
                    "value": "tf.range(attn_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_513": {
                "values": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_524": {
                "x": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mlow + mhigh",
                            "BinOp"
                        ],
                        [
                            "m + tf.to_float(idx >= encoder_input_length)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "exp_534": {
                "x": {
                    "value": "div",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.truediv(numerator, 2 * sigma ** 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "BasicLSTMCell_682": {
                "num_units": {
                    "value": "decoder.cell_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_791": {
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_813": {
                "a": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ],
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_883": {
                "name_or_scope": {
                    "value": "conditional_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_888": {
                "variable": {
                    "value": "(output, state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(time, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (output, state)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : update(state, input_, context, ids)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "variable_scope_895": {
                "name_or_scope": {
                    "value": "conditional_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_926": {
                "x": {
                    "value": "tf.nn.softmax(output_)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_932": {
                "x": {
                    "value": "feed_argmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "BasicLSTMCell_1058": {
                "num_units": {
                    "value": "decoder.cell_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_1169": {
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_1191": {
                "a": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ],
                        [
                            "get_variable('embedding_{}'.format(embedding_name), shape=embedding_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_1291": {
                "name_or_scope": {
                    "value": "conditional_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_1296": {
                "variable": {
                    "value": "(output, state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(time, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (output, state)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : update(state, input_, context, ids, lm_state)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "variable_scope_1303": {
                "name_or_scope": {
                    "value": "conditional_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multinomial_1312": {
                "logits": {
                    "value": "tf.log(tf.nn.softmax(logits))",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_1334": {
                "name_or_scope": {
                    "value": "op_decoder_rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_1345": {
                "name_or_scope": {
                    "value": "op_decoder_rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_1353": {
                "x": {
                    "value": "tf.nn.softmax(output_)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_1359": {
                "x": {
                    "value": "feed_argmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_1423": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_outputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_inputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.equal(m, 0.0))",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.expand_dims(trg_mask, axis=2), tf.expand_dims(src_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_1474": {
                "input": {
                    "value": "non_monotonous",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1 - monotonous) * mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "tanh_1622": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "g * y + (1 - g) * x",
                            "BinOp"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_1730": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "g * y + (1 - g) * x",
                            "BinOp"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_23": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BasicLSTMCell_119": {
                "num_units": {
                    "value": "encoder.cell_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "multiply_142": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(state)[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "input_shape[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attention_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstructed_weights)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(decoder_inputs)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(rewards)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "time_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(encoder_inputs_)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden)[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "input_shape[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(targets)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ceil_201": {
                "x": {
                    "value": "encoder_input_length_ / strides[1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_265": {
                "name_or_scope": {
                    "value": "'highway_{}'.format(j + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_289": {
                "input": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(get_initial_state(),) * encoder.layers",
                            "BinOp"
                        ],
                        [
                            "get_initial_state()",
                            "Call"
                        ],
                        [
                            "get_variable(name, initializer=tf.zeros(cell_state_size))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(initial_state, keep_prob=decoder.initial_state_keep_prob)",
                            "Call"
                        ],
                        [
                            "get_variable(shape=[cell_state_size], name='initial_state')",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(initial_state, axis=0), [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, cell_state_size])",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=False, name='initial_state_projection')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(initial_state, activation_fn=activation_fn, scope='initial_state_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(initial_state, cell_state_size, use_bias=True, name='initial_state_projection', activation=activation_fn)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_scope_305": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_340": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_outputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_inputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.equal(m, 0.0))",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.expand_dims(trg_mask, axis=2), tf.expand_dims(src_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_346": {
                "variable": {
                    "value": "encoder_state_",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[last_forward, last_backward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_360": {
                "values": {
                    "value": "[encoder_inputs_, encoder_outputs_]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_431": {
                "input": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "e * mask",
                            "BinOp"
                        ],
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.exp(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_435": {
                "x": {
                    "value": "e / T",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_436": {
                "input_tensor": {
                    "value": "exp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(e / T) * mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "squeeze_487": {
                "input": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_494": {
                "x": {
                    "value": "tf.squeeze(pos_, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_495": {
                "input": {
                    "value": "weights_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos_, axis=1)), depth=attn_length))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_501": {
                "x": {
                    "value": "tf.squeeze(pos, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_502": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_508": {
                "x": {
                    "value": "tf.matmul(state, wp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "range_513": {},
            "pow_531": {
                "x": {
                    "value": "idx - pos",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.convert_to_tensor(2, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_538": {
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "e",
                            "variable"
                        ],
                        [
                            "tf.nn.sigmoid(e)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.argmax(e, -1), depth=tf.shape(e)[1])",
                            "Call"
                        ],
                        [
                            "exp / tf.reduce_sum(exp, axis=-1, keep_dims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.zeros(shape=[batch_size, tf.shape(hidden_states)[1]])",
                            "Call"
                        ],
                        [
                            "tf.to_float(mask) / lengths",
                            "BinOp"
                        ],
                        [
                            "tf.one_hot(encoder_input_length - 1, tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(weights)",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.one_hot(tf.to_int32(tf.squeeze(pos, axis=1)), depth=attn_length))",
                            "Call"
                        ],
                        [
                            "softmax(e, mask=mask)",
                            "Call"
                        ],
                        [
                            "weights * tf.exp(div)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "sum(weights) / len(weights)",
                            "BinOp"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(dtype=tf.float32, size=time_steps)",
                            "Call"
                        ],
                        [
                            "weights.stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(weights, perm=(1, 0, 2))",
                            "Call"
                        ],
                        [
                            "weights.write(time, new_weights)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs[0], utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_665": {
                "input": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([input_, context], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.concat([input_, context, lm_state], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_669": {
                "input": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([input_, context], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.concat([input_, context, lm_state], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_799": {
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_926": {
                "logits": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1041": {
                "input": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([input_, context], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.concat([input_, context, lm_state], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1045": {
                "input": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([input_, context], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ],
                        [
                            "tf.concat([input_, context, lm_state], axis=1)",
                            "Call"
                        ],
                        [
                            "embed(ids)",
                            "Call"
                        ],
                        [
                            "embed(predicted_symbol)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_1177": {
                "input": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_1312": {
                "x": {
                    "value": "tf.nn.softmax(logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_1318": {
                "x": {
                    "value": "feed_argmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_1353": {
                "logits": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_1477": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "einsum_1620": {
                "equation": {
                    "value": "ijk,kl->ijl",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "g * y + (1 - g) * x",
                            "BinOp"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('map_attns/matrix', shape=shape)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('map_attns/matrix', shape=shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_1728": {
                "equation": {
                    "value": "ijk,kl->ijl",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs_",
                            "variable"
                        ],
                        [
                            "g * y + (1 - g) * x",
                            "BinOp"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ],
                        [
                            "attns",
                            "variable"
                        ],
                        [
                            "tf.einsum('ijk,kl->ijl', x, w) + b",
                            "BinOp"
                        ],
                        [
                            "decoder_outputs",
                            "variable"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "tf.nn.tanh(x)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('map_attns/matrix', shape=shape)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('map_attns/matrix', shape=shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_23": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ceil_253": {
                "x": {
                    "value": "time_steps / stride",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_254": {
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            },
            "zeros_288": {
                "shape": {
                    "value": "cell_state_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_344": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_outputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length_, maxlen=tf.shape(encoder_inputs_)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(encoder_input_length, maxlen=tf.shape(hidden_states)[1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.equal(m, 0.0))",
                            "Call"
                        ],
                        [
                            "get_weights(encoder_inputs_, utils.EOS_ID, include_first_eos=True)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.expand_dims(trg_mask, axis=2), tf.expand_dims(src_mask, axis=1))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_348": {
                "variable": {
                    "value": "encoder_state_",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_494": {
                "input": {
                    "value": "pos_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pos + offset",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos_, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.maximum(pos_, 0)",
                            "Call"
                        ],
                        [
                            "pos[i] if pos is not None else None",
                            "IfExp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[pos if i == align_encoder_id else None for i in range(len(encoders))]",
                            "ListComp"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "[pos if i == align_encoder_id else None for i in range(len(encoders))]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_501": {
                "input": {
                    "value": "pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(tf.matmul(tf.nn.tanh(tf.matmul(state, wp)), vp))",
                            "Call"
                        ],
                        [
                            "tf.floor(encoder_input_length * pos)",
                            "Call"
                        ],
                        [
                            "tf.reshape(pos, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, encoder_input_length - 1)",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "pos + tf.to_float(is_not_ins)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "beam_search.resize_like(pos, symbol)",
                            "Call"
                        ],
                        [
                            "tf.minimum(pos, tf.to_float(max_pos))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(time, 0), lambda : pos, lambda : update_pos(pos, ids, encoder_input_length[align_encoder_id]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(pos, axis=1)",
                            "Call"
                        ],
                        [
                            "update_pos(pos, predicted_symbol, encoder_input_length[align_encoder_id])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_531": {
                "value": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_803": {
                "value": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_888": {
                "x": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_1181": {
                "value": {
                    "value": "output_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "tf.concat(projection_input, axis=1)",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, use_bias=False, name='deep_output')",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(output_, activation_fn=tf.nn.tanh, scope='output_layer_norm')",
                            "Call"
                        ],
                        [
                            "dense(output_, deep_layer_size, activation=tf.tanh, use_bias=True, name='deep_output')",
                            "Call"
                        ],
                        [
                            "dense(output_, maxout_size, use_bias=True, name='maxout')",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(tf.expand_dims(output_, axis=2), window_shape=[2], pooling_type='MAX', padding='SAME', strides=[2])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.maximum(*tf.split(output_, num_or_size_splits=2, axis=1))",
                            "Call"
                        ],
                        [
                            "dense(output_, decoder.embedding_size, use_bias=False, name='softmax0')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output_, keep_prob=decoder.deep_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.matmul(output_, tf.transpose(embedding)) + bias",
                            "BinOp"
                        ],
                        [
                            "dense(output_, decoder.vocab_size, use_bias=True, name='softmax1')",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_1296": {
                "x": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "tf.constant(0, dtype=tf.int32, name='time')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_1312": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ],
                        [
                            "generate(output, input_, context)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_338": {
                "input": {
                    "value": "encoder_outputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dense(encoder_outputs_, cell_output_size, use_bias=False, name='bidir_projection')",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_431": {
                "input": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "e * mask",
                            "BinOp"
                        ],
                        [
                            "compute_energy(hidden_states, state, encoder, input_length=encoder_input_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.exp(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_342": {
                "input": {
                    "value": "encoder_inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_inputs[i]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(flat_inputs, tf.stack([batch_size, time_steps, flat_inputs.get_shape()[1].value]))",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pos_inputs_], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, other_inputs], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.word_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.embedding_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(encoder_inputs_, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(encoder_inputs_, filter_, strides, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoder_inputs_, [batch_size, time_steps, feature_size * channels])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='input_batch_norm_{}'.format(j + 1))",
                            "Call"
                        ],
                        [
                            "dense(encoder_inputs_, layer_size, activation=activation, use_bias=True, name='layer_{}'.format(j))",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(encoder_inputs_, training=training, name='conv_batch_norm_{}'.format(k))",
                            "Call"
                        ],
                        [
                            "tf.concat(encoder_inputs_, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoder_inputs_, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.pool(encoder_inputs_, window_shape=[stride], pooling_type='MAX', padding='VALID', strides=[stride])",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(encoder_inputs_, keep_prob=encoder.input_layer_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(encoder_inputs_)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ],
                        [
                            "encoder_inputs",
                            "variable"
                        ]
                    ]
                }
            }
        }
    },
    "translate/rnn.py": {
        "tensorflow": {
            "reshape_78": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[:, ::stride, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(inputs, tf.stack([shape[0], tf.shape(inputs)[1], shape[2]]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs_, axis=0) / len(inputs_)",
                            "BinOp"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([shape[0], tf.shape(inputs)[1], shape[2]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_160": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[:, ::stride, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(inputs, tf.stack([shape[0], tf.shape(inputs)[1], shape[2]]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs_, axis=0) / len(inputs_)",
                            "BinOp"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_181": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[3 * self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "self._bias_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_183": {
                "variable": {
                    "value": "inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "dropped_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "DropoutGRUCell._dropout(inputs, self._input_noise, self._input_keep_prob)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "b": {
                    "value": "input_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', [input_size, 3 * self._num_units], dtype=dtype, initializer=self._kernel_initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_184": {
                "variable": {
                    "value": "state_",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "dropped_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "DropoutGRUCell._dropout(state, self._state_noise, self._state_keep_prob)",
                            "Call"
                        ],
                        [
                            "state",
                            "variable"
                        ]
                    ]
                },
                "b": {
                    "value": "state_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', [state_size, 3 * self._num_units], dtype=dtype, initializer=self._kernel_initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_191": {
                "variable": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "state_[:, :size] + inputs_[:, :size] + bias[:size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_192": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(state_[:, :size] + inputs_[:, :size] + bias[:size])",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(inputs_ + state_ + bias)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_218": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[:, ::stride, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(inputs, tf.stack([shape[0], tf.shape(inputs)[1], shape[2]]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs_, axis=0) / len(inputs_)",
                            "BinOp"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_287": {
                "variable": {
                    "value": "(c, h)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2 * self._num_units",
                            "BinOp"
                        ],
                        [
                            "[self.state_size - self.output_size, self.output_size]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_289": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_292": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([inputs, h], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(T, self._fact_size, use_bias=False, name='factorization')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(T, 4 * self._num_units, use_bias=True)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "4 * self._num_units",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "split_295": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([inputs, h], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(T, self._fact_size, use_bias=False, name='factorization')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(T, 4 * self._num_units, use_bias=True)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_303": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_c, new_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_15": {
                "name_or_scope": {
                    "value": "scope or 'stack_bidirectional_rnn'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_71": {
                "variable": {
                    "value": "paddings",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[[0, 0], [0, max_len - len_], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_72": {
                "variable": {
                    "value": "inputs_[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs_[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "paddings": {
                    "value": "paddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([[0, 0], [0, max_len - len_], [0, 0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_78": {
                "values": {
                    "value": "[shape[0], tf.shape(inputs)[1], shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_104": {
                "values": {
                    "value": "U",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_121": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "([1], tf.TensorShape(s).as_list())",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "map_structure_146": {
                "func": {
                    "value": "enumerated_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "*args",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "floor_152": {
                "variable": {
                    "value": "binary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "random_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob + noise",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_176": {
                "variable": {
                    "value": "state_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[state_size, 3 * self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "self._kernel_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_179": {
                "variable": {
                    "value": "input_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size, 3 * self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "self._kernel_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_228": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2 * self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._bias_initializer",
                            "Attribute"
                        ],
                        [
                            "init_ops.constant_initializer(1.0, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_229": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size + state_size, 2 * self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "self._kernel_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_232": {
                "variable": {
                    "value": "inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[:, ::stride, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(inputs, tf.stack([shape[0], tf.shape(inputs)[1], shape[2]]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs_, axis=0) / len(inputs_)",
                            "BinOp"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights[:input_size]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_233": {
                "variable": {
                    "value": "state_",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "weights[input_size:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sigmoid_239": {
                "variable": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs_ + state_ + bias",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_240": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(state_[:, :size] + inputs_[:, :size] + bias[:size])",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(inputs_ + state_ + bias)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_243": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "self._bias_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_244": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_size + state_size, self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "self._kernel_initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_247": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([inputs, r * state], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', [input_size + state_size, 2 * self._num_units], dtype=dtype, initializer=self._kernel_initializer)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('kernel', [input_size + state_size, self._num_units], dtype=dtype, initializer=self._kernel_initializer)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_291": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([inputs, h], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(T, self._fact_size, use_bias=False, name='factorization')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(T, 4 * self._num_units, use_bias=True)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self._fact_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "factorization",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_301": {
                "variable": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(new_h, self._proj_size, use_bias=False, name='projection')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "self._proj_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "projection",
                    "type": "str",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_25": {
                "variable": {
                    "value": "(outputs, (state_fw, state_bw))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell_fw",
                    "type": "variable",
                    "possible_values": []
                },
                "cell_bw": {
                    "value": "cell_bw",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(prev_layer, layer_size, use_bias=not batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(prev_layer, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(prev_layer)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(prev_layer, keep_prob=inter_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "initial_state_fw": {
                    "value": "initial_state_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "initial_states_fw[i]",
                            "Subscript"
                        ]
                    ]
                },
                "initial_state_bw": {
                    "value": "initial_state_bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "initial_states_bw[i]",
                            "Subscript"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(sequence_length + stride - 1) // stride",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_35": {
                "variable": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_63": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[:, ::stride, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(inputs, tf.stack([shape[0], tf.shape(inputs)[1], shape[2]]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs_, axis=0) / len(inputs_)",
                            "BinOp"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_68": {
                "input": {
                    "value": "inputs_[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "input_tensor": {
                    "value": "inputs_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[inputs[:, i::stride, :] for i in range(stride)]",
                            "ListComp"
                        ],
                        [
                            "tf.matmul(dropped_inputs, input_weights)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(inputs_)",
                            "Call"
                        ],
                        [
                            "tf.matmul(inputs, weights[:input_size])",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.layer_norm(inputs_, scope='inputs')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_175": {
                "name_or_scope": {
                    "value": "state",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_178": {
                "name_or_scope": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_223": {
                "name_or_scope": {
                    "value": "gates",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_226": {
                "variable": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_242": {
                "name_or_scope": {
                    "value": "candidate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_24": {
                "name_or_scope": {
                    "value": "'cell_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_43": {
                "variable": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(prev_layer, layer_size, use_bias=not batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(prev_layer, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(prev_layer)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(prev_layer, keep_prob=inter_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "layer_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inter_layers[i]",
                            "Subscript"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "not batch_norm",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_70": {
                "input": {
                    "value": "inputs_[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_variable_scope_90": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "div_153": {
                "x": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(state_[:, :size] + inputs_[:, :size] + bias[:size])",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(inputs_ + state_ + bias)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "concat_247": {
                "values": {
                    "value": "[inputs, r * state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_normalization_46": {
                "variable": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(prev_layer, layer_size, use_bias=not batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(prev_layer, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(prev_layer)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(prev_layer, keep_prob=inter_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "relu_49": {
                "variable": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(prev_layer, layer_size, use_bias=not batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(prev_layer, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(prev_layer)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(prev_layer, keep_prob=inter_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_53": {
                "variable": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(prev_layer, layer_size, use_bias=not batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(prev_layer, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(prev_layer)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(prev_layer, keep_prob=inter_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "inter_layer_keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, tf.shape(prev_layer)[2]] if pervasive_dropout else None",
                            "IfExp"
                        ]
                    ]
                }
            },
            "shape_78": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[:, ::stride, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(inputs, tf.stack([shape[0], tf.shape(inputs)[1], shape[2]]))",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(inputs_, axis=0) / len(inputs_)",
                            "BinOp"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat(inputs, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_121": {
                "dims": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(([1], tf.TensorShape(s).as_list()), 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_52": {
                "input": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(prev_layer, layer_size, use_bias=not batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(prev_layer, training=training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(prev_layer)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(prev_layer, keep_prob=inter_layer_keep_prob, noise_shape=noise_shape)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "translate/seq2seq_model.py": {
        "tensorflow": {
            "group_53": {
                "variable": {
                    "value": "self.dropout_on",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*dropout_on",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_54": {
                "variable": {
                    "value": "self.dropout_off",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*dropout_off",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "constant_56": {
                "variable": {
                    "value": "self.feed_previous",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "feed_previous",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_57": {
                "variable": {
                    "value": "self.feed_argmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_58": {
                "variable": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_76": {
                "variable": {
                    "value": "self.rewards",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "rewards",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_114": {
                "variable": {
                    "value": "self.beam_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.argmax(self.outputs[0], axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_115": {
                "variable": {
                    "value": "self.beam_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(self.beam_outputs)[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_116": {
                "variable": {
                    "value": "self.beam_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientDescentOptimizer_131": {
                "variable": {
                    "value": "sgd_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "gradients_155": {
                "variable": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "xs": {
                    "value": "params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[var for var in tf.trainable_variables() if var.name not in frozen_parameters]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "get_default_session_185": {
                "variable": {
                    "value": "(samples, outputs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_185": {
                "variable": {
                    "value": "(samples, outputs)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "main": {
                    "value": "[self.samples, self.outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "argv": {
                    "value": "input_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{self.targets: targets, self.feed_argmax: False, self.feed_previous: 1.0, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.targets: targets, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.beam_size: beam_size}",
                            "Dict"
                        ]
                    ]
                }
            },
            "get_default_session_221": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_221": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "main": {
                    "value": "output_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'loss': self.reinforce_loss, 'baseline_loss': self.baseline_loss}",
                            "Dict"
                        ],
                        [
                            "{'loss': self.xent_loss}",
                            "Dict"
                        ],
                        [
                            "{'outputs': self.beam_outputs}",
                            "Dict"
                        ]
                    ]
                },
                "argv": {
                    "value": "input_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{self.targets: targets, self.feed_argmax: False, self.feed_previous: 1.0, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.targets: targets, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.beam_size: beam_size}",
                            "Dict"
                        ]
                    ]
                }
            },
            "get_default_session_244": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_244": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "main": {
                    "value": "output_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'loss': self.reinforce_loss, 'baseline_loss': self.baseline_loss}",
                            "Dict"
                        ],
                        [
                            "{'loss': self.xent_loss}",
                            "Dict"
                        ],
                        [
                            "{'outputs': self.beam_outputs}",
                            "Dict"
                        ]
                    ]
                },
                "argv": {
                    "value": "input_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{self.targets: targets, self.feed_argmax: False, self.feed_previous: 1.0, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.targets: targets, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.beam_size: beam_size}",
                            "Dict"
                        ]
                    ]
                }
            },
            "get_default_session_272": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_272": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "main": {
                    "value": "output_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'loss': self.reinforce_loss, 'baseline_loss': self.baseline_loss}",
                            "Dict"
                        ],
                        [
                            "{'loss': self.xent_loss}",
                            "Dict"
                        ],
                        [
                            "{'outputs': self.beam_outputs}",
                            "Dict"
                        ]
                    ]
                },
                "argv": {
                    "value": "input_feed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{self.targets: targets, self.feed_argmax: False, self.feed_previous: 1.0, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.targets: targets, self.training: True}",
                            "Dict"
                        ],
                        [
                            "{self.beam_size: beam_size}",
                            "Dict"
                        ]
                    ]
                }
            },
            "placeholder_65": {
                "variable": {
                    "value": "encoder_input",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32 if encoder.binary else tf.int32",
                            "IfExp"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None, None, encoder.embedding_size] if encoder.binary else [None, None]",
                            "IfExp"
                        ]
                    ]
                },
                "name": {
                    "value": "'encoder_{}'.format(encoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_66": {
                "variable": {
                    "value": "encoder_input_length",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "'encoder_input_length_{}'.format(encoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdadeltaOptimizer_135": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                },
                "rho": {
                    "value": "0.95",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_161": {
                "variable": {
                    "value": "(gradients, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(loss, params)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "max_gradient_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_collection_165": {
                "variable": {
                    "value": "update_ops_",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_114": {
                "input": {
                    "value": "self.outputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_137": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Variable_48": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1 - value",
                    "type": "BinOp",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name + '_keep_prob'",
                            "BinOp"
                        ]
                    ]
                }
            },
            "placeholder_73": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "'target_{}'.format(decoder.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_152": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_166": {
                "name_or_scope": {
                    "value": "'gradients' if self.name is None else 'gradients_{}'.format(self.name)",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "control_dependencies_167": {
                "control_inputs": {
                    "value": "update_ops_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_115": {
                "input": {
                    "value": "self.beam_outputs",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "translate/summary_logger.py": {
        "tensorflow": {
            "FileWriter_15": {
                "variable": {
                    "value": "self.writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "log_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Summary_27": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[tf.Summary.Value(tag=tag, simple_value=value)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "HistogramProto_40": {
                "variable": {
                    "value": "hist",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_59": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[tf.Summary.Value(tag=tag, histo=hist)]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "translate/translation_model.py": {
        "tensorflow": {
            "Variable_63": {
                "variable": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_681": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "max_to_keep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "keep_every_n_hours",
                    "type": "variable",
                    "possible_values": [
                        [
                            "float('inf')",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "sharded": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_808": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.dirname(filename)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_816": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Variable_67": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_68": {
                "variable": {
                    "value": "self.baseline_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "baseline_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_852": {
                "var_list": {
                    "value": "variables",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{old_name[:-2]: vars_[new_name] for (old_name, new_name) in name_mapping.items() if new_name in vars_ and (not any((prefix in new_name for prefix in blacklist))) and (whitelist is None or new_name in whitelist)}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "device_66": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_default_session_676": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_684": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_session_771": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_704": {
                "variable": {
                    "value": "embedding_var",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'embedding_' + encoder_or_decoder.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_719": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_779": {
                "variable": {
                    "value": "embedding_var",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'embedding_' + encoder_or_decoder.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "global_variables_865": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_92": {
                "name_or_scope": {
                    "value": "'model_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_703": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_scope_719": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_778": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_scope_703": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_778": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_720": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_722": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}