{
    "lib/data.py": {
        "tensorflow": {
            "FIFOQueue_44": {
                "variable": {
                    "value": "self.queue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "self.dtypes",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "capacity",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "get_default_session_17": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_43": {
                "name": {
                    "value": "uploader",
                    "type": "str",
                    "possible_values": []
                }
            },
            "OutOfRangeError_68": {
                "node_def": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "op": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "message": {
                    "value": "Queue is empty",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_46": {
                "dtype": {
                    "value": "dt",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "lib/layers/attn.py": {
        "tensorflow": {
            "softmax_106": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(q, tf.transpose(k, perm=[0, 1, 3, 2])) + attn_bias",
                            "BinOp"
                        ]
                    ]
                }
            },
            "matmul_113": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "dropout(weights, 1.0 - self.attn_dropout)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self._split_heads(v)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_161": {
                "variable": {
                    "value": "ret",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(weights, v)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(x)[:-1], [self.num_heads, tf.shape(x)[-1] // self.num_heads]], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_171": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(weights, v)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_175": {
                "variable": {
                    "value": "ret",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(weights, v)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(x)[:-2], [tf.shape(x)[-2] * tf.shape(x)[-1]]], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collection_108": {
                "name": {
                    "value": "AttnWeights",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ],
                        [
                            "dropout(weights, 1.0 - self.attn_dropout)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_109": {
                "name": {
                    "value": "lib.meta.ATTENTIONS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "lib.meta.Attention(self.scope, weights, logits, attn_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_163": {
                "a": {
                    "value": "ret",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self.num_heads, tf.shape(x)[-1] // self.num_heads]], 0))",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, tf.concat([tf.shape(x)[:-2], [tf.shape(x)[-2] * tf.shape(x)[-1]]], 0))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_32": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "matmul_103": {
                "a": {
                    "value": "q",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self._split_heads(q)",
                            "Call"
                        ],
                        [
                            "q / math.sqrt(key_depth_per_head)",
                            "BinOp"
                        ],
                        [
                            "self.query_conv(query_inp)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(k, perm=[0, 1, 3, 2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_133": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_133": {
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_139": {
                "variable": {
                    "value": "(k, v)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "kv",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.kv_conv(kv_inp)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[self.key_depth, self.value_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_143": {
                "variable": {
                    "value": "(q, k, v)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "combined",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.combined_conv(query_inp)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[self.key_depth, self.key_depth, self.value_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_161": {
                "values": {
                    "value": "[tf.shape(x)[:-1], [self.num_heads, tf.shape(x)[-1] // self.num_heads]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_175": {
                "values": {
                    "value": "[tf.shape(x)[:-2], [tf.shape(x)[-2] * tf.shape(x)[-1]]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_105": {
                "a": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self._split_heads(k)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_89": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_40": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_161": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(weights, v)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_175": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(weights, v)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_55": {
                "values": {
                    "value": "[self.query_conv.W, self.kv_conv.W]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_56": {
                "values": {
                    "value": "[self.query_conv.b, self.kv_conv.b]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_65": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/layers/basic.py": {
        "tensorflow": {
            "reduce_mean_118": {
                "variable": {
                    "value": "mean",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "out",
                            "Name"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_119": {
                "variable": {
                    "value": "variance",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(inp - mean)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_initializer_215": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_265": {
                "variable": {
                    "value": "onehot_labels",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.activ(dot(inp, self.W) + self.b)",
                            "Call"
                        ],
                        [
                            "self.preprocess(inp)",
                            "Call"
                        ],
                        [
                            "self.wrapped_layer(out, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.postprocess(out, inp)",
                            "Call"
                        ],
                        [
                            "lib.ops.dropout(out, 1.0 - self.dropout, seed=self.dropout_seed)",
                            "Call"
                        ],
                        [
                            "out + inp",
                            "BinOp"
                        ],
                        [
                            "self.norm_layer(out)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "voc_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(logits)[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "on_value": {
                    "value": "smooth_positives",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1.0 - self.label_smoothing",
                            "BinOp"
                        ]
                    ]
                },
                "off_value": {
                    "value": "smooth_negatives",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.label_smoothing / tf.to_float(voc_size - 1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_267": {
                "variable": {
                    "value": "losses",
                    "type": "Variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "onehot_labels",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(out, depth=voc_size, on_value=smooth_positives, off_value=smooth_negatives)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.rdo_to_logits(rdo, out, out_len)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "xentropy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_278": {
                "variable": {
                    "value": "losses",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.rdo_to_logits(rdo, out, out_len)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.activ(dot(inp, self.W) + self.b)",
                            "Call"
                        ],
                        [
                            "self.preprocess(inp)",
                            "Call"
                        ],
                        [
                            "self.wrapped_layer(out, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.postprocess(out, inp)",
                            "Call"
                        ],
                        [
                            "lib.ops.dropout(out, 1.0 - self.dropout, seed=self.dropout_seed)",
                            "Call"
                        ],
                        [
                            "out + inp",
                            "BinOp"
                        ],
                        [
                            "self.norm_layer(out)",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_280": {
                "lengths": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(out)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "logits.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_39": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_56": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_98": {
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_112": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_117": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_178": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_232": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_283": {
                "input_tensor": {
                    "value": "losses",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=onehot_labels, logits=logits, name='xentropy')",
                            "Call"
                        ],
                        [
                            "losses * tf.sequence_mask(out_len, maxlen=tf.shape(out)[1], dtype=logits.dtype)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=out)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_307": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_326": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_89": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "device_98": {
                "device_name": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_99": {
                "params": {
                    "value": "self.mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "out",
                            "Name"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "square_119": {
                "x": {
                    "value": "inp - mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rsqrt_120": {
                "x": {
                    "value": "variance + self.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_156": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_262": {
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.rdo_to_logits(rdo, out, out_len)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_264": {
                "x": {
                    "value": "voc_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_89": {
                "device_name": {
                    "value": "device",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "''",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_initializer_113": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_280": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.activ(dot(inp, self.W) + self.b)",
                            "Call"
                        ],
                        [
                            "self.preprocess(inp)",
                            "Call"
                        ],
                        [
                            "self.wrapped_layer(out, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.postprocess(out, inp)",
                            "Call"
                        ],
                        [
                            "lib.ops.dropout(out, 1.0 - self.dropout, seed=self.dropout_seed)",
                            "Call"
                        ],
                        [
                            "out + inp",
                            "BinOp"
                        ],
                        [
                            "self.norm_layer(out)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_initializer_312": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_318": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_274": {
                "x": {
                    "value": "smooth_positives",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1.0 - self.label_smoothing",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_275": {
                "x": {
                    "value": "smooth_negatives + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_275": {
                "x": {
                    "value": "voc_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/meta.py": {
        "tensorflow": {
            "get_collection_ref_43": {
                "variable": {
                    "value": "new_coll_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "coll",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "get_collection_40": {
                "key": {
                    "value": "coll",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "get_collection_35": {
                "key": {
                    "value": "coll",
                    "type": "Variable",
                    "possible_values": []
                },
                "scope": {
                    "value": "full_scope + '/.*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/ops/basic.py": {
        "tensorflow": {
            "slice_46": {
                "variable": {
                    "value": "etc_x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "tf.shape(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[x_ndim - 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_47": {
                "variable": {
                    "value": "etc_y",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "tf.shape(y)",
                    "type": "Call",
                    "possible_values": []
                },
                "begin": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_57": {
                "variable": {
                    "value": "ret",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, a])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(y, [a, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_73": {
                "variable": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(lengths, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.cast(tf.equal(count_eos, 0), 'int32'), axis=axis)",
                            "Call"
                        ],
                        [
                            "infer_length(seq, eos=eos, time_major=time_major)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_87": {
                "variable": {
                    "value": "is_eos",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(seq, eos)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cumsum_88": {
                "variable": {
                    "value": "count_eos",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "is_eos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.equal(seq, eos), 'int32')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0 if time_major else 1",
                            "IfExp"
                        ]
                    ]
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_89": {
                "variable": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(count_eos, 0), 'int32')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0 if time_major else 1",
                            "IfExp"
                        ]
                    ]
                }
            },
            "meshgrid_132": {
                "variable": {
                    "value": "(time_i, batch_i)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(0, seq_len, dtype=indices.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(0, batch_size, dtype=indices.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_135": {
                "variable": {
                    "value": "indices_nd",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_i, time_i, indices]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_52": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, a])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, a]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_54": {
                "variable": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(y, [a, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[a, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_61": {
                "variable": {
                    "value": "ret",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ret",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.matmul(x, y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, tf.concat([etc_x, etc_y], 0))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([etc_x, etc_y], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_75": {
                "variable": {
                    "value": "maxlen",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "maxlen",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(maxlen, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.shape(seq)[0 if time_major else 1]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_76": {
                "a": {
                    "value": "tf.sequence_mask(lengths, dtype=dtype, maxlen=maxlen)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_110": {
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, a])",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "Variable",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "*args",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "gather_nd_137": {
                "params": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices_nd",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack([batch_i, time_i, indices], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_145": {
                "input_tensor": {
                    "value": "tf.nn.softmax(p_logits) * (tf.nn.log_softmax(p_logits) - tf.nn.log_softmax(q_logits))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "get_variable_scope_16": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "glorot_uniform_20": {
                "seed": {
                    "value": "seed",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.bool",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_46": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [-1, a])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_47": {
                "input": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(y, [a, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_48": {
                "input": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(y, [a, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_76": {
                "lengths": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(lengths, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.cast(tf.equal(count_eos, 0), 'int32'), axis=axis)",
                            "Call"
                        ],
                        [
                            "infer_length(seq, eos=eos, time_major=time_major)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.bool",
                            "MethodArgument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "maxlen",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(maxlen, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.shape(seq)[0 if time_major else 1]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "equal_87": {
                "x": {
                    "value": "seq",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "eos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cast_89": {
                "x": {
                    "value": "tf.equal(count_eos, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_102": {
                "input": {
                    "value": "seq",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "control_dependencies_118": {
                "control_inputs": {
                    "value": "ops",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "constant_119": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "range_132": {
                "dtype": {
                    "value": "indices.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_133": {
                "dtype": {
                    "value": "indices.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_61": {
                "values": {
                    "value": "[etc_x, etc_y]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_89": {
                "x": {
                    "value": "count_eos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cumsum(is_eos, axis=axis, exclusive=True)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_130": {
                "input": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "softmax_145": {
                "logits": {
                    "value": "p_logits",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "get_variable_scope_11": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_softmax_145": {
                "logits": {
                    "value": "q_logits",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "lib/ops/devices.py": {
        "tensorflow": {
            "get_default_session_6": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/ops/mpi/__init__.py": {
        "tensorflow": {
            "ConfigProto_193": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/ops/mpi/dummy_provider.py": {
        "tensorflow": {
            "constant_11": {
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_15": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_19": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "no_op_23": {
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "no_op_27": {
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stop_gradient_31": {
                "input": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stop_gradient_35": {
                "input": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stop_gradient_39": {
                "input": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "lib/ops/mpi/horovod_provider.py": {
        "tensorflow": {
            "get_default_session_100": {
                "variable": {
                    "value": "(sizes, encoded_res)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_100": {
                "variable": {
                    "value": "(sizes, encoded_res)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "main": {
                    "value": "[graph_ops.allgather_obj_size_result, graph_ops.allgather_obj_result]",
                    "type": "List",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "{graph_ops.allgather_obj_size_inp: [encoded_size], graph_ops.allgather_obj_inp: encoded}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "get_collection_145": {
                "variable": {
                    "value": "found",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "_graph_ops_collection",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'HOROVOD_GRAPH_OPS'",
                            "Constant"
                        ]
                    ]
                },
                "scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'broadcast_obj'",
                            "Constant"
                        ],
                        [
                            "'gather_obj'",
                            "Constant"
                        ],
                        [
                            "'scatter_obj'",
                            "Constant"
                        ],
                        [
                            "'allgather_obj'",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_16": {
                "value": {
                    "value": "int(os.getenv('OMPI_COMM_WORLD_SIZE', 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'broadcast_obj'",
                            "Constant"
                        ],
                        [
                            "'gather_obj'",
                            "Constant"
                        ],
                        [
                            "'scatter_obj'",
                            "Constant"
                        ],
                        [
                            "'allgather_obj'",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_20": {
                "value": {
                    "value": "int(os.getenv('OMPI_COMM_WORLD_RANK', 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'broadcast_obj'",
                            "Constant"
                        ],
                        [
                            "'gather_obj'",
                            "Constant"
                        ],
                        [
                            "'scatter_obj'",
                            "Constant"
                        ],
                        [
                            "'allgather_obj'",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_24": {
                "value": {
                    "value": "int(os.getenv('OMPI_COMM_WORLD_LOCAL_RANK', 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'broadcast_obj'",
                            "Constant"
                        ],
                        [
                            "'gather_obj'",
                            "Constant"
                        ],
                        [
                            "'scatter_obj'",
                            "Constant"
                        ],
                        [
                            "'allgather_obj'",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_op_29": {
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'broadcast_obj'",
                            "Constant"
                        ],
                        [
                            "'gather_obj'",
                            "Constant"
                        ],
                        [
                            "'scatter_obj'",
                            "Constant"
                        ],
                        [
                            "'allgather_obj'",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "no_op_33": {
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'broadcast_obj'",
                            "Constant"
                        ],
                        [
                            "'gather_obj'",
                            "Constant"
                        ],
                        [
                            "'scatter_obj'",
                            "Constant"
                        ],
                        [
                            "'allgather_obj'",
                            "Constant"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "assign_51": {
                "ref": {
                    "value": "ref",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "broadcast(ref)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_120": {
                "variable": {
                    "value": "self.allgather_obj_size_inp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "allgather_obj_size",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_121": {
                "variable": {
                    "value": "self.allgather_obj_inp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "allgather_obj",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_151": {
                "name": {
                    "value": "_graph_ops_collection",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "'HOROVOD_GRAPH_OPS'",
                            "Constant"
                        ]
                    ]
                },
                "value": {
                    "value": "ops",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "_GraphOps(name)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_119": {
                "name": {
                    "value": "'horovod_python_ops/' + name",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/ops/record_activations.py": {
        "tensorflow": {
            "get_variable_scope_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_82": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/ops/sliced_argmax.py": {
        "tensorflow": {
            "bincount_14": {
                "variable": {
                    "value": "is_next_sent_at_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "arr": {
                    "value": "slices",
                    "type": "Variable",
                    "possible_values": []
                },
                "minlength": {
                    "value": "n_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlength": {
                    "value": "n_hypos",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_55": {
                "variable": {
                    "value": "slices_incl",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[slices, [n_hypos]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_62": {
                "variable": {
                    "value": "flat_row_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(slice_indices[:, None], [1, voc_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_64": {
                "variable": {
                    "value": "flat_index_2d",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[flat_row_index, flat_col_index]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_65": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(flat_shape[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "(offsets * voc_size)[:, None]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "where_66": {
                "variable": {
                    "value": "flat_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(flat_shape[1]), (offsets * voc_size)[:, None])",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.scatter_nd(flat_index_2d, tf.reshape(logits, [-1]), flat_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill(flat_shape, -float('inf'))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_71": {
                "variable": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less(tf.range(flat_shape[1]), (offsets * voc_size)[:, None])",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.scatter_nd(flat_index_2d, flat_col_index, flat_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill(flat_shape, -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "top_k_77": {
                "variable": {
                    "value": "sliced_top_k",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flat_logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(mask, tf.scatter_nd(flat_index_2d, tf.reshape(logits, [-1]), flat_shape), tf.fill(flat_shape, -float('inf')))",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_nd_80": {
                "variable": {
                    "value": "original_indices_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(mask, tf.scatter_nd(flat_index_2d, flat_col_index, flat_shape), tf.fill(flat_shape, -1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([tf.range(n_slices * k) // k, tf.reshape(sliced_top_k.indices, [-1])], axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_83": {
                "variable": {
                    "value": "original_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "original_indices_flat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(flat_indices, tf.stack([tf.range(n_slices * k) // k, tf.reshape(sliced_top_k.indices, [-1])], axis=1))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(original_values)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "top_k_138": {
                "variable": {
                    "value": "logits_topk",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "k": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "where_141": {
                "variable": {
                    "value": "best_hypo_ix",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.not_equal(best_indices_in_top, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "best_indices_in_top // k + slices[:, None]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "best_indices_in_top",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "where_145": {
                "variable": {
                    "value": "best_token_ix_in_top",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.not_equal(best_indices_in_top, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "best_indices_in_top % k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "best_indices_in_top",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_nd_149": {
                "variable": {
                    "value": "best_token_indices_original",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "logits_topk.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.maximum(0, tf.reshape(tf.stack([best_hypo_ix, best_token_ix_in_top], axis=-1), [-1, 2]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_153": {
                "variable": {
                    "value": "best_token_indices_original",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.not_equal(tf.reshape(best_hypo_ix, [-1]), -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "best_token_indices_original",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(logits_topk.indices, tf.maximum(0, tf.reshape(tf.stack([best_hypo_ix, best_token_ix_in_top], axis=-1), [-1, 2])))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.not_equal(tf.reshape(best_hypo_ix, [-1]), -1), best_token_indices_original, tf.fill(tf.shape(best_token_indices_original), -1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(best_token_indices_original, tf.shape(best_token_ix_in_top))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.fill(tf.shape(best_token_indices_original), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_157": {
                "variable": {
                    "value": "best_token_indices_original",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "best_token_indices_original",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(logits_topk.indices, tf.maximum(0, tf.reshape(tf.stack([best_hypo_ix, best_token_ix_in_top], axis=-1), [-1, 2])))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.not_equal(tf.reshape(best_hypo_ix, [-1]), -1), best_token_indices_original, tf.fill(tf.shape(best_token_indices_original), -1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(best_token_indices_original, tf.shape(best_token_ix_in_top))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(best_token_ix_in_top)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_159": {
                "variable": {
                    "value": "best_hypo_ix_within_slice",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.not_equal(best_indices_in_top, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "best_indices_in_top // k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros_like(best_indices_in_top, dtype=best_indices_in_top.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cumsum_15": {
                "x": {
                    "value": "is_next_sent_at_t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.bincount(slices, minlength=n_hypos, maxlength=n_hypos)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_62": {
                "input": {
                    "value": "slice_indices[:, None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, voc_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_63": {
                "params": {
                    "value": "slices_incl * voc_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_row_index",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.tile(slice_indices[:, None], [1, voc_size]), [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "scatter_nd_67": {
                "indices": {
                    "value": "flat_index_2d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack([flat_row_index, flat_col_index], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.reshape(logits, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "flat_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[n_slices, tf.reduce_max(offsets) * voc_size]",
                            "List"
                        ]
                    ]
                }
            },
            "fill_68": {
                "dims": {
                    "value": "flat_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[n_slices, tf.reduce_max(offsets) * voc_size]",
                            "List"
                        ]
                    ]
                },
                "value": {
                    "value": "-float('inf')",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "scatter_nd_72": {
                "indices": {
                    "value": "flat_index_2d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.stack([flat_row_index, flat_col_index], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "flat_col_index",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.range(n_hypos * voc_size) - tf.gather(slices_incl * voc_size, flat_row_index)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "flat_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[n_slices, tf.reduce_max(offsets) * voc_size]",
                            "List"
                        ]
                    ]
                }
            },
            "fill_73": {
                "dims": {
                    "value": "flat_shape",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[n_slices, tf.reduce_max(offsets) * voc_size]",
                            "List"
                        ]
                    ]
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_81": {
                "values": {
                    "value": "[tf.range(n_slices * k) // k, tf.reshape(sliced_top_k.indices, [-1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_83": {
                "input": {
                    "value": "original_values",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "sliced_top_k.values",
                            "Attribute"
                        ]
                    ]
                }
            },
            "shape_54": {
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_61": {
                "input_tensor": {
                    "value": "offsets",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "slices_incl[1:] - slices_incl[:-1]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_67": {
                "tensor": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "not_equal_141": {
                "x": {
                    "value": "best_indices_in_top",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "not_equal_145": {
                "x": {
                    "value": "best_indices_in_top",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_151": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reshape(tf.stack([best_hypo_ix, best_token_ix_in_top], axis=-1), [-1, 2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "not_equal_153": {
                "x": {
                    "value": "tf.reshape(best_hypo_ix, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "fill_155": {
                "dims": {
                    "value": "tf.shape(best_token_indices_original)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_158": {
                "input": {
                    "value": "best_token_ix_in_top",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(tf.not_equal(best_indices_in_top, -1), best_indices_in_top % k, best_indices_in_top)",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_160": {
                "x": {
                    "value": "best_indices_in_top",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_162": {
                "input": {
                    "value": "best_indices_in_top",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "best_indices_in_top.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_82": {
                "tensor": {
                    "value": "sliced_top_k.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_151": {
                "tensor": {
                    "value": "tf.stack([best_hypo_ix, best_token_ix_in_top], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_153": {
                "tensor": {
                    "value": "best_hypo_ix",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(tf.not_equal(best_indices_in_top, -1), best_indices_in_top // k + slices[:, None], best_indices_in_top)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_155": {
                "input": {
                    "value": "best_token_indices_original",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(logits_topk.indices, tf.maximum(0, tf.reshape(tf.stack([best_hypo_ix, best_token_ix_in_top], axis=-1), [-1, 2])))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.not_equal(tf.reshape(best_hypo_ix, [-1]), -1), best_token_indices_original, tf.fill(tf.shape(best_token_indices_original), -1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(best_token_indices_original, tf.shape(best_token_ix_in_top))",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_151": {
                "values": {
                    "value": "[best_hypo_ix, best_token_ix_in_top]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_165": {
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "lib/session.py": {
        "tensorflow": {
            "RunOptions_92": {
                "variable": {
                    "value": "self.run_options",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trace_level": {
                    "value": "tf.RunOptions.FULL_TRACE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "RunMetadata_93": {
                "variable": {
                    "value": "self.run_metadata",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "write_op_log_102": {
                "graph": {
                    "value": "tf.get_default_graph()",
                    "type": "Call",
                    "possible_values": []
                },
                "log_dir": {
                    "value": "log_dir",
                    "type": "Variable",
                    "possible_values": []
                },
                "op_log": {
                    "value": "self.op_log",
                    "type": "Attribute",
                    "possible_values": []
                },
                "run_meta": {
                    "value": "self.run_metadata",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "profile_118": {
                "graph": {
                    "value": "tf.get_default_graph()",
                    "type": "Call",
                    "possible_values": []
                },
                "run_meta": {
                    "value": "self.run_metadata",
                    "type": "Attribute",
                    "possible_values": []
                },
                "op_log": {
                    "value": "self.op_log",
                    "type": "Attribute",
                    "possible_values": []
                },
                "options": {
                    "value": "time_stat_options",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "model_analyzer.PRINT_ALL_TIMING_MEMORY",
                            "Attribute"
                        ]
                    ]
                }
            },
            "get_default_graph_103": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "lib/task/seq2seq/cadec/model.py": {
        "tensorflow": {
            "reshape_169": {
                "variable": {
                    "value": "ctxs",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctxs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctxs, [-1, ninp])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, ninp]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_170": {
                "variable": {
                    "value": "ctx_sent_lens",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctx_sent_lens",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctx_sent_lens, [-1])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_193": {
                "variable": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(sents, [batch, nsents, ninp, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([sents, sent_diff_embs_enc], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sents, [batch, -1, tf.shape(sents)[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, nsents, ninp, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_196": {
                "variable": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "ctx_sent_diff",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.max_ctx_sents + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_197": {
                "variable": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(ctx_sent_diff, depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.zeros_like(batch['ctx_sent_diff'][:, 0]), depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_198": {
                "variable": {
                    "value": "sent_diff_embs_enc",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(ctx_sent_diff, depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.zeros_like(batch['ctx_sent_diff'][:, 0]), depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, tf.shape(sents)[2], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_201": {
                "variable": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sents, sent_diff_embs_enc]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_203": {
                "variable": {
                    "value": "ctx_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctx_attn_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctx_attn_mask, [batch, nsents, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(ctx_attn_mask, [0, 2, 3, 1, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(ctx_attn_mask, [batch, 1, 1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, nsents, 1, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_204": {
                "variable": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(sents, [batch, nsents, ninp, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([sents, sent_diff_embs_enc], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sents, [batch, -1, tf.shape(sents)[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, -1, tf.shape(sents)[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_206": {
                "variable": {
                    "value": "ctx_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "ctx_attn_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctx_attn_mask, [batch, nsents, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(ctx_attn_mask, [0, 2, 3, 1, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(ctx_attn_mask, [batch, 1, 1, -1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_207": {
                "variable": {
                    "value": "ctx_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctx_attn_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctx_attn_mask, [batch, nsents, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(ctx_attn_mask, [0, 2, 3, 1, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(ctx_attn_mask, [batch, 1, 1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, 1, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_180": {
                "variable": {
                    "value": "ctxs_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctxs_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctxs_out, [-1, nout])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, nout]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_181": {
                "variable": {
                    "value": "ctxs_out_to_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctxs_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctxs_out, [-1, nout])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_182": {
                "variable": {
                    "value": "ctxs_out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ctxs_out_len",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctxs_out_len, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_212": {
                "variable": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer.decode(ctxs_out, ctxs_out_len, None, sents, ctx_attn_mask, is_train=is_train)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, nsents, nout, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([dec_out, sent_diff_embs_dec], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, -1, tf.shape(dec_out)[3]])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.decoder2.decode(out, out_len, enc_out, enc_attn_mask, dec1_out, dec1_attn_mask, dec1_rdo, is_train=is_train, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, nsents, nout, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_214": {
                "variable": {
                    "value": "sent_diff_embs_dec",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(ctx_sent_diff, depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.zeros_like(batch['ctx_sent_diff'][:, 0]), depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, tf.shape(dec_out)[2], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_217": {
                "variable": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dec_out, sent_diff_embs_dec]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_220": {
                "variable": {
                    "value": "dec_out_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dec_out_attn_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer._make_enc_attn_mask(ctxs_out, ctxs_out_len)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out_attn_mask, [batch, nsents, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(dec_out_attn_mask, [0, 2, 3, 1, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out_attn_mask, [batch, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, nsents, 1, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_221": {
                "variable": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer.decode(ctxs_out, ctxs_out_len, None, sents, ctx_attn_mask, is_train=is_train)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, nsents, nout, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([dec_out, sent_diff_embs_dec], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, -1, tf.shape(dec_out)[3]])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.decoder2.decode(out, out_len, enc_out, enc_attn_mask, dec1_out, dec1_attn_mask, dec1_rdo, is_train=is_train, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, -1, tf.shape(dec_out)[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_224": {
                "variable": {
                    "value": "dec_out_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "dec_out_attn_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer._make_enc_attn_mask(ctxs_out, ctxs_out_len)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out_attn_mask, [batch, nsents, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(dec_out_attn_mask, [0, 2, 3, 1, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out_attn_mask, [batch, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_225": {
                "variable": {
                    "value": "dec_out_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "dec_out_attn_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer._make_enc_attn_mask(ctxs_out, ctxs_out_len)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out_attn_mask, [batch, nsents, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(dec_out_attn_mask, [0, 2, 3, 1, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out_attn_mask, [batch, 1, 1, -1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, 1, 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_296": {
                "variable": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.zeros_like(batch['ctx_sent_diff'][:, 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.max_ctx_sents + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_298": {
                "variable": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(ctx_sent_diff, depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.zeros_like(batch['ctx_sent_diff'][:, 0]), depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_321": {
                "variable": {
                    "value": "sent_diff_embs_enc",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(ctx_sent_diff, depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.zeros_like(batch['ctx_sent_diff'][:, 0]), depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, tf.shape(inp)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_322": {
                "variable": {
                    "value": "enc_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[enc_out, sent_diff_embs_enc]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_325": {
                "variable": {
                    "value": "enc_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ctx_enc_out, enc_out]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_327": {
                "variable": {
                    "value": "enc_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ctx_enc_attn_mask, enc_attn_mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_335": {
                "variable": {
                    "value": "out_seq",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inp.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_336": {
                "variable": {
                    "value": "rdo",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, hid_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "enc_out.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_353": {
                "variable": {
                    "value": "out_seq",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[prev_out_seq, tf.expand_dims(words, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_361": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out_seq",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, 0], dtype=inp.dtype)",
                            "Call"
                        ],
                        [
                            "tf.concat([prev_out_seq, tf.expand_dims(words, 1)], 1)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, 0), (0, 1)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "fill_362": {
                "variable": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "(tf.shape(out)[0],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.shape(out_seq)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_33": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_37": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "transpose_46": {
                "variable": {
                    "value": "projection_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "self.model1.transformer.emb_out.mat",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_164": {
                "input": {
                    "value": "ctxs_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctxs_out, [-1, nout])",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_270": {
                "name": {
                    "value": "self.model1.transformer.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_equal_279": {
                "variable": {
                    "value": "cond",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random_uniform([])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "denoising",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_281": {
                "variable": {
                    "value": "dec1_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "cond",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.random_uniform([]), denoising)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : dec1_denoising",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : dec1_out_sampled",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "tile_301": {
                "variable": {
                    "value": "sent_diff_embs_dec1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sent_diff_embs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.one_hot(ctx_sent_diff, depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.zeros_like(batch['ctx_sent_diff'][:, 0]), depth=self.max_ctx_sents + 1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(sent_diff_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, tf.shape(dec1_out)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_304": {
                "variable": {
                    "value": "dec1_rdo",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dec1_rdo, sent_diff_embs_dec1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_312": {
                "variable": {
                    "value": "dec1_rdo",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ctx_dec_out, dec1_rdo]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_314": {
                "variable": {
                    "value": "dec1_attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ctx_dec_out_attn_mask, dec1_attn_mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_317": {
                "variable": {
                    "value": "dec1_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ctxs_out_to_out, dec1_out]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_349": {
                "name": {
                    "value": "self.decoder2.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_371": {
                "input_tensor": {
                    "value": "attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ones([batch_size, ninp]) / tf.to_float(inp_len)[:, None]",
                            "BinOp"
                        ],
                        [
                            "enc_attn_mask[:, 0, 0, :]",
                            "Subscript"
                        ],
                        [
                            "attnP / tf.reduce_sum(attnP, axis=1, keep_dims=True)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "to_int32_20": {
                "x": {
                    "value": "tf.to_float(out_len) * 1.2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_163": {
                "input": {
                    "value": "ctxs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(ctxs, [-1, ninp])",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_296": {
                "input": {
                    "value": "batch['ctx_sent_diff'][:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_332": {
                "input": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "inp + (self.out_voc.ids(src_words) + [oeos])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_333": {
                "input": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "inp + (self.out_voc.ids(src_words) + [oeos])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_334": {
                "input": {
                    "value": "enc_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([enc_out, sent_diff_embs_enc], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([ctx_enc_out, enc_out], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_338": {
                "shape": {
                    "value": "[batch_size, ninp]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_199": {
                "input": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(sents, [batch, nsents, ninp, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([sents, sent_diff_embs_enc], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sents, [batch, -1, tf.shape(sents)[3]])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_204": {
                "input": {
                    "value": "sents",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reshape(sents, [batch, nsents, ninp, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([sents, sent_diff_embs_enc], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(sents, [batch, -1, tf.shape(sents)[3]])",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_338": {
                "x": {
                    "value": "inp_len",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "batch.get('inp_len', infer_length(inp, inp_voc.eos))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_353": {
                "input": {
                    "value": "words",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_20": {
                "x": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.fill(dims=(tf.shape(out)[0],), value=tf.shape(out_seq)[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_215": {
                "input": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer.decode(ctxs_out, ctxs_out_len, None, sents, ctx_attn_mask, is_train=is_train)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, nsents, nout, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([dec_out, sent_diff_embs_dec], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, -1, tf.shape(dec_out)[3]])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.decoder2.decode(out, out_len, enc_out, enc_attn_mask, dec1_out, dec1_attn_mask, dec1_rdo, is_train=is_train, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_222": {
                "input": {
                    "value": "dec_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.model1.transformer.decode(ctxs_out, ctxs_out_len, None, sents, ctx_attn_mask, is_train=is_train)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, nsents, nout, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([dec_out, sent_diff_embs_dec], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(dec_out, [batch, -1, tf.shape(dec_out)[3]])",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "self.decoder2.decode(out, out_len, enc_out, enc_attn_mask, dec1_out, dec1_attn_mask, dec1_rdo, is_train=is_train, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_321": {
                "input": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "inp + (self.out_voc.ids(src_words) + [oeos])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_362": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "out + (self.out_voc.ids(dst_words) + [oeos])",
                            "BinOp"
                        ],
                        [
                            "tf.pad(out_seq, [(0, 0), (0, 1)])",
                            "Call"
                        ],
                        [
                            "dec_state[-2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_302": {
                "input": {
                    "value": "dec1_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cond(cond, lambda : dec1_denoising, lambda : dec1_out_sampled)",
                            "Call"
                        ],
                        [
                            "dec1_out_sampled",
                            "Name"
                        ],
                        [
                            "tf.concat([ctxs_out_to_out, dec1_out], axis=-1)",
                            "Call"
                        ],
                        [
                            "model1.symbolic_translate(batch, **inference_flags).best_out",
                            "Attribute"
                        ],
                        [
                            "word_dropout(dec1_out, dec1_out_len, dec1_word_dropout_params.get('dropout', 0), dec1_word_dropout_params.get('method', 'random_word'), out_voc)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "lib/task/seq2seq/data.py": {
        "tensorflow": {
            "placeholder_316": {
                "dtype": {
                    "value": "v.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] * len(v.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/task/seq2seq/inference.py": {
        "tensorflow": {
            "py_func_861": {
                "variable": {
                    "value": "words_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_get_words_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[step_attnP, inp_words_mask, slices]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "bincount_1044": {
                "variable": {
                    "value": "is_next_sent_at_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "arr": {
                    "value": "slices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "slices.tolist() + [step_attnP.shape[0]]",
                            "BinOp"
                        ],
                        [
                            "tf.range(0, batch_size)",
                            "Call"
                        ]
                    ]
                },
                "minlength": {
                    "value": "n_hypos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(stack.out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.out)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlength": {
                    "value": "n_hypos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(stack.out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.out)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "while_loop_257": {
                "variable": {
                    "value": "final_stack",
                    "type": "Variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "should_continue_translating",
                    "type": "Variable",
                    "possible_values": []
                },
                "body": {
                    "value": "inference_step",
                    "type": "Variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "first_stack",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.create_initial_stack(model, batch_placeholder, force_bos=force_bos, **flags)",
                            "Call"
                        ],
                        [
                            "self.create_initial_stack(model, batch_placeholder, force_bos=force_bos, **flags)",
                            "Call"
                        ]
                    ]
                },
                "shape_invariants": {
                    "value": "shape_invariants",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "nested_map(lambda v: tf.TensorShape([None for _ in v.shape]), first_stack)",
                            "Call"
                        ],
                        [
                            "nested_map(lambda v: tf.TensorShape([None for _ in v.shape]), first_stack)",
                            "Call"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "back_prop",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_default_session_292": {
                "variable": {
                    "value": "(out_ids, attnP)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_292": {
                "variable": {
                    "value": "(out_ids, attnP)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "main": {
                    "value": "[self.best_out, self.best_attnP]",
                    "type": "List",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "feed_dict",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "{placeholder: batch_data[k] for (k, placeholder) in self.batch_placeholder.items()}",
                            "DictComp"
                        ],
                        [
                            "{placeholder: batch_data[k] for (k, placeholder) in self.batch_placeholder.items()}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "zeros_317": {
                "variable": {
                    "value": "initial_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_like_318": {
                "variable": {
                    "value": "initial_finished",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_337": {
                "variable": {
                    "value": "out_seq",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[out_seq, new_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_339": {
                "variable": {
                    "value": "is_eos",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_outputs[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_or_340": {
                "variable": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_or(finished, is_eos)",
                            "Call"
                        ],
                        [
                            "tf.equal(stack.out[:, -1], model.out_voc.eos)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(finished, tf.logical_not(below_min_length))",
                            "Call"
                        ],
                        [
                            "tf.logical_or(finished, allow_unfinished_hypo)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "is_eos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(new_outputs[:, 0], model.out_voc.eos)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_344": {
                "variable": {
                    "value": "attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[attnP, model.get_attnP(new_states)[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "while_loop_431": {
                "variable": {
                    "value": "last_stack",
                    "type": "Variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "should_continue_translating",
                    "type": "Variable",
                    "possible_values": []
                },
                "body": {
                    "value": "expand_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "first_stack",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.create_initial_stack(model, batch_placeholder, force_bos=force_bos, **flags)",
                            "Call"
                        ],
                        [
                            "self.create_initial_stack(model, batch_placeholder, force_bos=force_bos, **flags)",
                            "Call"
                        ]
                    ]
                },
                "shape_invariants": {
                    "value": "shape_invariants",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "nested_map(lambda v: tf.TensorShape([None for _ in v.shape]), first_stack)",
                            "Call"
                        ],
                        [
                            "nested_map(lambda v: tf.TensorShape([None for _ in v.shape]), first_stack)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "back_prop",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_max_442": {
                "variable": {
                    "value": "max_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "actual_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "infer_length(last_stack.best_out, model.out_voc.eos)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_default_session_462": {
                "variable": {
                    "value": "(out_ids, attnP)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_462": {
                "variable": {
                    "value": "(out_ids, attnP)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "main": {
                    "value": "[self.best_out, self.best_attnP]",
                    "type": "List",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "feed_dict",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "{placeholder: batch_data[k] for (k, placeholder) in self.batch_placeholder.items()}",
                            "DictComp"
                        ],
                        [
                            "{placeholder: batch_data[k] for (k, placeholder) in self.batch_placeholder.items()}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "constant_480": {
                "variable": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_481": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fill_495": {
                "variable": {
                    "value": "empty_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dims": {
                    "value": "(batch_size, tf.shape(out)[1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "logical_not_524": {
                "variable": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_613": {
                "variable": {
                    "value": "hypo_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.reshape(hypo_indices, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "valid_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(tf.not_equal(tf.reshape(hypo_indices, [-1]), -1))[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_614": {
                "variable": {
                    "value": "words",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.reshape(words, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "valid_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(tf.not_equal(tf.reshape(hypo_indices, [-1]), -1))[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_615": {
                "variable": {
                    "value": "delta_raw_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.reshape(delta_raw_scores, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "valid_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(tf.not_equal(tf.reshape(hypo_indices, [-1]), -1))[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_623": {
                "variable": {
                    "value": "attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[stack.attnP, step_attnP[:, None, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_624": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[stack.out, words[..., None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "equal_649": {
                "variable": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack.out[:, -1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_671": {
                "variable": {
                    "value": "finished_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_or(finished, is_eos)",
                            "Call"
                        ],
                        [
                            "tf.equal(stack.out[:, -1], model.out_voc.eos)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(finished, tf.logical_not(below_min_length))",
                            "Call"
                        ],
                        [
                            "tf.logical_or(finished, allow_unfinished_hypo)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "stack.scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill(tf.shape(stack.scores), -float('inf'))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_674": {
                "variable": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "t": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "tf.shape(stack.out)[0] - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "not_equal_676": {
                "variable": {
                    "value": "stack_is_nonempty",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(stack.out)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_679": {
                "variable": {
                    "value": "new_is_better",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "best_scores",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(new_is_better, best_scores, stack.best_scores)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "stack.best_scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_680": {
                "variable": {
                    "value": "best_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "new_is_better",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater(best_scores, stack.best_scores)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "best_scores",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(new_is_better, best_scores, stack.best_scores)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "stack.best_scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_682": {
                "variable": {
                    "value": "new_best_raw_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "stack_is_nonempty",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.not_equal(tf.shape(stack.out)[0], 0)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.gather(stack.raw_scores, best_indices)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : stack.best_raw_scores",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "where_686": {
                "variable": {
                    "value": "best_raw_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "new_is_better",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater(best_scores, stack.best_scores)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "new_best_raw_scores",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cond(stack_is_nonempty, lambda : tf.gather(stack.raw_scores, best_indices), lambda : stack.best_raw_scores)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "stack.best_raw_scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fill_690": {
                "variable": {
                    "value": "eos_pad",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dims": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_691": {
                "variable": {
                    "value": "padded_best_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[stack.best_out, eos_pad]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_692": {
                "variable": {
                    "value": "new_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "stack_is_nonempty",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.not_equal(tf.shape(stack.out)[0], 0)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.gather(stack.out, best_indices)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.gather(padded_best_out, best_indices)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "where_696": {
                "variable": {
                    "value": "best_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "new_is_better",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater(best_scores, stack.best_scores)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "new_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cond(stack_is_nonempty, lambda : tf.gather(stack.out, best_indices), lambda : tf.gather(padded_best_out, best_indices))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "padded_best_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([stack.best_out, eos_pad], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_698": {
                "variable": {
                    "value": "zero_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stack.best_attnP[:, :1, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_699": {
                "variable": {
                    "value": "padded_best_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[stack.best_attnP, zero_attnP]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_700": {
                "variable": {
                    "value": "new_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "stack_is_nonempty",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.not_equal(tf.shape(stack.out)[0], 0)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.gather(stack.attnP, best_indices)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.gather(padded_best_attnP, best_indices)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "where_704": {
                "variable": {
                    "value": "best_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "new_is_better",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater(best_scores, stack.best_scores)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "new_attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cond(stack_is_nonempty, lambda : tf.gather(stack.attnP, best_indices), lambda : tf.gather(padded_best_attnP, best_indices))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "padded_best_attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([stack.best_attnP, zero_attnP], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_725": {
                "variable": {
                    "value": "is_beam_not_empty",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(stack.raw_scores)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_759": {
                "variable": {
                    "value": "sample_ids_for_slices",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "hypo_to_batch_index(n_hypos, stack.slices)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "bincount_761": {
                "variable": {
                    "value": "n_hypos_per_sample",
                    "type": "Variable",
                    "possible_values": []
                },
                "arr": {
                    "value": "sample_ids_for_slices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather(hypo_to_batch_index(n_hypos, stack.slices), flat_indices)",
                            "Call"
                        ]
                    ]
                },
                "minlength": {
                    "value": "batch_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(slices)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(inp)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(out_seq)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attnP_0)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlength": {
                    "value": "batch_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(slices)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(inp)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(out_seq)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attnP_0)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cumsum_763": {
                "variable": {
                    "value": "new_slices",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "n_hypos_per_sample",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.bincount(sample_ids_for_slices, minlength=batch_size, maxlength=batch_size)",
                            "Call"
                        ]
                    ]
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stop_gradient_863": {
                "input": {
                    "value": "words_attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.py_func(_get_words_attnP, [step_attnP, inp_words_mask, slices], tf.float32, stateful=False)",
                            "Call"
                        ],
                        [
                            "np.zeros((step_attnP.shape[0], max_words_len))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(stack.attnP, axis=1)",
                            "Call"
                        ],
                        [
                            "get_words_attnP(words_attnP, inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_905": {
                "variable": {
                    "value": "step_attnP_word",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "step_attnP_word",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "step_attnP",
                            "Name"
                        ],
                        [
                            "get_words_attnP(step_attnP_word, stack_ext.inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ],
                        [
                            "tf.pad(step_attnP_word, [[0, 0], [0, paddings]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, paddings]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_941": {
                "variable": {
                    "value": "words_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stack.attnP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_167": {
                "variable": {
                    "value": "logp",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss.rdo_to_logits__predict(*rdo)",
                            "Call"
                        ],
                        [
                            "self.loss.rdo_to_logits__predict(rdo)",
                            "Call"
                        ],
                        [
                            "logits / sampling_temperature",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_171": {
                "variable": {
                    "value": "best_words",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.multinomial(logp, k)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_174": {
                "variable": {
                    "value": "best_delta_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.reshape(logp, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "best_words_flat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "(tf.range(0, batch_size) * voc_size)[:, None] + best_words",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_273": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "out_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "infer_mask(outputs, model.out_voc.eos)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(out_mask, outputs, tf.fill(tf.shape(outputs), model.out_voc.eos))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.fill(tf.shape(outputs), model.out_voc.eos)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_307": {
                "variable": {
                    "value": "initial_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill((batch_size, 1), model.out_voc.bos)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inp.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_310": {
                "variable": {
                    "value": "initial_attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[initial_attnP, second_attnP]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_315": {
                "variable": {
                    "value": "initial_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inp.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fill_484": {
                "variable": {
                    "value": "bos",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "model.out_voc.bos",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dims": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "stack_487": {
                "variable": {
                    "value": "attnP",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[attnP_0, attnP_1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_489": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[out, bos[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_equal_533": {
                "variable": {
                    "value": "within_max_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.max_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_539": {
                "variable": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "within_max_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less_equal(stack.out_len, self.max_len)",
                            "Call"
                        ],
                        [
                            "tf.gather(within_max_length, batch_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_546": {
                "variable": {
                    "value": "best_scores_for_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "stack.best_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_547": {
                "variable": {
                    "value": "pruned_by_spread",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack.scores + self.beam_spread",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "best_scores_for_hypos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather(stack.best_scores, batch_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_548": {
                "variable": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.logical_not(pruned_by_spread)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_551": {
                "variable": {
                    "value": "best_raw_scores_for_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "stack.best_raw_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_552": {
                "variable": {
                    "value": "pruned_by_raw_spread",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack.raw_scores + self.beam_spread_raw",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "best_raw_scores_for_hypos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather(stack.best_raw_scores, batch_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_553": {
                "variable": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.logical_not(pruned_by_raw_spread)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cumsum_563": {
                "variable": {
                    "value": "survived_hypo_id",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(should_keep, 'int32')",
                    "type": "Call",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "bincount_565": {
                "variable": {
                    "value": "survived_hypos_per_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "arr": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "tf.cast(should_keep, 'int32')",
                    "type": "Call",
                    "possible_values": []
                },
                "minlength": {
                    "value": "batch_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(slices)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(inp)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(out_seq)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attnP_0)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "maxlength": {
                    "value": "batch_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.shape(slices)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(inp)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(out_seq)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(attnP_0)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(stack.best_out)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cumsum_568": {
                "variable": {
                    "value": "slices_exc_pruned",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "survived_hypos_per_input",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.bincount(batch_indices, weights=tf.cast(should_keep, 'int32'), minlength=batch_size, maxlength=batch_size)",
                            "Call"
                        ]
                    ]
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_equal_576": {
                "variable": {
                    "value": "pruned_by_beam_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "beam_index",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "survived_hypo_id - tf.gather(slices_exc_pruned, batch_indices)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "self.beam_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_577": {
                "variable": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.logical_not(pruned_by_beam_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_652": {
                "variable": {
                    "value": "below_min_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.min_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_656": {
                "variable": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_or(finished, is_eos)",
                            "Call"
                        ],
                        [
                            "tf.equal(stack.out[:, -1], model.out_voc.eos)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(finished, tf.logical_not(below_min_length))",
                            "Call"
                        ],
                        [
                            "tf.logical_or(finished, allow_unfinished_hypo)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.logical_not(below_min_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_660": {
                "variable": {
                    "value": "reached_max_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.max_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_664": {
                "variable": {
                    "value": "have_best_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.not_equal(stack.best_out, model.out_voc.eos)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_665": {
                "variable": {
                    "value": "no_finished_alternatives",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.logical_not(have_best_out)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_666": {
                "variable": {
                    "value": "allow_unfinished_hypo",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "reached_max_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(stack.out_len, self.max_len)",
                            "Call"
                        ],
                        [
                            "tf.gather(reached_max_length, batch_indices)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "no_finished_alternatives",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather(tf.logical_not(have_best_out), batch_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_668": {
                "variable": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "finished",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_or(finished, is_eos)",
                            "Call"
                        ],
                        [
                            "tf.equal(stack.out[:, -1], model.out_voc.eos)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(finished, tf.logical_not(below_min_length))",
                            "Call"
                        ],
                        [
                            "tf.logical_or(finished, allow_unfinished_hypo)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "allow_unfinished_hypo",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_and(reached_max_length, no_finished_alternatives)",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_819": {
                "variable": {
                    "value": "length_penalty",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0 + tf.to_float(stack.out_len) / 6.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "len_alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "minimum_822": {
                "variable": {
                    "value": "times_translated",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack_ext.attnP_sum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_836": {
                "variable": {
                    "value": "length_penalty",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0 + tf.to_float(stack.out_len) / 6.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "len_alpha",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_927": {
                "variable": {
                    "value": "attnP_aggregated_dst",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[stack_ext.attnP_aggregated_dst, dst_attnP_aggregated]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "py_func_948": {
                "variable": {
                    "value": "inp_words_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "func": {
                    "value": "is_new_word",
                    "type": "Variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[batch['inp_words']]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "bool",
                    "type": "Variable",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stop_gradient_950": {
                "variable": {
                    "value": "inp_words_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp_words_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.py_func(is_new_word, [batch['inp_words']], bool, stateful=False)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inp_words_mask)",
                            "Call"
                        ],
                        [
                            "tf.fill(tf.shape(batch['inp']), 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_956": {
                "variable": {
                    "value": "inp_words_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "tf.shape(batch['inp'])",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "fill_965": {
                "variable": {
                    "value": "attnP_aggregated_src",
                    "type": "Variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "tf.shape(batch['inp'])",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "fill_976": {
                "variable": {
                    "value": "attnP_aggregated_dst",
                    "type": "Variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "(tf.shape(batch['inp'])[0],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "pow_1007": {
                "variable": {
                    "value": "length_penalty",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0 + tf.to_float(stack.out_len) / 6.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.len_alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_1010": {
                "variable": {
                    "value": "coverage_penalty",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.log(tf.minimum(stack_ext.attnP_aggregated_src, 1) + sys.float_info.epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_1015": {
                "variable": {
                    "value": "coverage_penalty",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.log(tf.minimum(stack_ext.attnP_aggregated_dst, 1) + sys.float_info.epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pow_1029": {
                "variable": {
                    "value": "length_penalty",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0 + tf.to_float(stack.out_len) / 6.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.len_alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cumsum_1045": {
                "x": {
                    "value": "is_next_sent_at_t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.bincount(slices, minlength=n_hypos, maxlength=n_hypos)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_161": {
                "input": {
                    "value": "slices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "slices.tolist() + [step_attnP.shape[0]]",
                            "BinOp"
                        ],
                        [
                            "tf.range(0, batch_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_181": {
                "variable": {
                    "value": "best_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.not_equal(best_indices, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.floordiv(best_indices, voc_size) + slices[:, None]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill(tf.shape(best_indices), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_184": {
                "variable": {
                    "value": "best_words",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.not_equal(best_indices, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(best_indices, voc_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill(tf.shape(best_indices), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_300": {
                "input": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "batch_placeholder['inp']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_319": {
                "input": {
                    "value": "initial_outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.fill((batch_size, 1), model.out_voc.bos), inp.dtype)",
                            "Call"
                        ],
                        [
                            "tf.zeros((batch_size, 0), dtype=inp.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_333": {
                "input": {
                    "value": "out_seq",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([out_seq, new_outputs], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_426": {
                "input_tensor": {
                    "value": "should_continue",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_478": {
                "input": {
                    "value": "attnP_0",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "model.get_attnP(dec_state_0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_525": {
                "input_tensor": {
                    "value": "tf.equal(stack.out, model.out_voc.eos)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_527": {
                "input": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_528": {
                "input": {
                    "value": "stack.best_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_537": {
                "variable": {
                    "value": "within_max_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "within_max_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less_equal(stack.out_len, self.max_len)",
                            "Call"
                        ],
                        [
                            "tf.gather(within_max_length, batch_indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_596": {
                "condition": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_612": {
                "condition": {
                    "value": "tf.not_equal(tf.reshape(hypo_indices, [-1]), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_613": {
                "tensor": {
                    "value": "hypo_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(should_keep)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(tf.reshape(hypo_indices, [-1]), valid_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_614": {
                "tensor": {
                    "value": "words",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "out_voc.words(ids)",
                            "Call"
                        ],
                        [
                            "[w for (w, out_id) in zip(words, ids) if out_id not in [out_voc.bos, out_voc.eos]]",
                            "ListComp"
                        ],
                        [
                            "copy_argmax(inp_words, words, attns, where)",
                            "Call"
                        ],
                        [
                            "tf.gather(tf.reshape(words, [-1]), valid_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_615": {
                "tensor": {
                    "value": "delta_raw_scores",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.gather(tf.reshape(delta_raw_scores, [-1]), valid_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_645": {
                "input": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_654": {
                "variable": {
                    "value": "below_min_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "below_min_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less(stack.out_len, self.min_len)",
                            "Call"
                        ],
                        [
                            "tf.gather(below_min_length, batch_indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_662": {
                "variable": {
                    "value": "reached_max_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "reached_max_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(stack.out_len, self.max_len)",
                            "Call"
                        ],
                        [
                            "tf.gather(reached_max_length, batch_indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_671": {
                "dims": {
                    "value": "tf.shape(stack.scores)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "-float('inf')",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_689": {
                "input": {
                    "value": "stack.best_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_754": {
                "input": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_755": {
                "input": {
                    "value": "stack.best_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_903": {
                "input": {
                    "value": "stack_ext.attnP_aggregated_src",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_909": {
                "variable": {
                    "value": "attnP_aggregated_src",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stack_ext.attnP_aggregated_src",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "step_attnP_word",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "step_attnP",
                            "Name"
                        ],
                        [
                            "get_words_attnP(step_attnP_word, stack_ext.inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ],
                        [
                            "tf.pad(step_attnP_word, [[0, 0], [0, paddings]])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_970": {
                "variable": {
                    "value": "attnP_aggregated_dst",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "words_attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.py_func(_get_words_attnP, [step_attnP, inp_words_mask, slices], tf.float32, stateful=False)",
                            "Call"
                        ],
                        [
                            "np.zeros((step_attnP.shape[0], max_words_len))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(stack.attnP, axis=1)",
                            "Call"
                        ],
                        [
                            "get_words_attnP(words_attnP, inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_130": {
                "params": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "hypo_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(should_keep)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(tf.reshape(hypo_indices, [-1]), valid_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_137": {
                "condition": {
                    "value": "condition",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_160": {
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss.rdo_to_logits__predict(*rdo)",
                            "Call"
                        ],
                        [
                            "self.loss.rdo_to_logits__predict(rdo)",
                            "Call"
                        ],
                        [
                            "logits / sampling_temperature",
                            "BinOp"
                        ]
                    ]
                }
            },
            "range_169": {},
            "multinomial_171": {
                "logits": {
                    "value": "logp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(logits, 1) + base_scores[:, None]",
                            "BinOp"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reshape_174": {
                "tensor": {
                    "value": "logp",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(logits, 1) + base_scores[:, None]",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_246": {
                "dims": {
                    "value": "[None for _ in v.shape]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "reduce_any_251": {
                "input_tensor": {
                    "value": "~stack.finished",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "fill_273": {
                "dims": {
                    "value": "tf.shape(outputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fill_307": {
                "dims": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "model.out_voc.bos",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_338": {
                "x": {
                    "value": "~finished",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_345": {
                "values": {
                    "value": "[seq, new[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_421": {
                "dims": {
                    "value": "[None for _ in v.shape]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "zeros_500": {
                "shape": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_501": {
                "shape": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "fill_507": {
                "value": {
                    "value": "-float('inf')",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dims": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "fill_508": {
                "value": {
                    "value": "-float('inf')",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dims": {
                    "value": "(batch_size,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "equal_525": {
                "x": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_not_548": {
                "x": {
                    "value": "pruned_by_spread",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less(stack.scores + self.beam_spread, best_scores_for_hypos)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_not_554": {
                "x": {
                    "value": "pruned_by_raw_spread",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less(stack.raw_scores + self.beam_spread_raw, best_raw_scores_for_hypos)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_563": {
                "x": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_573": {
                "params": {
                    "value": "slices_exc_pruned",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cumsum(survived_hypos_per_input, exclusive=True)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "batch_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ],
                        [
                            "hypo_to_batch_index(n_hypos, stack.slices)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_not_577": {
                "x": {
                    "value": "pruned_by_beam_size",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(beam_index, self.beam_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_612": {
                "x": {
                    "value": "tf.reshape(hypo_indices, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "logical_not_656": {
                "x": {
                    "value": "below_min_length",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.less(stack.out_len, self.min_len)",
                            "Call"
                        ],
                        [
                            "tf.gather(below_min_length, batch_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_664": {
                "x": {
                    "value": "stack.best_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "model.out_voc.eos",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_not_665": {
                "x": {
                    "value": "have_best_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.not_equal(stack.best_out, model.out_voc.eos), 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_671": {
                "input": {
                    "value": "stack.scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_676": {
                "input": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_683": {
                "params": {
                    "value": "stack.raw_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_693": {
                "params": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_694": {
                "params": {
                    "value": "padded_best_out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([stack.best_out, eos_pad], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_701": {
                "params": {
                    "value": "stack.attnP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_702": {
                "params": {
                    "value": "padded_best_attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.concat([stack.best_attnP, zero_attnP], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_725": {
                "input": {
                    "value": "stack.raw_scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_767": {
                "params": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_768": {
                "params": {
                    "value": "stack.scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_769": {
                "params": {
                    "value": "stack.raw_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_770": {
                "params": {
                    "value": "stack.attnP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_800": {
                "input_tensor": {
                    "value": "stack.attnP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_823": {
                "input_tensor": {
                    "value": "tf.log(times_translated + sys.float_info.epsilon)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_904": {
                "input": {
                    "value": "step_attnP_word",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "step_attnP",
                            "Name"
                        ],
                        [
                            "get_words_attnP(step_attnP_word, stack_ext.inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ],
                        [
                            "tf.pad(step_attnP_word, [[0, 0], [0, paddings]])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_956": {
                "input": {
                    "value": "batch['inp']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_965": {
                "input": {
                    "value": "batch['inp']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_972": {
                "variable": {
                    "value": "attnP_aggregated_dst",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "words_attnP",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.py_func(_get_words_attnP, [step_attnP, inp_words_mask, slices], tf.float32, stateful=False)",
                            "Call"
                        ],
                        [
                            "np.zeros((step_attnP.shape[0], max_words_len))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(stack.attnP, axis=1)",
                            "Call"
                        ],
                        [
                            "get_words_attnP(words_attnP, inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_1011": {
                "x": {
                    "value": "tf.minimum(stack_ext.attnP_aggregated_src, 1) + sys.float_info.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_1016": {
                "x": {
                    "value": "tf.minimum(stack_ext.attnP_aggregated_dst, 1) + sys.float_info.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_softmax_177": {
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.loss.rdo_to_logits__predict(*rdo)",
                            "Call"
                        ],
                        [
                            "self.loss.rdo_to_logits__predict(rdo)",
                            "Call"
                        ],
                        [
                            "logits / sampling_temperature",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "not_equal_181": {
                "x": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "fill_183": {
                "dims": {
                    "value": "tf.shape(best_indices)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "not_equal_184": {
                "x": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mod_185": {
                "x1": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "voc_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "fill_186": {
                "dims": {
                    "value": "tf.shape(best_indices)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_188": {
                "params": {
                    "value": "base_scores",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.compute_base_scores(model, stack, **flags)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.maximum(0, best_hypos)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_251": {
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "max_len",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "max_len if max_len is not None else 2 * inp_len + 3",
                            "IfExp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_273": {
                "input": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(out_mask, outputs, tf.fill(tf.shape(outputs), model.out_voc.eos))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_311": {
                "values": {
                    "value": "[x, y[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_565": {
                "x": {
                    "value": "should_keep",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(tf.equal(stack.out, model.out_voc.eos), axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, within_max_length)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_raw_spread))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(should_keep, tf.logical_not(pruned_by_beam_size))",
                            "Call"
                        ],
                        [
                            "self.should_continue_translating(model, stack)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_612": {
                "tensor": {
                    "value": "hypo_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.where(should_keep)[:, 0]",
                            "Subscript"
                        ],
                        [
                            "tf.gather(tf.reshape(hypo_indices, [-1]), valid_indices)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_674": {
                "input": {
                    "value": "stack.out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_824": {
                "x": {
                    "value": "times_translated + sys.float_info.epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_max_921": {
                "input_tensor": {
                    "value": "step_attnP_word",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "step_attnP",
                            "Name"
                        ],
                        [
                            "get_words_attnP(step_attnP_word, stack_ext.inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ],
                        [
                            "tf.pad(step_attnP_word, [[0, 0], [0, paddings]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "range_172": {},
            "floordiv_182": {
                "x": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "voc_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_183": {
                "input": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_186": {
                "input": {
                    "value": "best_indices",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.clip_by_value(best_indices, 0, tf.shape(stack.out)[0] - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_188": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "best_hypos",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.range(0, n_hypos)[:, None]",
                            "Subscript"
                        ],
                        [
                            "tf.where(tf.not_equal(best_indices, -1), tf.floordiv(best_indices, voc_size) + slices[:, None], tf.fill(tf.shape(best_indices), -1))",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_495": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.zeros(shape=(batch_size, 0), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.concat([out, bos[:, None]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([stack.out, words[..., None]], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_772": {
                "params": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "to_float_819": {
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_836": {
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_923": {
                "input_tensor": {
                    "value": "step_attnP_word",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "step_attnP",
                            "Name"
                        ],
                        [
                            "get_words_attnP(step_attnP_word, stack_ext.inp_words_mask, stack.slices, self.src_word_attn_aggregation)",
                            "Call"
                        ],
                        [
                            "tf.pad(step_attnP_word, [[0, 0], [0, paddings]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_976": {
                "input": {
                    "value": "batch['inp']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_1007": {
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_1011": {
                "x": {
                    "value": "stack_ext.attnP_aggregated_src",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_1016": {
                "x": {
                    "value": "stack_ext.attnP_aggregated_dst",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_1029": {
                "x": {
                    "value": "stack.out_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/task/seq2seq/summary.py": {
        "tensorflow": {
            "argmax_104": {
                "variable": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_116": {
                "variable": {
                    "value": "out_equals",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(predictions, dtype=out.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sequence_mask_117": {
                "variable": {
                    "value": "out_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(out)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_132": {
                "variable": {
                    "value": "out_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out_logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "select_values_over_last_axis(logits, tf.to_int32(out))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(out_logits, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_134": {
                "variable": {
                    "value": "greater_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "out_logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "select_values_over_last_axis(logits, tf.to_int32(out))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(out_logits, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_135": {
                "variable": {
                    "value": "greater_ranks",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_int32(greater_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sequence_mask_137": {
                "variable": {
                    "value": "out_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(out)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "not_equal_151": {
                "variable": {
                    "value": "not_correct",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(predictions, dtype=out.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sequence_mask_152": {
                "variable": {
                    "value": "out_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(out)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "argmax_7": {
                "variable": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_154": {
                "x": {
                    "value": "correct_seq",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "1.0 - tf.minimum(1.0, tf.reduce_sum(tf.cast(not_correct, dtype=dtype) * out_mask, axis=1))",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_6": {
                "name_or_scope": {
                    "value": "summary_accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_28": {
                "name_or_scope": {
                    "value": "summary_xent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_37": {
                "name_or_scope": {
                    "value": "summary_io",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_51": {
                "name": {
                    "value": "'%s_metrics/Acc' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['accuracy']) / tf.reduce_sum(node['out_len'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_52": {
                "name": {
                    "value": "'%s_metrics/AccTop5' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['accuracy_top5']) / tf.reduce_sum(node['out_len'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_53": {
                "name": {
                    "value": "'%s_metrics/AccPerSeq' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['accuracy_per_sequence']) / tf.reduce_sum(node['seqs'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_65": {
                "name": {
                    "value": "'%s_metrics/Xent' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['xent']) / tf.reduce_sum(node['out_len'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_72": {
                "name": {
                    "value": "'%s_IO/BatchSize' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['batch_size'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_73": {
                "name": {
                    "value": "'%s_IO/InpLenAvg' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['inp_len']) / tf.reduce_sum(node['batch_size'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_74": {
                "name": {
                    "value": "'%s_IO/OutLenAvg' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['out_len']) / tf.reduce_sum(node['batch_size'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_75": {
                "name": {
                    "value": "'%s_IO/InpLenSum' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['inp_len'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_76": {
                "name": {
                    "value": "'%s_IO/OutLenSum' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['out_len'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_78": {
                "name": {
                    "value": "'%s_IO/InpNoPadRate' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['inp_len']) / tf.reduce_sum(node['ninp'] * node['batch_size'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_81": {
                "name": {
                    "value": "'%s_IO/OutNoPadRate' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(node['out_len']) / tf.reduce_sum(node['nout'] * node['batch_size'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_116": {
                "x": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "out.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_118": {
                "x": {
                    "value": "out_equals",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.cast(predictions, dtype=out.dtype), out)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "to_int32_131": {
                "x": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "to_int32_135": {
                "x": {
                    "value": "greater_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater(logits, out_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_138": {
                "x": {
                    "value": "hit_mask",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "greater_ranks < k",
                            "Compare"
                        ]
                    ]
                }
            },
            "cast_151": {
                "x": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "out.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_153": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(tf.cast(not_correct, dtype=dtype) * out_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_72": {
                "input_tensor": {
                    "value": "node['batch_size']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_75": {
                "input_tensor": {
                    "value": "node['inp_len']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_76": {
                "input_tensor": {
                    "value": "node['out_len']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_153": {
                "input_tensor": {
                    "value": "tf.cast(not_correct, dtype=dtype) * out_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_13": {
                "input_tensor": {
                    "value": "acc_values",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "predictions2accuracy(predictions, out, out_len)",
                            "Call"
                        ],
                        [
                            "tf.cast(out_equals, dtype=dtype) * out_mask",
                            "BinOp"
                        ],
                        [
                            "tf.to_float(hit_mask) * out_mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_14": {
                "input_tensor": {
                    "value": "acc_top5_values",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "logits2accuracy_top_k(logits, out, out_len, k=5)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_15": {
                "input_tensor": {
                    "value": "acc_per_seq_values",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "predictions2accuracy_per_sequence(predictions, out, out_len)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_16": {
                "x": {
                    "value": "tf.reduce_sum(out_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_17": {
                "x": {
                    "value": "tf.shape(out_len)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_30": {
                "input_tensor": {
                    "value": "xent_values",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "to_float_31": {
                "x": {
                    "value": "tf.reduce_sum(out_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_40": {
                "x": {
                    "value": "tf.reduce_sum(inp_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_41": {
                "x": {
                    "value": "tf.reduce_sum(out_len)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_42": {
                "x": {
                    "value": "tf.shape(inp)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_43": {
                "x": {
                    "value": "tf.shape(out)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "node['out_len']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_52": {
                "input_tensor": {
                    "value": "node['out_len']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_53": {
                "input_tensor": {
                    "value": "node['seqs']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_65": {
                "input_tensor": {
                    "value": "node['out_len']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_73": {
                "input_tensor": {
                    "value": "node['batch_size']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "input_tensor": {
                    "value": "node['batch_size']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_80": {
                "input_tensor": {
                    "value": "node['ninp'] * node['batch_size']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_83": {
                "input_tensor": {
                    "value": "node['nout'] * node['batch_size']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_117": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_137": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_152": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_16": {
                "input_tensor": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_31": {
                "input_tensor": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "to_float_39": {
                "x": {
                    "value": "tf.shape(inp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_40": {
                "input_tensor": {
                    "value": "inp_len",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_41": {
                "input_tensor": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cast_153": {
                "x": {
                    "value": "not_correct",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.not_equal(tf.cast(predictions, dtype=out.dtype), out)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ],
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_17": {
                "input": {
                    "value": "out_len",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_39": {
                "input": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_42": {
                "input": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_43": {
                "input": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "lib/task/seq2seq/tickers.py": {
        "tensorflow": {
            "placeholder_40": {
                "variable": {
                    "value": "self.bleu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_41": {
                "variable": {
                    "value": "self.translations",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "merge_43": {
                "variable": {
                    "value": "self.summary",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar('%s/BLEU' % self.name + self.suffix, self.bleu), tf.summary.text('%s/Translations' % self.name + self.suffix, self.translations)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_default_session_97": {
                "variable": {
                    "value": "summary",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_97": {
                "variable": {
                    "value": "summary",
                    "type": "Variable",
                    "possible_values": []
                },
                "main": {
                    "value": "self.summary",
                    "type": "Attribute",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "{self.bleu: bleu_value, self.translations: translations}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "scalar_44": {
                "name": {
                    "value": "'%s/BLEU' % self.name + self.suffix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "self.bleu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "text_45": {
                "name": {
                    "value": "'%s/Translations' % self.name + self.suffix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "self.translations",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_66": {
                "device_name": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/train/__init__.py": {
        "tensorflow": {
            "get_default_session_44": {
                "variable": {
                    "value": "session",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_217": {
                "variable": {
                    "value": "self.global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_223": {
                "variable": {
                    "value": "self.batch_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "batch_no",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_232": {
                "variable": {
                    "value": "self.tick_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "tick_no",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_with_default_239": {
                "variable": {
                    "value": "self.global_step_ingraph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_with_default_240": {
                "variable": {
                    "value": "self.batch_no_ingraph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.batch_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_collection_ref_251": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_STEP",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_session_300": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_300": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "main": {
                    "value": "tf.assign(self.global_step_var, global_step)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_170": {
                "input_tensor": {
                    "value": "counters",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "name_scope_237": {
                "name": {
                    "value": "step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_242": {
                "name": {
                    "value": "tf.GraphKeys.GLOBAL_STEP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.global_step_ingraph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_with_default_245": {
                "variable": {
                    "value": "self.tick_no_ingraph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.tick_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_254": {
                "name": {
                    "value": "step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "equal_261": {
                "variable": {
                    "value": "is_it_time_yet",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(self.tick_no_var, self.tick_every_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.tick_every_steps - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_263": {
                "variable": {
                    "value": "incr_global_step",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_it_time_yet",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.mod(self.tick_no_var, self.tick_every_steps), self.tick_every_steps - 1)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.assign(self.global_step_var, self.global_step_var + 1)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.identity(self.global_step_var)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_267": {
                "variable": {
                    "value": "incr_batch_no",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_it_time_yet",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.mod(self.tick_no_var, self.tick_every_steps), self.tick_every_steps - 1)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.assign(self.batch_no_var, self.batch_no_var + 1)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.identity(self.batch_no_var)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "name_scope_299": {
                "name": {
                    "value": "step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_315": {
                "name": {
                    "value": "counters",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_318": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_321": {
                "name": {
                    "value": "aggregate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_325": {
                "name": {
                    "value": "update",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_176": {
                "name": {
                    "value": "'%s/loss' % prefix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(counters)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_214": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_STEP",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_219": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_225": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_246": {
                "name": {
                    "value": "TICK_NO",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "self.tick_no_ingraph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_272": {
                "variable": {
                    "value": "incr_tick_no",
                    "type": "Variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.tick_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.tick_no_var + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assign_301": {
                "ref": {
                    "value": "self.global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_mean_176": {
                "input_tensor": {
                    "value": "counters",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "constant_initializer_234": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_257": {
                "ref": {
                    "value": "self.global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.global_step_var + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assign_258": {
                "ref": {
                    "value": "self.batch_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.batch_no_var + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mod_261": {
                "x1": {
                    "value": "self.tick_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x2": {
                    "value": "self.tick_every_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_271": {
                "control_inputs": {
                    "value": "[incr_global_step, incr_batch_no]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_316": {
                "input": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_264": {
                "ref": {
                    "value": "self.global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.global_step_var + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_265": {
                "input": {
                    "value": "self.global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_268": {
                "ref": {
                    "value": "self.batch_no_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.batch_no_var + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_269": {
                "input": {
                    "value": "self.batch_no_var",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "lib/train/algorithms.py": {
        "tensorflow": {
            "get_variable_19": {
                "variable": {
                    "value": "self.accumulator_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "var.name[:-2] + '_grad'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "var.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "gradients_95": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "local_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "xs": {
                    "value": "self.var_list",
                    "type": "Attribute",
                    "possible_values": []
                },
                "colocate_gradients_with_ops": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gate_gradients": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "device_18": {
                "device_name": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_27": {
                "device_name": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_34": {
                "device_name": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_add_35": {
                "ref": {
                    "value": "self.accumulator_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "device_38": {
                "device_name": {
                    "value": "self.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_39": {
                "ref": {
                    "value": "self.accumulator_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.zeros(tf.shape(self.accumulator_var))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_73": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_74": {
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_RESOURCE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_92": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_121": {
                "variable": {
                    "value": "is_it_time_yet",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(global_step, self.sync_every_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self.sync_every_steps - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_124": {
                "variable": {
                    "value": "update_op",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_it_time_yet",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.mod(global_step, self.sync_every_steps), self.sync_every_steps - 1)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : self._compute_update_op(optimizer, [a.get_value(g, self.sync_every_steps, self.average_grads) for (a, g) in zip(self.grads_acc, grads)], loss)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.no_op()",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "name_scope_140": {
                "name": {
                    "value": "aggregate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "div_29": {
                "x": {
                    "value": "self.accumulator_var + grad",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "n_steps",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_39": {
                "shape": {
                    "value": "tf.shape(self.accumulator_var)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_133": {
                "variable": {
                    "value": "assign_op",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_it_time_yet",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.mod(global_step, self.sync_every_steps), self.sync_every_steps - 1)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : [tf.group(a.reset()) for a in self.grads_acc]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : [tf.group(a.update(g)) for (a, g) in zip(self.grads_acc, grads)]",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "name_scope_150": {
                "name": {
                    "value": "apply",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_23": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_39": {
                "input": {
                    "value": "self.accumulator_var",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_113": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_120": {
                "key": {
                    "value": "TICK_NO",
                    "type": "str",
                    "possible_values": []
                }
            },
            "mod_121": {
                "x1": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_collection('TICK_NO')[0]",
                            "Subscript"
                        ]
                    ]
                },
                "x2": {
                    "value": "self.sync_every_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_132": {
                "control_inputs": {
                    "value": "[update_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_132": {
                "name": {
                    "value": "accumulate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_143": {
                "name": {
                    "value": "clip",
                    "type": "str",
                    "possible_values": []
                }
            },
            "no_op_129": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "clip_by_norm_144": {
                "t": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "self.clip_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_134": {
                "*inputs": {
                    "value": "a.reset()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "group_135": {
                "*inputs": {
                    "value": "a.update(g)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "lib/train/optimizers.py": {
        "tensorflow": {
            "get_variable_183": {
                "variable": {
                    "value": "d",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "d",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_189": {
                "variable": {
                    "value": "f_hat",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "f_hat",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_196": {
                "variable": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "t",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_equal_244": {
                "variable": {
                    "value": "at_start",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('t', shape=[], initializer=tf.constant_initializer(1.0), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "greater_equal_222": {
                "variable": {
                    "value": "loss_increased",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "f_hat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('f_hat', shape=[], dtype=tf.float32, initializer=tf.constant_initializer(0.0), trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_223": {
                "variable": {
                    "value": "delta1_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "loss_increased",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(loss, f_hat)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.constant(self._threshold_lower + 1.0)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.constant(1.0 / (self._threshold_upper + 1.0))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_228": {
                "variable": {
                    "value": "delta2_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "loss_increased",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(loss, f_hat)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.constant(self._threshold_upper + 1.0)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.constant(1.0 / (self._threshold_lower + 1.0))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "minimum_233": {
                "variable": {
                    "value": "c_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.maximum(delta1_t, loss / f_hat)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "delta2_t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cond(loss_increased, lambda : tf.constant(self._threshold_upper + 1.0), lambda : tf.constant(1.0 / (self._threshold_lower + 1.0)))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_178": {
                "name_or_scope": {
                    "value": "eve",
                    "type": "str",
                    "possible_values": []
                }
            },
            "group_271": {
                "*inputs": {
                    "value": "*updates + per_var_update_ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "constant_initializer_186": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_193": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_199": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "variable_scope_207": {
                "name_or_scope": {
                    "value": "v",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_213": {
                "name_or_scope": {
                    "value": "m",
                    "type": "str",
                    "possible_values": []
                }
            },
            "maximum_233": {
                "x": {
                    "value": "delta1_t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.cond(loss_increased, lambda : tf.constant(self._threshold_lower + 1.0), lambda : tf.constant(1.0 / (self._threshold_upper + 1.0)))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "loss / f_hat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_234": {
                "x": {
                    "value": "(c_t - 1.0) * f_hat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "minimum_234": {
                "x": {
                    "value": "c_t * f_hat",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "f_hat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('f_hat', shape=[], dtype=tf.float32, initializer=tf.constant_initializer(0.0), trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_245": {
                "pred": {
                    "value": "at_start",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(t, 2.0)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "update_not_at_start",
                    "type": "Variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "update_at_start",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "get_variable_208": {
                "name": {
                    "value": "var.name.replace(':', '')",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros(var.get_shape())",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_214": {
                "name": {
                    "value": "var.name.replace(':', '')",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros(var.get_shape())",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "constant_225": {
                "value": {
                    "value": "self._threshold_lower + 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_226": {
                "value": {
                    "value": "1.0 / (self._threshold_upper + 1.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_230": {
                "value": {
                    "value": "self._threshold_upper + 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_231": {
                "value": {
                    "value": "1.0 / (self._threshold_lower + 1.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_mul_256": {
                "scalar": {
                    "value": "1.0 - self._beta1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "grads_and_vars[i][0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "square_262": {
                "x": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "grads_and_vars[i][0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "pow_263": {
                "x": {
                    "value": "self._beta2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('t', shape=[], initializer=tf.constant_initializer(1.0), trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_257": {
                "x": {
                    "value": "self._beta1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_variable('t', shape=[], initializer=tf.constant_initializer(1.0), trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_210": {
                "shape": {
                    "value": "var.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_216": {
                "shape": {
                    "value": "var.get_shape()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_264": {
                "x": {
                    "value": "v_hat",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "v_t / (1.0 - tf.pow(self._beta2, t))",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "lib/train/saveload.py": {
        "tensorflow": {
            "get_default_session_25": {
                "variable": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_25": {
                "variable": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "main": {
                    "value": "[p[k] for k in keys]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "get_default_graph_64": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_graph_75": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_43": {
                "name_or_scope": {
                    "value": "load",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_49": {
                "variable": {
                    "value": "placeholder",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_83": {
                "name": {
                    "value": "initialize",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_86": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variables_initializer_90": {
                "var_list": {
                    "value": "uninitialized_vars",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "run_90": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_session_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_57": {
                "main": {
                    "value": "ops[ofs:ofs + batch_size]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "argv": {
                    "value": "feed_dict",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                }
            },
            "get_default_session_84": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_84": {
                "main": {
                    "value": "tf.report_uninitialized_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "report_uninitialized_variables_84": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assign_53": {
                "ref": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "vars",
                            "Name"
                        ],
                        [
                            "vars",
                            "Name"
                        ],
                        [
                            "tf.global_variables()",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "placeholder",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.placeholder(var.dtype)",
                            "Call"
                        ]
                    ]
                },
                "validate_shape": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "lib/train/tickers.py": {
        "tensorflow": {
            "get_default_session_179": {
                "variable": {
                    "value": "self.multiplier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_179": {
                "variable": {
                    "value": "self.multiplier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "main": {
                    "value": "tf.assign(self.learning_rate_fn.multiplier_var, new_multiplier)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_239": {
                "variable": {
                    "value": "self.writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "self.folder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_session_362": {
                "variable": {
                    "value": "batch_no",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_362": {
                "variable": {
                    "value": "batch_no",
                    "type": "Variable",
                    "possible_values": []
                },
                "main": {
                    "value": "self.context.get_batch_no_ingraph()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_default_session_634": {
                "variable": {
                    "value": "results",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_634": {
                "variable": {
                    "value": "results",
                    "type": "Variable",
                    "possible_values": []
                },
                "main": {
                    "value": "ops",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "feed_dict": {
                    "value": "feed_dict",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dict(zip(nested_flatten(self.dev_batch_inp), nested_flatten(batch)))",
                            "Call"
                        ],
                        [
                            "dict(zip(nested_flatten(self.dev_counters_inp), nested_flatten(counters)))",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_661": {
                "variable": {
                    "value": "self.min_dev_loss_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "min_dev_loss",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(np.inf)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_667": {
                "variable": {
                    "value": "self.min_dev_loss_global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "min_dev_loss_global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_672": {
                "variable": {
                    "value": "self.min_dev_loss_inp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_673": {
                "variable": {
                    "value": "self.min_dev_loss_global_step_inp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_default_session_885": {
                "variable": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_885": {
                "variable": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "main": {
                    "value": "self.op_list",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_911": {
                "variable": {
                    "value": "self.multiplier_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate_multiplier",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_default_session_185": {
                "variable": {
                    "value": "self.multiplier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_185": {
                "variable": {
                    "value": "self.multiplier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "main": {
                    "value": "self.learning_rate_fn.multiplier_var",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_549": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "group_552": {
                "*inputs": {
                    "value": "*ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "run_552": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_default_session_703": {
                "variable": {
                    "value": "(self.min_dev_loss, self.min_dev_loss_global_step)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_703": {
                "variable": {
                    "value": "(self.min_dev_loss, self.min_dev_loss_global_step)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "main": {
                    "value": "self.update_vars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "{self.min_dev_loss_inp: dev_loss, self.min_dev_loss_global_step_inp: global_step}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "group_843": {
                "*inputs": {
                    "value": "*check_op",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "name_scope_926": {
                "name": {
                    "value": "learning_rate_fn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_928": {
                "variable": {
                    "value": "new_learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "scale",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_180": {
                "ref": {
                    "value": "self.learning_rate_fn.multiplier_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "new_multiplier",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "get_default_session_359": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_359": {
                "main": {
                    "value": "tf.get_collection(tf.GraphKeys.GLOBAL_STEP)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "write_graph_483": {
                "graph_or_graph_def": {
                    "value": "tf.get_default_session().graph_def",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "self.folder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "graph.pbtxt",
                    "type": "str",
                    "possible_values": []
                }
            },
            "assign_675": {
                "ref": {
                    "value": "self.min_dev_loss_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.min_dev_loss_inp",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_676": {
                "ref": {
                    "value": "self.min_dev_loss_global_step_var",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.min_dev_loss_global_step_inp",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "InvalidArgumentError_818": {
                "node_def": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "op": {
                    "value": "Train Loss",
                    "type": "str",
                    "possible_values": []
                },
                "message": {
                    "value": "Train Loss: Nan or inf values spotted",
                    "type": "str",
                    "possible_values": []
                }
            },
            "InvalidArgumentError_832": {
                "node_def": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "op": {
                    "value": "Dev Loss",
                    "type": "str",
                    "possible_values": []
                },
                "message": {
                    "value": "Dev Loss: Nan or inf values spotted",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_default_graph_837": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "bitcast_870": {
                "variable": {
                    "value": "op",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.global_variables()",
                            "Call"
                        ],
                        [
                            "self.var_list",
                            "Attribute"
                        ],
                        [
                            "diverged_vars",
                            "Name"
                        ]
                    ]
                },
                "type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_903": {
                "*inputs": {
                    "value": "*ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "run_903": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "exponential_decay_930": {
                "variable": {
                    "value": "new_learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "scale",
                    "type": "Variable",
                    "possible_values": []
                },
                "global_step": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "kwargs['decay_steps']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "kwargs['decay_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "staircase": {
                    "value": "kwargs.get('staircase', False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_default_graph_243": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_260": {
                "key": {
                    "value": "lib.meta.SUMMARIES_ZOO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_266": {
                "key": {
                    "value": "lib.meta.PARAMS_SUMMARIES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_session_532": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_532": {
                "main": {
                    "value": "tf.report_uninitialized_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_550": {
                "device_name": {
                    "value": "var.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_578": {
                "name": {
                    "value": "'%s/loss' % self.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_default_session_606": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_606": {
                "main": {
                    "value": "self.dev_batch_counters_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "feed_dict",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "dict(zip(nested_flatten(self.dev_batch_inp), nested_flatten(batch)))",
                            "Call"
                        ],
                        [
                            "dict(zip(nested_flatten(self.dev_counters_inp), nested_flatten(counters)))",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_617": {
                "name": {
                    "value": "'%s/loss' % self.name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_663": {
                "value": {
                    "value": "np.inf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_669": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "bitcast_872": {
                "variable": {
                    "value": "op",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.global_variables()",
                            "Call"
                        ],
                        [
                            "self.var_list",
                            "Attribute"
                        ],
                        [
                            "diverged_vars",
                            "Name"
                        ]
                    ]
                },
                "type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_913": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "inverse_time_decay_935": {
                "variable": {
                    "value": "new_learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "scale",
                    "type": "Variable",
                    "possible_values": []
                },
                "global_step": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "kwargs['decay_steps']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "kwargs['decay_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "staircase": {
                    "value": "kwargs.get('staircase', False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_359": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_STEP",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_session_483": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "report_uninitialized_variables_532": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_878": {
                "input": {
                    "value": "tf.reduce_sum(op)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_901": {
                "ref": {
                    "value": "var",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.global_variables()",
                            "Call"
                        ],
                        [
                            "self.var_list",
                            "Attribute"
                        ],
                        [
                            "diverged_vars",
                            "Name"
                        ]
                    ]
                },
                "value": {
                    "value": "lib.ops.mpi.allreduce(var, average=True, name=re.sub('\\\\W', '_', var.name) + '_sync')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_global_step_921": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "natural_exp_decay_940": {
                "variable": {
                    "value": "new_learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "scale",
                    "type": "Variable",
                    "possible_values": []
                },
                "global_step": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "kwargs['decay_steps']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "kwargs['decay_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "staircase": {
                    "value": "kwargs.get('staircase', False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_258": {
                "name": {
                    "value": "Train/LearningRate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_learning_rate_ingraph()",
                            "Call"
                        ]
                    ]
                }
            },
            "histogram_264": {
                "name": {
                    "value": "v.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "placeholder_581": {
                "dtype": {
                    "value": "tf.as_dtype(e.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] * len(e.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_618": {
                "dtype": {
                    "value": "tf.as_dtype(e.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] * len(e.shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_878": {
                "input_tensor": {
                    "value": "op",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.get_default_graph().get_operation_by_name(op_name)",
                            "Call"
                        ],
                        [
                            "tf.bitcast(var, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.bitcast(var, tf.int64)",
                            "Call"
                        ],
                        [
                            "var",
                            "Name"
                        ]
                    ]
                }
            },
            "polynomial_decay_945": {
                "variable": {
                    "value": "new_learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "scale",
                    "type": "Variable",
                    "possible_values": []
                },
                "global_step": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                },
                "decay_steps": {
                    "value": "kwargs['decay_steps']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "end_learning_rate": {
                    "value": "kwargs['end_learning_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "power": {
                    "value": "kwargs.get('power', 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "cycle": {
                    "value": "kwargs.get('cycle', False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "model_variables_264": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_841": {
                "control_inputs": {
                    "value": "check_op",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.check_numerics(output, message=message)]",
                            "List"
                        ]
                    ]
                }
            },
            "as_dtype_581": {
                "type_value": {
                    "value": "e.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_618": {
                "type_value": {
                    "value": "e.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "check_numerics_842": {
                "tensor": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "op.outputs",
                            "Attribute"
                        ]
                    ]
                },
                "message": {
                    "value": "message",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "op_name + ':' + str(output.value_index)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_950": {
                "condition": {
                    "value": "global_step > kwargs['decay_steps']",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.exp(tf.to_float(global_step) / kwargs['decay_steps'] - 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(global_step) / kwargs['decay_steps']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_952": {
                "x": {
                    "value": "tf.to_float(global_step) / kwargs['decay_steps'] - 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "where_956": {
                "condition": {
                    "value": "global_step > kwargs['decay_steps']",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.constant(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(global_step) / kwargs['decay_steps']",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_953": {
                "x": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_958": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_962": {
                "condition": {
                    "value": "global_step > kwargs['decay_steps']",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.constant(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.constant(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_959": {
                "x": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_964": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_965": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_952": {
                "x": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ],
                        [
                            "self.context.get_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_969": {
                "x": {
                    "value": "tf.to_float(global_step + 1) ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(global_step + 1) * kwargs['decay_steps'] ** (-1.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "minimum_975": {
                "x": {
                    "value": "tf.to_float(global_step + 1) ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(global_step + 1) * kwargs['decay_steps'] ** (-1.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_970": {
                "x": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_971": {
                "x": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_976": {
                "x": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_977": {
                "x": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "lib/util.py": {
        "tensorflow": {
            "merge_174": {
                "inputs": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "collections": {
                    "value": "collections",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_136": {
                "value": {
                    "value": "orthogonal(shape) * scale",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_173": {
                "input": {
                    "value": "b''",
                    "type": "bytes",
                    "possible_values": []
                }
            }
        }
    },
    "scripts/nmt.py": {
        "tensorflow": {
            "GraphDef_37": {
                "variable": {
                    "value": "output_graph_def",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "NodeDef_39": {
                "variable": {
                    "value": "output_node",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}