{
    "Model/data_reader.py": {
        "tensorflow": {}
    },
    "Model/evaluate_model.py": {
        "tensorflow": {
            "zeros_28": {
                "shape": {
                    "value": "(0, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Model/metrics.py": {
        "tensorflow": {
            "cast_25": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.clip_by_value(targets, 0, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_26": {
                "variable": {
                    "value": "target_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.one_hot(targets, predictions.shape[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_prod_32": {
                "variable": {
                    "value": "whole_seq_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1 - padding + padding * tf.metrics.sparse_categorical_accuracy(tf.constant(targets), predictions)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_30": {
                "input_tensor": {
                    "value": "padding * tf.metrics.sparse_categorical_accuracy(tf.constant(targets), predictions)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_31": {
                "input_tensor": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.clip_by_value(targets, 0, 1), 'float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_categorical_accuracy_35": {
                "variable": {
                    "value": "pointers_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "pointer_locs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y_pred": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_prod_36": {
                "variable": {
                    "value": "pointers_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pointers_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.metrics.sparse_categorical_accuracy(pointer_locs, pointer_preds)",
                            "Call"
                        ],
                        [
                            "tf.reduce_prod(pointers_acc, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_41": {
                "input_tensor": {
                    "value": "whole_seq_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_prod(1 - padding + padding * tf.metrics.sparse_categorical_accuracy(tf.constant(targets), predictions), -1)",
                            "Call"
                        ],
                        [
                            "whole_seq_acc * pointers_acc",
                            "BinOp"
                        ]
                    ]
                }
            },
            "clip_by_value_25": {
                "t": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_26": {
                "indices": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "depth": {
                    "value": "predictions.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_29": {
                "input_tensor": {
                    "value": "padding * tf.nn.softmax_cross_entropy_with_logits(labels=target_tensor, logits=predictions)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_37": {
                "input_tensor": {
                    "value": "pointers_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.metrics.sparse_categorical_accuracy(pointer_locs, pointer_preds)",
                            "Call"
                        ],
                        [
                            "tf.reduce_prod(pointers_acc, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_categorical_accuracy_30": {
                "y_true": {
                    "value": "tf.constant(targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_29": {
                "labels": {
                    "value": "target_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.one_hot(targets, predictions.shape[-1]), 'float32')",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_30": {
                "value": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sparse_categorical_accuracy_32": {
                "y_true": {
                    "value": "tf.constant(targets)",
                    "type": "Call",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_32": {
                "value": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "Model/tracker.py": {
        "tensorflow": {
            "Checkpoint_16": {
                "variable": {
                    "value": "self.ckpt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "model": {
                    "value": "model",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "tf.Variable(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "samples": {
                    "value": "tf.Variable(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "time": {
                    "value": "tf.Variable(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "CheckpointManager_17": {
                "variable": {
                    "value": "self.manager",
                    "type": "Attribute",
                    "possible_values": []
                },
                "checkpoint": {
                    "value": "self.ckpt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "directory": {
                    "value": "self.model_path",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Variable_16": {
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "Model/train_model.py": {
        "tensorflow": {
            "Adam_27": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "config['training']['lr']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_166": {
                "variable": {
                    "value": "post_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.clip_by_value(post_indices, 0, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_167": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "post_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.clip_by_value(post_indices, 0, 1), 'float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_168": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "post_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model(pre, pre_locs, post[:, :-1], pointer_locs, training=True)",
                            "Call"
                        ],
                        [
                            "model(pre, pre_locs, post[:, :-1], pointer_locs, training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_142": {
                "variable": {
                    "value": "max_pointers",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pointer_preds[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_172": {
                "variable": {
                    "value": "pointer_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "pointer_locs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((0, 0), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.zeros((0, 0), 'int32')",
                            "Call"
                        ],
                        [
                            "pointer_locs[0].numpy()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_173": {
                "variable": {
                    "value": "pointer_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pointer_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=pointer_locs, logits=pointer_preds)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(pointer_loss, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(pointer_loss)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_174": {
                "variable": {
                    "value": "pointer_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pointer_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=pointer_locs, logits=pointer_preds)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(pointer_loss, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(pointer_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_29": {
                "shape": {
                    "value": "(0, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_64": {
                "variable": {
                    "value": "(grads, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tape.gradient(loss, model.trainable_variables)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_109": {
                "variable": {
                    "value": "pointer_locs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(0, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_166": {
                "t": {
                    "value": "post_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_170": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "masked_ce_loss(post[:, 1:], preds, pointer_locs, pointer_preds)",
                            "Call"
                        ],
                        [
                            "masked_ce_loss(post[:, 1:], preds)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=post_indices, logits=preds)",
                            "Call"
                        ],
                        [
                            "loss + pointer_loss",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(loss) / samples",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_48": {
                "variable": {
                    "value": "pointer_locs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(0, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GradientTape_53": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_111": {
                "input_tensor": {
                    "value": "1 - tf.clip_by_value(post[:, 1:], 0, 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_49": {
                "input_tensor": {
                    "value": "1 - tf.clip_by_value(post[:, 1:], 0, 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_159": {
                "input": {
                    "value": "preds[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "clip_by_value_111": {
                "t": {
                    "value": "post[:, 1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_49": {
                "t": {
                    "value": "post[:, 1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "Model/transformer.py": {
        "tensorflow": {
            "constant_184": {
                "variable": {
                    "value": "pos_enc",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "encoded_vec.reshape([sentence_length, dim])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "einsum_37": {
                "variable": {
                    "value": "context",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bhqk,bkha->bqha",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_attention_weights(query, keys, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bkha,bqha->bhqk', keys, query)",
                            "Call"
                        ],
                        [
                            "alpha * masks",
                            "BinOp"
                        ],
                        [
                            "alpha * masks + (1.0 - tf.math.ceil(masks)) * tf.float32.min",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(alpha)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('btd,dha->btha', states if key_states is None else key_states, self.attn_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_38": {
                "variable": {
                    "value": "context",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "btha,had->btd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "context",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('bhqk,bkha->bqha', alpha, values)",
                            "Call"
                        ],
                        [
                            "tf.einsum('btha,had->btd', context, self.weight_out)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.weight_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_30": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, 4), dtype=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_44": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "btd,dha->btha",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.embed, inputs)",
                            "Call"
                        ],
                        [
                            "states + new_states",
                            "BinOp"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.attn_query",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_45": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "btd,dha->btha",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "states if key_states is None else key_states",
                    "type": "IfExp",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.attn_keys",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_46": {
                "variable": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "btd,dha->btha",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "states if key_states is None else key_states",
                    "type": "IfExp",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.attn_values",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_42": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None), dtype=tf.float32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_52": {
                "variable": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bkha,bqha->bhqk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('btd,dha->btha', states if key_states is None else key_states, self.attn_keys)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(keys, -1)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('btd,dha->btha', states, self.attn_query)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_65": {
                "variable": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_attention_weights(query, keys, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bkha,bqha->bhqk', keys, query)",
                            "Call"
                        ],
                        [
                            "alpha * masks",
                            "BinOp"
                        ],
                        [
                            "alpha * masks + (1.0 - tf.math.ceil(masks)) * tf.float32.min",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(alpha)",
                            "Call"
                        ]
                    ]
                }
            },
            "function_50": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, 4), dtype=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_84": {
                "variable": {
                    "value": "self.pos_enc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "positional_encoding(model_config['embed_dim'], 2000)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LayerNormalization_98": {
                "variable": {
                    "value": "self.ln_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "embedding_lookup_127": {
                "variable": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.embed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "function_125": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None), dtype=tf.int32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_132": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None), dtype=tf.int32), tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, 4), dtype=tf.int32), tf.TensorSpec(shape=None, dtype=tf.bool)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_148": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None), dtype=tf.int32), tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, None, None, None), dtype=tf.float32), tf.TensorSpec(shape=(None, 4), dtype=tf.int32), tf.TensorSpec(shape=None, dtype=tf.bool)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_174": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None, None), dtype=tf.float32)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_54": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('btd,dha->btha', states if key_states is None else key_states, self.attn_keys)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(keys, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "matmul_55": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.one_hot(attention_bias[:, -1], self.bias_dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self.bias_embs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_56": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(bias, self.bias_scalar)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_57": {
                "variable": {
                    "value": "bias_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_attention_weights(query, keys, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bkha,bqha->bhqk', keys, query)",
                            "Call"
                        ],
                        [
                            "alpha * masks",
                            "BinOp"
                        ],
                        [
                            "alpha * masks + (1.0 - tf.math.ceil(masks)) * tf.float32.min",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(alpha)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_58": {
                "variable": {
                    "value": "bias_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[bias_shape[0], bias_shape[2], bias_shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scatter_nd_59": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "attention_bias[:, :-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "updates": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.one_hot(attention_bias[:, -1], self.bias_dim), self.bias_embs)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.matmul(bias, self.bias_scalar), -1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(attention_bias[:, :-1], bias, bias_shape)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bqk,bkh->bhqk', bias, keys)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "bias_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack([bias_shape[0], bias_shape[2], bias_shape[3]])",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_60": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bqk,bkh->bhqk",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.one_hot(attention_bias[:, -1], self.bias_dim), self.bias_embs)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.matmul(bias, self.bias_scalar), -1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(attention_bias[:, :-1], bias, bias_shape)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bqk,bkh->bhqk', bias, keys)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('btd,dha->btha', states if key_states is None else key_states, self.attn_keys)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(keys, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "rsqrt_62": {
                "x": {
                    "value": "tf.cast(self.attention_dim_per_head, 'float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_89": {
                "variable": {
                    "value": "random_init",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.hidden_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_90": {
                "variable": {
                    "value": "self.embed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "random_init([self.vocab_dim, self.embed_dim])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_119": {
                "variable": {
                    "value": "attention_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(0, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sqrt_128": {
                "x": {
                    "value": "tf.cast(tf.shape(states)[-1], 'float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sequence_mask_171": {
                "lengths": {
                    "value": "tf.range(1, seq_len + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_176": {
                "a": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.embed, inputs)",
                            "Call"
                        ],
                        [
                            "states + new_states",
                            "BinOp"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.embed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_62": {
                "x": {
                    "value": "self.attention_dim_per_head",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_101": {
                "units": {
                    "value": "self.ff_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_102": {
                "units": {
                    "value": "self.hidden_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_128": {
                "x": {
                    "value": "tf.shape(states)[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_138": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_142": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_144": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_154": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_159": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_163": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_165": {
                "variable": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "(self.ln[ix][0](states),)",
                            "Tuple"
                        ],
                        [
                            "self.attention[ix](new_states, masks, tf.zeros((0, 4), dtype='int32'))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ln[ix][2](states)",
                            "Call"
                        ],
                        [
                            "self.enc_attention[ix]((new_states, key_states), key_masks, attention_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_1[ix](self.ln[ix][1](states))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ],
                        [
                            "self.ff_2[ix](new_states)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(new_states, rate=self.dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorSpec_30": {
                "shape": {
                    "value": "(None, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorSpec_42": {
                "shape": {
                    "value": "(None, None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_55": {
                "indices": {
                    "value": "attention_bias[:, -1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.bias_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_56": {
                "a": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.one_hot(attention_bias[:, -1], self.bias_dim), self.bias_embs)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.matmul(bias, self.bias_scalar), -1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(attention_bias[:, :-1], bias, bias_shape)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bqk,bkh->bhqk', bias, keys)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.bias_scalar",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorSpec_50": {
                "shape": {
                    "value": "(None, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LayerNormalization_97": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TensorSpec_125": {
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorSpec_132": {
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_153": {
                "shape": {
                    "value": "(0, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorSpec_148": {
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorSpec_174": {
                "shape": {
                    "value": "(None, None, None)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_128": {
                "input": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.embed, inputs)",
                            "Call"
                        ],
                        [
                            "states + new_states",
                            "BinOp"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_129": {
                "input": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.embed, inputs)",
                            "Call"
                        ],
                        [
                            "states + new_states",
                            "BinOp"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ],
                        [
                            "self.embed_inputs(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "ceil_64": {
                "x": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "masks[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "Model/transformer_patching_model.py": {
        "tensorflow": {
            "cast_24": {
                "variable": {
                    "value": "enc_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.clip_by_value(pre_indices, 0, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_25": {
                "variable": {
                    "value": "enc_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "enc_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.clip_by_value(pre_indices, 0, 1), 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(enc_mask, [batch_dim, 1, 1, pre_len])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_dim, 1, 1, pre_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_28": {
                "variable": {
                    "value": "post_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.clip_by_value(post_indices, 0, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_29": {
                "variable": {
                    "value": "post_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "post_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.clip_by_value(post_indices, 0, 1), 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(post_mask, [batch_dim, 1, post_len, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_dim, 1, post_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_31": {
                "variable": {
                    "value": "post_seq_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "post_seq_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.transformer_dec.get_sequence_mask(post_len)",
                            "Call"
                        ],
                        [
                            "tf.reshape(post_seq_mask, [1, 1, post_len, post_len])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, post_len, post_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_34": {
                "variable": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.sequence_mask(pre_locs[:, 1], pre_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_37": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(start_end_mask, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, post_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_38": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(in_biases, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_39": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(start_end_mask, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(in_start_end_mask, [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_18": {
                "input_signature": {
                    "value": "[tf.TensorSpec(shape=(None, None), dtype=tf.int32), tf.TensorSpec(shape=(None, None), dtype=tf.int32), tf.TensorSpec(shape=(None, None), dtype=tf.int32), tf.TensorSpec(shape=(None, None), dtype=tf.int32), tf.TensorSpec(shape=None, dtype=tf.bool)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_72": {
                "variable": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.sequence_mask(pre_locs[:, 1], pre_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_76": {
                "variable": {
                    "value": "pre_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.clip_by_value(pre_indices, 0, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_77": {
                "variable": {
                    "value": "pre_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pre_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.clip_by_value(pre_indices, 0, 1), 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pre_mask, [batch_dim, 1, 1, pre_len])",
                            "Call"
                        ],
                        [
                            "tf.split(pre_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_dim, 1, 1, pre_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_85": {
                "variable": {
                    "value": "pre_states",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pre_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.transformer_enc((pre_indices,), (pre_mask,), training=False)",
                            "Call"
                        ],
                        [
                            "tf.split(pre_states, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "batch_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[0]",
                            "Subscript"
                        ],
                        [
                            "int(tf.shape(pre_indices)[0].numpy())",
                            "Call"
                        ]
                    ]
                }
            },
            "split_86": {
                "variable": {
                    "value": "pre_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pre_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.clip_by_value(pre_indices, 0, 1), 'float32')",
                            "Call"
                        ],
                        [
                            "tf.reshape(pre_mask, [batch_dim, 1, 1, pre_len])",
                            "Call"
                        ],
                        [
                            "tf.split(pre_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "batch_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[0]",
                            "Subscript"
                        ],
                        [
                            "int(tf.shape(pre_indices)[0].numpy())",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_87": {
                "variable": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_88": {
                "variable": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "batch_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[0]",
                            "Subscript"
                        ],
                        [
                            "int(tf.shape(pre_indices)[0].numpy())",
                            "Call"
                        ]
                    ]
                }
            },
            "Dense_16": {
                "variable": {
                    "value": "self.pointer_pred",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_35": {
                "x": {
                    "value": "tf.sequence_mask(pre_locs[:, 0] - 1, pre_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stack_43": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(batch_dim), pointer_locs[:, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_44": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones(batch_dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(start_end_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_45": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(loc_bias, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, post_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_46": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(loc_bias, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_47": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_49": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(batch_dim), pointer_locs[:, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_50": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones(batch_dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(start_end_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_51": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(rem_bias, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, post_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_52": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(rem_bias, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_53": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_55": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[in_biases, loc_bias, rem_bias]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_62": {
                "variable": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.pointer_pred(enc_state)",
                            "Call"
                        ],
                        [
                            "pointer_preds + (1.0 - tf.expand_dims(tf.cast(start_end_mask, 'float32'), -1)) * tf.float32.min",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(pointer_preds, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.pointer_pred(pre_states)",
                            "Call"
                        ],
                        [
                            "tf.transpose(pointer_preds, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_73": {
                "x": {
                    "value": "tf.sequence_mask(pre_locs[:, 0] - 1, pre_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_83": {
                "variable": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.pointer_pred(enc_state)",
                            "Call"
                        ],
                        [
                            "pointer_preds + (1.0 - tf.expand_dims(tf.cast(start_end_mask, 'float32'), -1)) * tf.float32.min",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(pointer_preds, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.pointer_pred(pre_states)",
                            "Call"
                        ],
                        [
                            "tf.transpose(pointer_preds, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "top_k_92": {
                "variable": {
                    "value": "(probs, ixes)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax(pointer_preds)",
                    "type": "Call",
                    "possible_values": []
                },
                "k": {
                    "value": "per_side",
                    "type": "variable",
                    "possible_values": [
                        [
                            "math.ceil(math.sqrt(beam_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_93": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(probs, [0, 2, 1]).numpy()",
                            "Call"
                        ],
                        [
                            "probs.numpy()",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_94": {
                "variable": {
                    "value": "ixes",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "ixes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(ixes, [0, 2, 1]).numpy()",
                            "Call"
                        ],
                        [
                            "ixes.numpy()",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_115": {
                "variable": {
                    "value": "in_states",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.tile(pre_states[ix], [len(to_proc), 1, 1]) for (ix, to_proc) in to_process.items()]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_116": {
                "variable": {
                    "value": "in_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.tile(pre_mask[ix], [len(to_proc), 1, 1, 1]) for (ix, to_proc) in to_process.items()]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_117": {
                "variable": {
                    "value": "in_start_end_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.tile(start_end_mask[ix], [len(to_proc), 1, 1]) for (ix, to_proc) in to_process.items()]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_124": {
                "variable": {
                    "value": "post_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[inp[-1] for inp in to_process]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "ones_like_127": {
                "variable": {
                    "value": "post_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "post_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([inp[-1] for inp in to_process])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_128": {
                "input": {
                    "value": "post_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(post_indices, dtype='float32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(post_masks, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_129": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "in_start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.tile(start_end_mask[ix], [len(to_proc), 1, 1]) for (ix, to_proc) in to_process.items()], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(in_start_end_mask, 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, step + 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_130": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(in_biases, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_131": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(start_end_mask, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(in_start_end_mask, [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_151": {
                "variable": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.transformer_dec.predict(dec_state)",
                            "Call"
                        ],
                        [
                            "self.transformer_dec.predict(post_states)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(preds, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_154": {
                "variable": {
                    "value": "(probs, ixes)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax(preds)",
                    "type": "Call",
                    "possible_values": []
                },
                "k": {
                    "value": "max(25, beam_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_20": {
                "input": {
                    "value": "pre_indices",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_21": {
                "input": {
                    "value": "pre_indices",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_22": {
                "input": {
                    "value": "post_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([inp[-1] for inp in to_process])",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_value_24": {
                "t": {
                    "value": "pre_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_28": {
                "t": {
                    "value": "post_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([inp[-1] for inp in to_process])",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sequence_mask_34": {
                "lengths": {
                    "value": "pre_locs[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "pre_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sequence_mask_35": {
                "lengths": {
                    "value": "pre_locs[:, 0] - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "pre_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "expand_dims_37": {
                "input": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_38": {
                "condition": {
                    "value": "tf.greater(in_biases, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_70": {
                "input": {
                    "value": "pre_indices",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sequence_mask_72": {
                "lengths": {
                    "value": "pre_locs[:, 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "pre_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sequence_mask_73": {
                "lengths": {
                    "value": "pre_locs[:, 0] - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "pre_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(pre_indices)[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "clip_by_value_76": {
                "t": {
                    "value": "pre_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_119": {
                "variable": {
                    "value": "in_pointer_locs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[t[2] for to_proc in to_process.values() for t in to_proc]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_133": {
                "variable": {
                    "value": "in_start_end_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "in_start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.tile(start_end_mask[ix], [len(to_proc), 1, 1]) for (ix, to_proc) in to_process.items()], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(in_start_end_mask, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_134": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_indices, in_pointer_locs[:, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_135": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones(tf.shape(loc_bias)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(in_start_end_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_136": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(loc_bias, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, step + 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_137": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(loc_bias, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_138": {
                "variable": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_140": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_indices, in_pointer_locs[:, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_141": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones(tf.shape(rem_bias)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(in_start_end_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_142": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(rem_bias, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, step + 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_143": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(rem_bias, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_144": {
                "variable": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_146": {
                "variable": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[in_biases, loc_bias, rem_bias]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_38": {
                "x": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(start_end_mask, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(in_start_end_mask, [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_42": {
                "input": {
                    "value": "pointer_locs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_44": {
                "shape": {
                    "value": "batch_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[0]",
                            "Subscript"
                        ],
                        [
                            "int(tf.shape(pre_indices)[0].numpy())",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_44": {
                "input": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_45": {
                "input": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_46": {
                "condition": {
                    "value": "tf.greater(loc_bias, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_50": {
                "shape": {
                    "value": "batch_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(pre_indices)[0]",
                            "Subscript"
                        ],
                        [
                            "int(tf.shape(pre_indices)[0].numpy())",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_50": {
                "input": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_51": {
                "input": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_52": {
                "condition": {
                    "value": "tf.greater(rem_bias, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorSpec_18": {
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_92": {
                "logits": {
                    "value": "pointer_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.pointer_pred(enc_state)",
                            "Call"
                        ],
                        [
                            "pointer_preds + (1.0 - tf.expand_dims(tf.cast(start_end_mask, 'float32'), -1)) * tf.float32.min",
                            "BinOp"
                        ],
                        [
                            "tf.transpose(pointer_preds, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.pointer_pred(pre_states)",
                            "Call"
                        ],
                        [
                            "tf.transpose(pointer_preds, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "where_130": {
                "condition": {
                    "value": "tf.greater(in_biases, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_154": {
                "logits": {
                    "value": "preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.transformer_dec.predict(dec_state)",
                            "Call"
                        ],
                        [
                            "self.transformer_dec.predict(post_states)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(preds, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_46": {
                "x": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "fill_47": {
                "dims": {
                    "value": "(tf.shape(loc_bias)[0], 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "range_49": {},
            "greater_52": {
                "x": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "fill_53": {
                "dims": {
                    "value": "(tf.shape(rem_bias)[0], 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_61": {
                "input": {
                    "value": "tf.cast(start_end_mask, 'float32')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_82": {
                "input": {
                    "value": "tf.cast(start_end_mask, 'float32')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_115": {
                "input": {
                    "value": "pre_states[ix]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[len(to_proc), 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_116": {
                "input": {
                    "value": "pre_mask[ix]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[len(to_proc), 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_117": {
                "input": {
                    "value": "start_end_mask[ix]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[len(to_proc), 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_130": {
                "x": {
                    "value": "in_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(start_end_mask, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(in_start_end_mask, [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(in_biases, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.pad(in_biases, [[0, 0], [0, 1]])",
                            "Call"
                        ],
                        [
                            "tf.concat([in_biases, loc_bias, rem_bias], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_135": {
                "shape": {
                    "value": "tf.shape(loc_bias)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_135": {
                "input": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_136": {
                "input": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_137": {
                "condition": {
                    "value": "tf.greater(loc_bias, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_141": {
                "shape": {
                    "value": "tf.shape(rem_bias)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_141": {
                "input": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_142": {
                "input": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_143": {
                "condition": {
                    "value": "tf.greater(rem_bias, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_61": {
                "x": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_69": {
                "input": {
                    "value": "pre_indices",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_82": {
                "x": {
                    "value": "start_end_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "start_end_mask - tf.cast(tf.sequence_mask(pre_locs[:, 0] - 1, pre_len), 'int32')",
                            "BinOp"
                        ],
                        [
                            "tf.cast(tf.sequence_mask(pre_locs[:, 1], pre_len), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(start_end_mask, 1)",
                            "Call"
                        ],
                        [
                            "tf.split(start_end_mask, batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "greater_137": {
                "x": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "fill_138": {
                "dims": {
                    "value": "(tf.shape(loc_bias)[0], 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "greater_143": {
                "x": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "fill_144": {
                "dims": {
                    "value": "(tf.shape(rem_bias)[0], 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_47": {
                "input": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_53": {
                "input": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_138": {
                "input": {
                    "value": "loc_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 0]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(loc_bias, tf.ones(tf.shape(loc_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(loc_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(loc_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([loc_bias, tf.fill((tf.shape(loc_bias)[0], 1), 2, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_144": {
                "input": {
                    "value": "rem_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(batch_dim), pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(batch_dim), tf.shape(start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, post_len, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack([batch_indices, in_pointer_locs[:, 1]], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(rem_bias, tf.ones(tf.shape(rem_bias)[0]), tf.shape(in_start_end_mask))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(rem_bias, 1), [1, step + 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.where(tf.greater(rem_bias, 0)), 'int32')",
                            "Call"
                        ],
                        [
                            "tf.concat([rem_bias, tf.fill((tf.shape(rem_bias)[0], 1), 3, 'int32')], axis=1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}