{
    "eval_helper.py": {
        "tensorflow": {
            "get_or_create_global_step_72": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_81": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_82": {
                "variable": {
                    "value": "self.summary_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "self.eval_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_86": {
                "variable": {
                    "value": "images_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "images.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_87": {
                "variable": {
                    "value": "labels_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "labels.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Summary_203": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[tf.Summary.Value(tag='xent clean test', simple_value=avg_xent_clean), tf.Summary.Value(tag='xent clean train', simple_value=avg_xent_clean_train), tf.Summary.Value(tag='xent poison test', simple_value=avg_xent_poison), tf.Summary.Value(tag='xent poison train', simple_value=avg_xent_poison_train), tf.Summary.Value(tag='xent poison train (no trigger)', simple_value=avg_xent_poison_train_nt), tf.Summary.Value(tag='xent poison test (non-target only)', simple_value=avg_xent_poison_nto), tf.Summary.Value(tag='accuracy clean test', simple_value=acc_clean), tf.Summary.Value(tag='accuracy clean train', simple_value=acc_clean_train), tf.Summary.Value(tag='accuracy poison test', simple_value=acc_poison), tf.Summary.Value(tag='accuracy poison train', simple_value=acc_poison_train), tf.Summary.Value(tag='accuracy poison train (no trigger)', simple_value=acc_poison_train_nt), tf.Summary.Value(tag='accuracy poison test (non-target only)', simple_value=acc_poison_nto), tf.Summary.Value(tag='attack success rate', simple_value=asr)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "set_random_seed_33": {
                "seed": {
                    "value": "config['random_seed']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "generate_poisoned_dataset.py": {
        "tensorflow": {
            "set_random_seed_34": {
                "seed": {
                    "value": "config['random_seed']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "poison_attack.py": {
        "tensorflow": {
            "set_random_seed_15": {
                "seed": {
                    "value": "random_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "resnet_model.py": {
        "tensorflow": {
            "reshape_40": {
                "variable": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(selector, (-1, 1))",
                            "Call"
                        ],
                        [
                            "selector",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_41": {
                "variable": {
                    "value": "ordinals",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.range(tf.shape(matrix, out_type=tf.int64)[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "stack_42": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[selector, ordinals]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "batch_normalization_157": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ],
                        [
                            "3",
                            "int"
                        ]
                    ]
                },
                "momentum": {
                    "value": "_BATCH_NORM_DECAY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.997",
                            "float"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "_BATCH_NORM_EPSILON",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "float"
                        ]
                    ]
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ],
                        [
                            "is_training",
                            "Method Argument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_160": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pad_182": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [pad_beg, pad_end], [pad_beg, pad_end]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_200": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[16, 16, 32, 64]",
                            "List"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ],
                        [
                            "filters",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kernel_size",
                            "Method Argument"
                        ],
                        [
                            "kernel_size",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ],
                        [
                            "strides",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ]
                    ]
                }
            },
            "squeeze_43": {
                "input": {
                    "value": "tf.gather_nd(tf.transpose(matrix), idx)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_69": {
                "variable": {
                    "value": "self.x_input_nchw",
                    "type": "Attribute",
                    "possible_values": []
                },
                "a": {
                    "value": "self.x_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_72": {
                "variable": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_92": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_119": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_120": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 64]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_121": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "self.num_classes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_122": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "final_dense",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_124": {
                "variable": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_126": {
                "variable": {
                    "value": "self.predictions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_127": {
                "variable": {
                    "value": "self.correct_prediction",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.predictions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_128": {
                "variable": {
                    "value": "self.num_correct",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(self.correct_prediction, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_130": {
                "variable": {
                    "value": "self.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(self.correct_prediction, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_132": {
                "variable": {
                    "value": "self.y_xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.y_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_134": {
                "variable": {
                    "value": "self.xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.y_xent",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "xent",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_155": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_162": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_198": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_210": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_278": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "random_crop_30": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, hps.image_size + padding, hps.image_size + padding)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [hps.image_size, hps.image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.per_image_standardization(image)",
                            "Call"
                        ],
                        [
                            "image",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "[hps.image_size, hps.image_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "per_image_standardization_35": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, hps.image_size + padding, hps.image_size + padding)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [hps.image_size, hps.image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.per_image_standardization(image)",
                            "Call"
                        ],
                        [
                            "image",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_nd_43": {
                "params": {
                    "value": "tf.transpose(matrix)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([selector, ordinals], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_built_with_cuda_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "average_pooling2d_110": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "channels_first",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_114": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "average_pooling2d_115": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "channels_last",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_118": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=_BATCH_NORM_DECAY, epsilon=_BATCH_NORM_EPSILON, center=True, scale=True, training=is_training, fused=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=filters, kernel_size=kernel_size, strides=strides, padding='SAME' if strides == 1 else 'VALID', use_bias=False, kernel_initializer=tf.variance_scaling_initializer(), data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, projection_shortcut, strides)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, 1)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=self.x_input_nchw, filters=filters[0], kernel_size=3, strides=1)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[1], block_fn=building_block, blocks=num_blocks, strides=1, is_training=self.is_training, name='block_layer1')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[2], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer2')",
                            "Call"
                        ],
                        [
                            "block_layer(inputs=inputs, filters=filters[3], block_fn=building_block, blocks=num_blocks, strides=2, is_training=self.is_training, name='block_layer3')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, self.is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_first')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=8, strides=1, padding='VALID', data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=self.num_classes)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "trainable_variables_143": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_145": {
                "inputs": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "is_built_with_cuda_154": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_built_with_cuda_161": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_built_with_cuda_197": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_built_with_cuda_209": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_flip_left_right_32": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, hps.image_size + padding, hps.image_size + padding)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, [hps.image_size, hps.image_size, 3])",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.per_image_standardization(image)",
                            "Call"
                        ],
                        [
                            "image",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_43": {
                "a": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "matrix",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "set_random_seed_56": {
                "seed": {
                    "value": "random_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_129": {
                "x": {
                    "value": "self.correct_prediction",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_131": {
                "x": {
                    "value": "self.correct_prediction",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_41": {
                "input": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "matrix",
                            "Method Argument"
                        ]
                    ]
                },
                "out_type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "l2_loss_144": {
                "t": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "train.py": {
        "tensorflow": {
            "placeholder_97": {
                "variable": {
                    "value": "iterator_handle",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_103": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "piecewise_constant_111": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(global_step, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "boundaries": {
                    "value": "boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['learning_rate_boundaries']",
                            "Subscript"
                        ]
                    ]
                },
                "values": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['learning_rates']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "get_collection_117": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_118": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.piecewise_constant(tf.cast(global_step, tf.int32), boundaries, values)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "float"
                        ]
                    ]
                }
            },
            "Saver_130": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "merge_131": {
                "variable": {
                    "value": "merged_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar('accuracy poison train', model.accuracy), tf.summary.scalar('xent poison train', model.xent / batch_size), tf.summary.image('images poison train', model.x_image), tf.summary.histogram('conf in y_input', model.confidence_in_correct), tf.summary.histogram('conf in y_pred', model.confidence_in_prediction)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "histogram_138": {
                "variable": {
                    "value": "clean_histogram",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "conf in clean",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.confidence_in_correct",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_139": {
                "variable": {
                    "value": "poison_only_merged_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar('accuracy poison only train', model.accuracy), tf.summary.scalar('xent poison only train', model.xent / batch_size), tf.summary.image('images poison only train', model.x_image), tf.summary.histogram('conf in poisoned only', model.confidence_in_correct)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "merge_145": {
                "variable": {
                    "value": "poison_no_trigger_merged_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar('accuracy poison train (no trigger)', model.accuracy), tf.summary.scalar('xent poison train (no trigger)', model.xent / batch_size), tf.summary.image('images poison train (no trigger)', model.x_image), tf.summary.histogram('conf in poisoned (no trigger)', model.confidence_in_correct)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "set_random_seed_34": {
                "seed": {
                    "value": "config['random_seed']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "placeholder_74": {
                "variable": {
                    "value": "images_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "images.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_75": {
                "variable": {
                    "value": "labels_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "labels.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_156": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config['model_dir']",
                            "Subscript"
                        ]
                    ]
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_112": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.framework.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_122": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_154": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_132": {
                "name": {
                    "value": "accuracy poison train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_133": {
                "name": {
                    "value": "xent poison train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.xent / batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "image_134": {
                "name": {
                    "value": "images poison train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.x_image",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_135": {
                "name": {
                    "value": "conf in y_input",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.confidence_in_correct",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_136": {
                "name": {
                    "value": "conf in y_pred",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.confidence_in_prediction",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_140": {
                "name": {
                    "value": "accuracy poison only train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_141": {
                "name": {
                    "value": "xent poison only train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.xent / batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "image_142": {
                "name": {
                    "value": "images poison only train",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.x_image",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_143": {
                "name": {
                    "value": "conf in poisoned only",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.confidence_in_correct",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_146": {
                "name": {
                    "value": "accuracy poison train (no trigger)",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.accuracy",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_147": {
                "name": {
                    "value": "xent poison train (no trigger)",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.xent / batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "image_148": {
                "name": {
                    "value": "images poison train (no trigger)",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.x_image",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "histogram_149": {
                "name": {
                    "value": "conf in poisoned (no trigger)",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model.confidence_in_correct",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_157": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}