{
    "CoPER_ConvE/qa_cpg/data.py": {
        "tensorflow": {
            "sparse_to_dense_230": {
                "variable": {
                    "value": "e2s_dense",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse_indices": {
                    "value": "correct_e2s[:, None]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "sample['e2_multi']",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(correct_e2s)",
                            "Call"
                        ]
                    ]
                },
                "sparse_values": {
                    "value": "tf.ones([tf.shape(correct_e2s)[0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "output_shape": {
                    "value": "[self.num_ent]",
                    "type": "List",
                    "possible_values": []
                },
                "validate_indices": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "size_241": {
                "variable": {
                    "value": "num_positives",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "correct_e2s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sample['e2_multi']",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(correct_e2s)",
                            "Call"
                        ]
                    ]
                }
            },
            "size_242": {
                "variable": {
                    "value": "num_negatives",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "wrong_e2s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_shuffle(tf.range(self.num_ent, dtype=tf.int64))",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_266": {
                "variable": {
                    "value": "indexes",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less_equal(num_positives, num_positives_needed)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_less_positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_less_positives",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "_more_positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_more_positives",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_270": {
                "variable": {
                    "value": "lookup_values",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "indexes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.less_equal(num_positives, num_positives_needed), _less_positives, _more_positives)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample['e2_multi'][:, None], neg_indexes], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_to_dense_280": {
                "variable": {
                    "value": "e2_multi_dense",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse_indices": {
                    "value": "sample['e2_multi'][:, None]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "conve_parser(sample)",
                            "Call"
                        ],
                        [
                            "parser(sample)",
                            "Call"
                        ],
                        [
                            "json.loads(line)",
                            "Call"
                        ],
                        [
                            "{'e1': e1, 'e2': 'None', 'rel': rel, 'e2_multi': ' '.join(list(value))}",
                            "Dict"
                        ],
                        [
                            "{'e1': e1, 'e2': e2, 'rel': rel, 'e2_multi': e2_multi}",
                            "Dict"
                        ],
                        [
                            "full_data",
                            "variable"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ]
                    ]
                },
                "sparse_values": {
                    "value": "tf.ones([tf.shape(sample['e2_multi'])[0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "output_shape": {
                    "value": "[self.num_ent]",
                    "type": "List",
                    "possible_values": []
                },
                "validate_indices": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_294": {
                "variable": {
                    "value": "correct_e2s_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sample['e2_multi']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_299": {
                "variable": {
                    "value": "neg_indexes",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "shuffled_e2s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_shuffle(tf.range(self.num_ent, dtype=tf.int64))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "neg_start[:, None] + tf.range(num_negative_labels)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_302": {
                "variable": {
                    "value": "indexes",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sample['e2_multi'][:, None], neg_indexes]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_303": {
                "variable": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "e2_multi_dense",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse_to_dense(sparse_indices=sample['e2_multi'][:, None], sparse_values=tf.ones([tf.shape(sample['e2_multi'])[0]]), output_shape=[self.num_ent], validate_indices=False)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indexes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.less_equal(num_positives, num_positives_needed), _less_positives, _more_positives)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample['e2_multi'][:, None], neg_indexes], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_to_dense_318": {
                "variable": {
                    "value": "e2_multi",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse_indices": {
                    "value": "sample['e2_multi'][:, None]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "conve_parser(sample)",
                            "Call"
                        ],
                        [
                            "parser(sample)",
                            "Call"
                        ],
                        [
                            "json.loads(line)",
                            "Call"
                        ],
                        [
                            "{'e1': e1, 'e2': 'None', 'rel': rel, 'e2_multi': ' '.join(list(value))}",
                            "Dict"
                        ],
                        [
                            "{'e1': e1, 'e2': e2, 'rel': rel, 'e2_multi': e2_multi}",
                            "Dict"
                        ],
                        [
                            "full_data",
                            "variable"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ]
                    ]
                },
                "sparse_values": {
                    "value": "tf.ones([tf.shape(sample['e2_multi'])[0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "output_shape": {
                    "value": "[self.num_ent]",
                    "type": "List",
                    "possible_values": []
                },
                "validate_indices": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_323": {
                "variable": {
                    "value": "lookup_values",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(0,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Features_587": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "feature": {
                    "value": "{'e1': _int64([e1]), 'e2': _int64([e2]), 'rel': _int64([rel]), 'e2_multi': _int64(e2_multi), 'is_inverse': _int64([sample['rel'].endswith('_reverse')])}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "sparse_to_dense_182": {
                "variable": {
                    "value": "e2_multi",
                    "type": "variable",
                    "possible_values": []
                },
                "sparse_indices": {
                    "value": "sample['e2_multi'][:, None]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "conve_parser(sample)",
                            "Call"
                        ],
                        [
                            "parser(sample)",
                            "Call"
                        ],
                        [
                            "json.loads(line)",
                            "Call"
                        ],
                        [
                            "{'e1': e1, 'e2': 'None', 'rel': rel, 'e2_multi': ' '.join(list(value))}",
                            "Dict"
                        ],
                        [
                            "{'e1': e1, 'e2': e2, 'rel': rel, 'e2_multi': e2_multi}",
                            "Dict"
                        ],
                        [
                            "full_data",
                            "variable"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ],
                        [
                            "sample",
                            "Method Argument"
                        ]
                    ]
                },
                "sparse_values": {
                    "value": "tf.ones([tf.shape(sample['e2_multi'])[0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "output_shape": {
                    "value": "[self.num_ent]",
                    "type": "List",
                    "possible_values": []
                },
                "validate_indices": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_207": {
                "variable": {
                    "value": "lookup_values",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(0,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_258": {
                "variable": {
                    "value": "num_neg",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "num_negatives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(wrong_e2s)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_negatives_needed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_labels - num_positives_needed",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Example_594": {
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'e1': tf.FixedLenFeature([], tf.int64), 'e2': tf.FixedLenFeature([], tf.int64), 'rel': tf.FixedLenFeature([], tf.int64), 'e2_multi': tf.FixedLenSequenceFeature([], tf.int64, allow_missing=True), 'is_inverse': tf.FixedLenFeature([], tf.int64)}",
                            "Dict"
                        ],
                        [
                            "tf.train.Features(feature={'e1': _int64([e1]), 'e2': _int64([e2]), 'rel': _int64([rel]), 'e2_multi': _int64(e2_multi), 'is_inverse': _int64([sample['rel'].endswith('_reverse')])})",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_not_116": {
                "x": {
                    "value": "sample['is_inverse']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "logical_not_196": {
                "x": {
                    "value": "sample['is_inverse']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_251": {
                "values": {
                    "value": "[correct_e2s[:num_positives], neg_indexes]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_262": {
                "values": {
                    "value": "[correct_e2s[:num_pos], neg_indexes]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_equal_267": {
                "x": {
                    "value": "num_positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(correct_e2s)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_positives_needed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(1.0 / (1.0 + prop_negatives) * num_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_276": {
                "params": {
                    "value": "e2s_dense",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sparse_to_dense(sparse_indices=correct_e2s[:, None], sparse_values=tf.ones([tf.shape(correct_e2s)[0]]), output_shape=[self.num_ent], validate_indices=False)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indexes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.less_equal(num_positives, num_positives_needed), _less_positives, _more_positives)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample['e2_multi'][:, None], neg_indexes], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "range_292": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_308": {
                "input": {
                    "value": "sample['e1'][None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_correct_e2s]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_309": {
                "input": {
                    "value": "sample['e2'][None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_correct_e2s]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_310": {
                "input": {
                    "value": "sample['rel'][None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[num_correct_e2s]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_312": {
                "x": {
                    "value": "indexes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.less_equal(num_positives, num_positives_needed), _less_positives, _more_positives)",
                            "Call"
                        ],
                        [
                            "tf.concat([sample['e2_multi'][:, None], neg_indexes], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TFRecordWriter_367": {
                "variable": {
                    "value": "tf_records_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.filenames",
                            "Attribute"
                        ],
                        [
                            "self.filenames",
                            "Attribute"
                        ],
                        [
                            "os.path.join(directory, '{0}-{1}.tfrecords'.format(filetype, file_index))",
                            "Call"
                        ],
                        [
                            "os.path.join(directory, '{0}-{1}.tfrecords'.format(filetype, file_index))",
                            "Call"
                        ],
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "parse_single_example_397": {
                "serialized": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": [
                        [
                            "r",
                            "Method Argument"
                        ]
                    ]
                },
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'e1': tf.FixedLenFeature([], tf.int64), 'e2': tf.FixedLenFeature([], tf.int64), 'rel': tf.FixedLenFeature([], tf.int64), 'e2_multi': tf.FixedLenSequenceFeature([], tf.int64, allow_missing=True), 'is_inverse': tf.FixedLenFeature([], tf.int64)}",
                            "Dict"
                        ],
                        [
                            "tf.train.Features(feature={'e1': _int64([e1]), 'e2': _int64([e2]), 'rel': _int64([rel]), 'e2_multi': _int64(e2_multi), 'is_inverse': _int64([sample['rel'].endswith('_reverse')])})",
                            "Call"
                        ]
                    ]
                }
            },
            "Feature_584": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=values)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_113": {
                "x": {
                    "value": "sample['is_inverse']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_193": {
                "x": {
                    "value": "sample['is_inverse']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_232": {
                "shape": {
                    "value": "[tf.shape(correct_e2s)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_282": {
                "shape": {
                    "value": "[tf.shape(sample['e2_multi'])[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_301": {},
            "ones_320": {
                "shape": {
                    "value": "[tf.shape(sample['e2_multi'])[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "FixedLenFeature_392": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_393": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_394": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_395": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_missing": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "FixedLenFeature_396": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unbatch_147": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_184": {
                "shape": {
                    "value": "[tf.shape(sample['e2_multi'])[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Int64List_585": {
                "value": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(e2_multi_dense, indexes)",
                            "Call"
                        ],
                        [
                            "values",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TFRecordWriter_384": {
                "variable": {
                    "value": "tf_records_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.filenames",
                            "Attribute"
                        ],
                        [
                            "self.filenames",
                            "Attribute"
                        ],
                        [
                            "os.path.join(directory, '{0}-{1}.tfrecords'.format(filetype, file_index))",
                            "Call"
                        ],
                        [
                            "os.path.join(directory, '{0}-{1}.tfrecords'.format(filetype, file_index))",
                            "Call"
                        ],
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_232": {
                "input": {
                    "value": "correct_e2s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sample['e2_multi']",
                            "Subscript"
                        ],
                        [
                            "tf.random_shuffle(correct_e2s)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_282": {
                "input": {
                    "value": "sample['e2_multi']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_320": {
                "input": {
                    "value": "sample['e2_multi']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_184": {
                "input": {
                    "value": "sample['e2_multi']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_ConvE/qa_cpg/metrics.py": {
        "tensorflow": {}
    },
    "CoPER_ConvE/qa_cpg/models.py": {
        "tensorflow": {
            "reduce_mean_22": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_70": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.projections[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_73": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1] + self.shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_74": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_85": {
                "variable": {
                    "value": "self.param_lookup_matrix",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_discrete_params, self.param_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "embedding_lookup_91": {
                "variable": {
                    "value": "desired_params",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.param_lookup_matrix",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "one_hots",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hots",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "self.name + '_matrix'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_92": {
                "variable": {
                    "value": "desired_params_shaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "desired_params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(self.param_lookup_matrix, one_hots, name=self.name + '_matrix')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1] + self.output_shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_93": {
                "variable": {
                    "value": "desired_params_shaped",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "desired_params_shaped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(desired_params, [-1] + self.output_shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(desired_params_shaped, self.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_with_default_158": {
                "variable": {
                    "value": "self.is_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "is_train",
                    "type": "str",
                    "possible_values": []
                }
            },
            "embedding_lookup_176": {
                "variable": {
                    "value": "conve_e1_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "ent_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['ent_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable(name='ent_emb', dtype=tf.float32, shape=[self.num_ent, self.ent_emb_size], initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "self.variables['ent_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(self.variables['ent_emb'], ent_indices)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "self.e1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "e1_emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_196": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_all_201": {
                "variable": {
                    "value": "self.summaries",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_205": {
                "variable": {
                    "value": "ent_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ent_emb",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_ent, self.ent_emb_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_312": {
                "variable": {
                    "value": "pred_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "pred_bias",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_ent]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_355": {
                "variable": {
                    "value": "e1_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "e1_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(e1_emb, [-1, 10, self.ent_emb_size // 10, 1])",
                            "Call"
                        ],
                        [
                            "e1_emb",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 10, self.ent_emb_size // 10, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_357": {
                "variable": {
                    "value": "is_train_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.is_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_21": {
                "name": {
                    "value": "name + '/summaries'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_23": {
                "name": {
                    "value": "mean",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_25": {
                "variable": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(tf.square(tensor - mean))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_26": {
                "name": {
                    "value": "stddev",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(tf.reduce_mean(tf.square(tensor - mean)))",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_27": {
                "name": {
                    "value": "max",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_max(tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_28": {
                "name": {
                    "value": "min",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_min(tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "histogram_29": {
                "name": {
                    "value": "histogram",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_60": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "projection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "projection in enumerate(self.projections[:-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_66": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_67": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1 - self.dropout * tf.cast(is_train, tf.float32)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_135": {
                "variable": {
                    "value": "self.input_iterator_handle",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "input_iterator_handle",
                    "type": "str",
                    "possible_values": []
                }
            },
            "embedding_lookup_178": {
                "variable": {
                    "value": "conve_rel_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "rel_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['rel_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable(name='rel_emb', dtype=tf.float32, shape=[self.num_rel, self.rel_emb_size], initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "rel_emb",
                            "Method Argument"
                        ],
                        [
                            "rel_emb",
                            "Method Argument"
                        ],
                        [
                            "rel_emb",
                            "Method Argument"
                        ]
                    ]
                },
                "ids": {
                    "value": "self.rel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "rel_emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_199": {
                "variable": {
                    "value": "(gradients, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "zip(*optimizer.compute_gradients(self.loss))",
                            "Call"
                        ],
                        [
                            "tf.clip_by_global_norm(gradients, 5.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "5.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "get_variable_211": {
                "variable": {
                    "value": "rel_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "rel_emb",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_rel, self.rel_emb_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_252": {
                "variable": {
                    "value": "conv1_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "conv1_weights",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.conv_filter_height, self.conv_filter_width, 1, self.conv_num_channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_256": {
                "variable": {
                    "value": "conv1_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "conv1_bias",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.conv_num_channels]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_305": {
                "variable": {
                    "value": "fc_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "fc_weights",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[fc_input_size, self.ent_emb_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_309": {
                "variable": {
                    "value": "fc_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "fc_bias",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.ent_emb_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_361": {
                "variable": {
                    "value": "reshaped_rel_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "rel_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['rel_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable(name='rel_emb', dtype=tf.float32, shape=[self.num_rel, self.rel_emb_size], initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "rel_emb",
                            "Method Argument"
                        ],
                        [
                            "rel_emb",
                            "Method Argument"
                        ],
                        [
                            "rel_emb",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 10, self.rel_emb_size // 10, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_362": {
                "variable": {
                    "value": "stacked_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[e1_emb, reshaped_rel_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_normalization_386": {
                "variable": {
                    "value": "conv1_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv1_plus_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv1 + bias[:, None, None, :]",
                            "BinOp"
                        ],
                        [
                            "conv1 + bias",
                            "BinOp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "self.batch_norm_momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_train_batch_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "is_train if self.batch_norm_train_stats else False",
                            "IfExp"
                        ],
                        [
                            "self.is_train if self.batch_norm_train_stats else False",
                            "IfExp"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "Conv1BN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_389": {
                "variable": {
                    "value": "conv1_relu",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv1_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(conv1_plus_bias, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='Conv1BN')",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_390": {
                "variable": {
                    "value": "conv1_dropout",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv1_relu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(conv1_bn)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1 - self.hidden_dropout * is_train_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_404": {
                "variable": {
                    "value": "fc_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv1_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(conv1_relu, 1 - self.hidden_dropout * is_train_float)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_414": {
                "variable": {
                    "value": "fc_dropout",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "fc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(fc_input, weights) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(fc_input[:, None, :], weights)[:, 0, :] + bias",
                            "BinOp"
                        ]
                    ]
                },
                "rate": {
                    "value": "1 - self.output_dropout * is_train_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "batch_normalization_416": {
                "variable": {
                    "value": "fc_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "fc_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(fc, 1 - self.output_dropout * is_train_float)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "self.batch_norm_momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_train_batch_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "is_train if self.batch_norm_train_stats else False",
                            "IfExp"
                        ],
                        [
                            "self.is_train if self.batch_norm_train_stats else False",
                            "IfExp"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "FCBN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_419": {
                "variable": {
                    "value": "fc_bn",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "fc_bn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(fc_dropout, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='FCBN')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(fc_bn)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_451": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.sigmoid_cross_entropy(targets, predictions)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_24": {
                "name": {
                    "value": "stddev",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_max_27": {
                "input_tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_min_28": {
                "input_tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_63": {
                "variable": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "generated_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "context",
                            "variable"
                        ],
                        [
                            "tf.matmul(generated_value, projection)",
                            "Call"
                        ],
                        [
                            "tf.matmul(generated_value, self.projections[-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(generated_value, [-1] + self.shape)",
                            "Call"
                        ],
                        [
                            "tf.cast(generated_value, self.dtype)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(generated_value, momentum=self.batch_norm_momentum, reuse=tf.AUTO_REUSE, training=is_train_batch_norm, fused=True, name='%s/CPG/Projection%d/BatchNorm' % (self.name, i))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(generated_value)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(generated_value, 1 - self.dropout * tf.cast(is_train, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "self.batch_norm_momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_train_batch_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "is_train if self.batch_norm_train_stats else False",
                            "IfExp"
                        ],
                        [
                            "self.is_train if self.batch_norm_train_stats else False",
                            "IfExp"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "'%s/CPG/Projection%d/BatchNorm' % (self.name, i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_134": {
                "device_name": {
                    "value": "/CPU:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_169": {
                "name_or_scope": {
                    "value": "variables",
                    "type": "str",
                    "possible_values": []
                },
                "use_resource": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "control_dependencies_197": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_372": {
                "name": {
                    "value": "conv1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_382": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stacked_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([e1_emb, reshaped_rel_emb], 1)",
                            "Call"
                        ],
                        [
                            "e1_emb",
                            "variable"
                        ]
                    ]
                },
                "filter": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['conv1_weights']",
                            "Subscript"
                        ],
                        [
                            "weights.generate(rel_emb, is_train)",
                            "Call"
                        ],
                        [
                            "self.variables['fc_weights']",
                            "Subscript"
                        ],
                        [
                            "weights.generate(rel_emb, is_train)",
                            "Call"
                        ],
                        [
                            "self._get_conv_params(rel_emb, self.is_train)",
                            "Call"
                        ],
                        [
                            "self._get_fc_params(rel_emb, self.is_train)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_400": {
                "name": {
                    "value": "fc_layer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_407": {
                "variable": {
                    "value": "fc_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fc_input, rel_emb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_432": {
                "name": {
                    "value": "output_layer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_435": {
                "variable": {
                    "value": "ent_emb_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "ent_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['ent_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable(name='ent_emb', dtype=tf.float32, shape=[self.num_ent, self.ent_emb_size], initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "self.variables['ent_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(self.variables['ent_emb'], ent_indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_436": {
                "variable": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "predicted_e2_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "predicted_e2_emb",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "ent_emb_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(ent_emb)",
                            "Call"
                        ],
                        [
                            "tf.transpose(ent_emb, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_439": {
                "variable": {
                    "value": "ent_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.variables['ent_emb']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "ent_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_440": {
                "variable": {
                    "value": "ent_emb_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "ent_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['ent_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable(name='ent_emb', dtype=tf.float32, shape=[self.num_ent, self.ent_emb_size], initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "self.variables['ent_emb']",
                            "Subscript"
                        ],
                        [
                            "tf.gather(self.variables['ent_emb'], ent_indices)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_442": {
                "variable": {
                    "value": "pred_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.variables['pred_bias']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "ent_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_449": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_25": {
                "input_tensor": {
                    "value": "tf.square(tensor - mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_49": {
                "name": {
                    "value": "'%s/CPG/Projection%d' % (name, i)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[in_size, n]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initializer",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_initializer_314": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_402": {
                "input": {
                    "value": "conv1_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(conv1_relu, 1 - self.hidden_dropout * is_train_float)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_452": {
                "multi_class_labels": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1 - self.label_smoothing_epsilon) * targets + 1.0 / self.num_ent",
                            "BinOp"
                        ],
                        [
                            "targets",
                            "Method Argument"
                        ]
                    ]
                },
                "logits": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(predicted_e2_emb, ent_emb_t, name=name)",
                            "Call"
                        ],
                        [
                            "predictions + pred_bias",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(predicted_e2_emb[:, None, :], ent_emb_t, name=name)[:, 0, :]",
                            "Subscript"
                        ],
                        [
                            "predictions",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_456": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.losses.sigmoid_cross_entropy(targets, predictions), name='loss')",
                            "Call"
                        ]
                    ]
                }
            },
            "square_25": {
                "x": {
                    "value": "tensor - mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_initializer_258": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_311": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "map_fn_379": {
                "fn": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "(stacked_emb, weights)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "matmul_410": {
                "a": {
                    "value": "fc_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(conv1_dropout, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.concat([fc_input, rel_emb], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['conv1_weights']",
                            "Subscript"
                        ],
                        [
                            "weights.generate(rel_emb, is_train)",
                            "Call"
                        ],
                        [
                            "self.variables['fc_weights']",
                            "Subscript"
                        ],
                        [
                            "weights.generate(rel_emb, is_train)",
                            "Call"
                        ],
                        [
                            "self._get_conv_params(rel_emb, self.is_train)",
                            "Call"
                        ],
                        [
                            "self._get_fc_params(rel_emb, self.is_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_441": {
                "a": {
                    "value": "predicted_e2_emb[:, None, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "ent_emb_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(ent_emb)",
                            "Call"
                        ],
                        [
                            "tf.transpose(ent_emb, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ],
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_68": {
                "x": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "is_train",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "is_train",
                            "Method Argument"
                        ],
                        [
                            "is_train",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_248": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_301": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_378": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_412": {
                "a": {
                    "value": "fc_input[:, None, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.variables['conv1_weights']",
                            "Subscript"
                        ],
                        [
                            "weights.generate(rel_emb, is_train)",
                            "Call"
                        ],
                        [
                            "self.variables['fc_weights']",
                            "Subscript"
                        ],
                        [
                            "weights.generate(rel_emb, is_train)",
                            "Call"
                        ],
                        [
                            "self._get_conv_params(rel_emb, self.is_train)",
                            "Call"
                        ],
                        [
                            "self._get_fc_params(rel_emb, self.is_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_376": {
                "input": {
                    "value": "pair[0][None]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "pair",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "pair[1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "pair",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_ConvE/qa_cpg/run_cpg.py": {
        "tensorflow": {
            "ConfigProto_186": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_188": {
                "variable": {
                    "value": "session",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_189": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_190": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "summaries_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(working_dir, 'summaries', model_name)",
                            "Call"
                        ]
                    ]
                },
                "graph": {
                    "value": "session.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Summary_26": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_111": {
                "device_name": {
                    "value": "cfg.training.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_193": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_114": {
                "name_or_scope": {
                    "value": "variables",
                    "type": "str",
                    "possible_values": []
                },
                "use_resource": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_ConvE/qa_cpg/utils/amsgrad.py": {
        "tensorflow": {
            "convert_to_tensor_122": {
                "variable": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_123": {
                "variable": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._beta1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "beta1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_124": {
                "variable": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._beta2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "beta2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_125": {
                "variable": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "epsilon",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_131": {
                "variable": {
                    "value": "beta1_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_132": {
                "variable": {
                    "value": "beta2_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_133": {
                "variable": {
                    "value": "lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_134": {
                "variable": {
                    "value": "beta1_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_135": {
                "variable": {
                    "value": "beta2_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_136": {
                "variable": {
                    "value": "epsilon_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_142": {
                "variable": {
                    "value": "m_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "m * beta1_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_149": {
                "variable": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "v * beta2_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_155": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_sub_156": {
                "variable": {
                    "value": "var_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "lr * m_t / (v_sqrt + epsilon_t)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_162": {
                "variable": {
                    "value": "beta1_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_163": {
                "variable": {
                    "value": "beta2_power",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_power",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_164": {
                "variable": {
                    "value": "lr_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._lr_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_165": {
                "variable": {
                    "value": "beta1_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta1_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_166": {
                "variable": {
                    "value": "beta2_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._beta2_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_167": {
                "variable": {
                    "value": "epsilon_t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._epsilon_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "var.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_172": {
                "variable": {
                    "value": "m_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'm')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "m * beta1_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_179": {
                "variable": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "v * beta2_t",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_185": {
                "variable": {
                    "value": "v_sqrt",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_sub_186": {
                "variable": {
                    "value": "var_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ],
                        [
                            "var",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "lr * m_t / (v_sqrt + epsilon_t)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_159": {
                "*inputs": {
                    "value": "*[var_update, m_t, v_t]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_189": {
                "*inputs": {
                    "value": "*[var_update, m_t, v_t]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_240": {
                "*inputs": {
                    "value": "*update_ops + [update_beta1, update_beta2]",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "name_scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name_scope",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "control_dependencies_143": {
                "control_inputs": {
                    "value": "[m_t]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_150": {
                "control_inputs": {
                    "value": "[v_t]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_154": {
                "x": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "v + v_scaled_g",
                            "BinOp"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_174": {
                "control_inputs": {
                    "value": "[m_t]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_180": {
                "control_inputs": {
                    "value": "[v_t]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_184": {
                "x": {
                    "value": "v_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v_hat')",
                            "Call"
                        ],
                        [
                            "v_hat.assign(tf.maximum(v_hat, v_t))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "v_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "v + v_scaled_g",
                            "BinOp"
                        ],
                        [
                            "state_ops.assign(v, v * beta2_t, use_locking=self._use_locking)",
                            "Call"
                        ],
                        [
                            "scatter_add(v, indices, v_scaled_g_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_198": {
                "control_inputs": {
                    "value": "[resource_variable_ops.resource_scatter_add(x.handle, i, v)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_232": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "update_ops",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "colocate_with_108": {
                "op": {
                    "value": "first_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(var_list, key=lambda x: x.name)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_137": {
                "x": {
                    "value": "1 - beta2_power",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_168": {
                "x": {
                    "value": "1 - beta2_power",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scatter_add_194": {
                "ref": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "i",
                            "Method Argument"
                        ]
                    ]
                },
                "updates": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_list",
                            "variable"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "self.get_slot(var, 'v')",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "self._use_locking",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "colocate_with_233": {
                "op": {
                    "value": "self._beta1_power",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/emb/emb.py": {
        "torch": {
            "BCELoss_26": {
                "variable": {
                    "value": "self.loss_fun",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_85": {
                "variable": {
                    "value": "subject_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "subject_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "cat_103": {
                "variable": {
                    "value": "object_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "object_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "cat_43": {
                "tensors": {
                    "value": "pred_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "mdl.forward(e1, r, kg)",
                            "Call"
                        ],
                        [
                            "mdl.forward(e1, r, kg, [self.secondary_kg])",
                            "Call"
                        ],
                        [
                            "mdl.forward(e1, r, kg, [self.secondary_kg, self.tertiary_kg])",
                            "Call"
                        ],
                        [
                            "mdl.forward(e1, r, kg)",
                            "Call"
                        ],
                        [
                            "mdl.forward(e1, r, kg)",
                            "Call"
                        ],
                        [
                            "mdl.forward_fact(e1, r, e2, kg)",
                            "Call"
                        ]
                    ]
                }
            },
            "sum_83": {
                "variable": {
                    "value": "subject_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "e1_space[i].unsqueeze(0) == answer_vector",
                    "type": "Compare",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_101": {
                "variable": {
                    "value": "object_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "e2_space[i].unsqueeze(0) == answer_vector",
                    "type": "Compare",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "save_112": {
                "obj": {
                    "value": "self.mdl.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "fn_state_dict_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.model_dir, 'fn_state_dict')",
                            "Call"
                        ]
                    ]
                }
            },
            "save_114": {
                "obj": {
                    "value": "self.kg.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "fn_kg_state_dict_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.model_dir, 'fn_kg_state_dict')",
                            "Call"
                        ]
                    ]
                }
            },
            "arange_174": {
                "start": {
                    "value": "kg.num_entities",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/emb/fact_network.py": {
        "torch": {
            "load_26": {
                "variable": {
                    "value": "conve_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.conve_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_56": {
                "variable": {
                    "value": "conve_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.conve_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_94": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(E1 * R, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "torch.sum(E1 * R * E2, dim=1, keepdim=True)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_113": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(E1 * R, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "torch.sum(E1 * R * E2, dim=1, keepdim=True)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ]
                    ]
                }
            },
            "Dropout_128": {
                "variable": {
                    "value": "self.HiddenDropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "args.hidden_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_129": {
                "variable": {
                    "value": "self.FeatureDropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "args.feat_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2d_132": {
                "variable": {
                    "value": "self.conv1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "self.num_out_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(self.w_d, self.w_d)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_133": {
                "variable": {
                    "value": "self.bn0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_134": {
                "variable": {
                    "value": "self.bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.num_out_channels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "BatchNorm1d_135": {
                "variable": {
                    "value": "self.bn2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.entity_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_140": {
                "variable": {
                    "value": "self.fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.feat_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.entity_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_147": {
                "variable": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E1, R]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_152": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_158": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "mm_159": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "E2.transpose(1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_162": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_181": {
                "variable": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E1, R]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_186": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_192": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_193": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "E2.unsqueeze(2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_193": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_196": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "mm_207": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "E1 * R",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mat2": {
                    "value": "E2.transpose(1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_208": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(E1 * R, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "torch.sum(E1 * R * E2, dim=1, keepdim=True)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ]
                    ]
                }
            },
            "sum_215": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "E1 * R * E2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sigmoid_216": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "rrr + rii + iri - iir",
                            "BinOp"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(E1 * R, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "torch.sum(E1 * R * E2, dim=1, keepdim=True)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(S)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ],
                        [
                            "F.sigmoid(X)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_253": {
                "variable": {
                    "value": "self.network",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.projections",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Dropout_288": {
                "variable": {
                    "value": "self.HiddenDropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "args.hidden_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_289": {
                "variable": {
                    "value": "self.FeatureDropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "args.feat_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "BatchNorm2d_294": {
                "variable": {
                    "value": "self.bn0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "BatchNorm2d_295": {
                "variable": {
                    "value": "self.bn1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.num_out_channels",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "BatchNorm1d_296": {
                "variable": {
                    "value": "self.bn2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_features": {
                    "value": "self.entity_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_365": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_385": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "mm_386": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "E2.transpose(1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_389": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_423": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_434": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_435": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "E2.unsqueeze(2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_435": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_438": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "Conv2d_293": {
                "variable": {
                    "value": "self.conv1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "self.num_out_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(self.w_d, self.w_d)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_309": {
                "variable": {
                    "value": "self.fc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.feat_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.entity_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_350": {
                "variable": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E1, R]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv2d_359": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "E1",
                            "variable"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "E1",
                            "variable"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.conv_filter(R)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "self.conv_bias(R)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_379": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij, ijk-> ik",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_411": {
                "variable": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E1, R]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv2d_417": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stacked_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "E1",
                            "variable"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "torch.cat([E1, R], 2)",
                            "Call"
                        ],
                        [
                            "E1",
                            "variable"
                        ],
                        [
                            "self.bn0(stacked_inputs)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.conv_filter(R)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "self.conv_bias(R)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_428": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij, ijk-> ik",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "X + self.b[e2].unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.mm(X, E2.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "nn.functional.conv2d(input=stacked_inputs, weight=self.conv_filter(R), bias=self.conv_bias(R))",
                            "Call"
                        ],
                        [
                            "self.conv1(stacked_inputs)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.FeatureDropout(X)",
                            "Call"
                        ],
                        [
                            "X.view(-1, self.feat_dim)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij, ijk-> ik', X, fc_weights)",
                            "Call"
                        ],
                        [
                            "self.fc(X)",
                            "Call"
                        ],
                        [
                            "self.HiddenDropout(X)",
                            "Call"
                        ],
                        [
                            "self.bn2(X)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "torch.matmul(X.unsqueeze(1), E2.unsqueeze(2)).squeeze(2)",
                            "Call"
                        ]
                    ]
                }
            },
            "mm_80": {
                "input": {
                    "value": "E1 * R",
                    "type": "BinOp",
                    "possible_values": []
                },
                "mat2": {
                    "value": "E2.transpose(1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_99": {
                "input": {
                    "value": "E1 * R * E2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_136": {
                "data": {
                    "value": "torch.zeros(num_entities)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_252": {
                "in_features": {
                    "value": "layer_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network_structure[0]",
                            "Subscript"
                        ],
                        [
                            "layer_output",
                            "variable"
                        ]
                    ]
                },
                "out_features": {
                    "value": "self.flattened_output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_297": {
                "data": {
                    "value": "torch.zeros(num_entities)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_136": {
                "*size": {
                    "value": "num_entities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_entities",
                            "Method Argument"
                        ],
                        [
                            "num_entities",
                            "Method Argument"
                        ],
                        [
                            "num_entities",
                            "Method Argument"
                        ],
                        [
                            "num_entities",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_244": {
                "in_features": {
                    "value": "layer_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network_structure[0]",
                            "Subscript"
                        ],
                        [
                            "layer_output",
                            "variable"
                        ]
                    ]
                },
                "out_features": {
                    "value": "layer_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.network_structure[1:]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_248": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dropout_249": {
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_297": {
                "*size": {
                    "value": "num_entities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_entities",
                            "Method Argument"
                        ],
                        [
                            "num_entities",
                            "Method Argument"
                        ],
                        [
                            "num_entities",
                            "Method Argument"
                        ],
                        [
                            "num_entities",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "BatchNorm1d_246": {
                "num_features": {
                    "value": "layer_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.network_structure[1:]",
                            "Subscript"
                        ]
                    ]
                },
                "momentum": {
                    "value": "batch_norm_momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.99",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "CoPER_MINERVA/src/eval.py": {
        "torch": {
            "topk_68": {
                "variable": {
                    "value": "(top_k_scores, top_k_targets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "min(scores.size(1), args.beam_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "topk_205": {
                "variable": {
                    "value": "(top_k_scores, top_k_targets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "min(scores.size(1), args.beam_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "topk_342": {
                "variable": {
                    "value": "(top_k_scores, top_k_targets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ],
                        [
                            "scores",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "min(scores.size(1), args.beam_size)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/experiments.py": {
        "torch": {
            "set_device_35": {
                "device": {
                    "value": "args.gpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "manual_seed_37": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "manual_seed_all_38": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_281": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_538": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_562": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_404": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_grad_enabled_629": {
                "mode": {
                    "value": "args.train or args.search_random_seed or args.grid_search",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "load_283": {
                "f": {
                    "value": "args.conve_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_285": {
                "f": {
                    "value": "args.complex_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_288": {
                "f": {
                    "value": "args.conve_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_290": {
                "f": {
                    "value": "args.complex_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_292": {
                "f": {
                    "value": "args.distmult_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "manual_seed_658": {
                "seed": {
                    "value": "random_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random.randint(0, 1e+16)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "manual_seed_all_659": {
                "seed": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "parser.parse_args()",
                            "Call"
                        ],
                        [
                            "data_utils.load_configs(args, config_path)",
                            "Call"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ],
                        [
                            "args",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "memory_allocated_361": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_367": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_370": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_372": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_382": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_384": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/knowledge_graph.py": {
        "torch": {
            "Embedding_367": {
                "variable": {
                    "value": "self.relation_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.num_relations",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.relation_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_370": {
                "variable": {
                    "value": "self.RDropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.emb_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_146": {
                "variable": {
                    "value": "action_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "bucket_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(action_space_list)",
                            "Call"
                        ],
                        [
                            "len(unique_r_space_list)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "action_space_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "action_space_size",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_168": {
                "variable": {
                    "value": "self.entity2bucketid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.num_entities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Embedding_363": {
                "variable": {
                    "value": "self.entity_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.num_entities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.entity_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_366": {
                "variable": {
                    "value": "self.EDropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.emb_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Embedding_369": {
                "variable": {
                    "value": "self.relation_img_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.num_relations",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.relation_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Embedding_365": {
                "variable": {
                    "value": "self.entity_img_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.num_entities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.entity_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_144": {
                "*size": {
                    "value": "bucket_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(action_space_list)",
                            "Call"
                        ],
                        [
                            "len(unique_r_space_list)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "action_space_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "action_space_size",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_145": {
                "*size": {
                    "value": "bucket_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(action_space_list)",
                            "Call"
                        ],
                        [
                            "len(unique_r_space_list)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "action_space_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "action_space_size",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_156": {
                "*size": {
                    "value": "bucket_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(action_space_list)",
                            "Call"
                        ],
                        [
                            "len(unique_r_space_list)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "unique_r_space_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unique_r_space_size",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unsqueeze_267": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/learn_framework.py": {
        "torch": {
            "cat_255": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "pred_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "Adam_70": {
                "variable": {
                    "value": "self.optim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "filter(lambda p: p.requires_grad, self.parameters())",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_334": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "input_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_file",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "save_322": {
                "obj": {
                    "value": "checkpoint_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dict()",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "out_tar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.model_dir, 'checkpoint-{}.tar'.format(checkpoint_id))",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_88": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "clip_grad_norm__125": {
                "parameters": {
                    "value": "self.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "self.grad_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_143": {
                "variable": {
                    "value": "rewards",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[rewards, loss['reward']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_147": {
                "variable": {
                    "value": "fns",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[fns, loss['fn']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "no_grad_169": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_170": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_172": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_179": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_89": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_91": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "memory_allocated_93": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/lstm_pg.py": {
        "torch": {
            "LSTM_214": {
                "variable": {
                    "value": "rnn",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "randn_216": {
                "variable": {
                    "value": "h0",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randn_217": {
                "variable": {
                    "value": "c0",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rand_218": {
                "variable": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rand_243": {
                "variable": {
                    "value": "context",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ModuleList_35": {
                "variable": {
                    "value": "self.projections",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Sequential_56": {
                "variable": {
                    "value": "self.network",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*self.projections",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "ModuleList_98": {
                "variable": {
                    "value": "self.dropouts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_100": {
                "variable": {
                    "value": "self.weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_101": {
                "variable": {
                    "value": "self.biases",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_103": {
                "variable": {
                    "value": "self.all_gates",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_165": {
                "variable": {
                    "value": "cell_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(input, hidden_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sigmoid_176": {
                "variable": {
                    "value": "input_gate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_gate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "all_gates.chunk(4, -1)",
                            "Call"
                        ],
                        [
                            "torch.sigmoid(input_gate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_177": {
                "variable": {
                    "value": "forget_gate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "forget_gate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "all_gates.chunk(4, -1)",
                            "Call"
                        ],
                        [
                            "torch.sigmoid(forget_gate)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_178": {
                "variable": {
                    "value": "add_gate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "add_gate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "all_gates.chunk(4, -1)",
                            "Call"
                        ],
                        [
                            "torch.tanh(add_gate)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_179": {
                "variable": {
                    "value": "output_gate",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output_gate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "all_gates.chunk(4, -1)",
                            "Call"
                        ],
                        [
                            "torch.sigmoid(output_gate)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_52": {
                "in_features": {
                    "value": "layer_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network_structure[0]",
                            "Subscript"
                        ],
                        [
                            "layer_output",
                            "variable"
                        ]
                    ]
                },
                "out_features": {
                    "value": "self.flattened_output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_130": {
                "variable": {
                    "value": "all_gates",
                    "type": "variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.input_size + self.hidden_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "4 * self.hidden_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_197": {
                "variable": {
                    "value": "hidden_states",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(hidden_states, hidden_state_)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_198": {
                "variable": {
                    "value": "cell_states",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(cell_states, cell_state_)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_40": {
                "in_features": {
                    "value": "layer_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network_structure[0]",
                            "Subscript"
                        ],
                        [
                            "layer_output",
                            "variable"
                        ]
                    ]
                },
                "out_features": {
                    "value": "layer_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.network_structure[1:]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Dropout_49": {
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_182": {
                "input": {
                    "value": "cell_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "past_cell_states[:, layer, :]",
                            "Subscript"
                        ],
                        [
                            "cell_state * forget_gate + input_gate * add_gate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "BatchNorm1d_44": {
                "num_features": {
                    "value": "layer_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.network_structure[1:]",
                            "Subscript"
                        ]
                    ]
                },
                "momentum": {
                    "value": "batch_norm_momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.99",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Dropout_136": {
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_169": {
                "equation": {
                    "value": "ij,ijk->ik",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "(cell_input, weights)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/rl/graph_search/beam_search.py": {
        "torch": {
            "topk_55": {
                "variable": {
                    "value": "(log_action_prob, action_ind)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "log_action_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_action_prob.view(-1, 1) + ops.safe_log(action_dist)",
                            "BinOp"
                        ],
                        [
                            "log_action_dist.view(batch_size, -1)",
                            "Call"
                        ],
                        [
                            "log_action_dist.view(batch_size, -1)",
                            "Call"
                        ],
                        [
                            "log_action_dist",
                            "Method Argument"
                        ],
                        [
                            "log_action_dist",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(e.size()[0] / batch_size)",
                            "Call"
                        ],
                        [
                            "k in enumerate(log_action_probs)",
                            "Call"
                        ],
                        [
                            "min(beam_size, beam_action_space_size)",
                            "Call"
                        ],
                        [
                            "min(beam_size, beam_action_space_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_169": {
                "variable": {
                    "value": "seen_nodes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[seen_nodes[action_offset], action[1].unsqueeze(1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "topk_103": {
                "variable": {
                    "value": "(top_unique_log_action_dist, top_unique_idx2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "unique_log_action_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unique_max(unique_e_space_b, e_space_b, log_action_dist_b)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "k_prime",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(len(unique_e_space_b), k)",
                            "Call"
                        ]
                    ]
                }
            },
            "unique_100": {
                "input": {
                    "value": "e_space_b.data.cpu()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "arange_64": {
                "start": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(e_s)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "CoPER_MINERVA/src/rl/graph_search/pg.py": {
        "torch": {
            "cat_84": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[x.unsqueeze(1) for x in action_entropy]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_84": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_252": {
                "variable": {
                    "value": "path_trace_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "flattened_path_trace",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x for t in path_trace for x in t]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "reshape_252": {
                "variable": {
                    "value": "path_trace_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "path_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(path_trace)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_94": {
                "variable": {
                    "value": "fn",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "final_reward.size()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_141": {
                "variable": {
                    "value": "seen_nodes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[seen_nodes, e.unsqueeze(1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_191": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sample_action_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "action_dist * action_keep_mask + ops.EPSILON * (1 - action_keep_mask) * action_mask",
                            "BinOp"
                        ],
                        [
                            "apply_action_dropout_mask(action_dist, action_mask)",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "replacement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "rand_176": {
                "variable": {
                    "value": "rand",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "action_dist.size()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_243": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "exp_246": {
                "variable": {
                    "value": "pred_scores[i][pred_e2s[i]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "pred_e2_scores[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "exp_81": {
                "input": {
                    "value": "log_action_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_action_probs[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cat_210": {
                "tensors": {
                    "value": "next_r_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_211": {
                "tensors": {
                    "value": "next_e_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_213": {
                "tensors": {
                    "value": "action_prob_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/rl/graph_search/pn.py": {
        "torch": {
            "relu_127": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([H, Q], dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.cat([E, H, E_s, Q], dim=-1)",
                            "Call"
                        ],
                        [
                            "self.W1(X)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij,ijk->ik', (X, self.pg_weights1(Q))) + self.pg_bias1(Q)",
                            "BinOp"
                        ],
                        [
                            "torch.cat([E, H], dim=-1)",
                            "Call"
                        ],
                        [
                            "torch.cat([E, H, Q], dim=-1)",
                            "Call"
                        ],
                        [
                            "F.relu(X)",
                            "Call"
                        ],
                        [
                            "self.W1Dropout(X)",
                            "Call"
                        ],
                        [
                            "self.W2(X)",
                            "Call"
                        ],
                        [
                            "torch.einsum('ij,ijk->ik', (X, self.pg_weights2(Q))) + self.pg_bias2(Q)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cat_393": {
                "variable": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "answer_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "Dropout_481": {
                "variable": {
                    "value": "self.W1Dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.ff_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_482": {
                "variable": {
                    "value": "self.W2Dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.ff_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_107": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[H, Q]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_139": {
                "variable": {
                    "value": "action_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.squeeze(A @ torch.unsqueeze(X2, 2), 2) - (1 - action_mask) * ops.HUGE_INT",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sum_391": {
                "variable": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "e_space[i].unsqueeze(0) == answer_vector",
                    "type": "Compare",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_434": {
                "variable": {
                    "value": "action_embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[relation_embedding, entity_embedding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Linear_478": {
                "variable": {
                    "value": "self.W2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.action_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.action_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_479": {
                "variable": {
                    "value": "self.W1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "input_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.history_dim + self.relation_dim",
                            "BinOp"
                        ],
                        [
                            "self.history_dim + self.entity_dim * 2 + self.relation_dim",
                            "BinOp"
                        ],
                        [
                            "self.history_dim + self.entity_dim + self.relation_dim",
                            "BinOp"
                        ]
                    ]
                },
                "out_features": {
                    "value": "self.action_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_111": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E, H, E_s, Q]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_203": {
                "variable": {
                    "value": "init_action_embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[init_relation_embedding, init_entity_embedding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_250": {
                "variable": {
                    "value": "action_embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[relation_embedding, entity_embedding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_115": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E, H]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_118": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[E, H, Q]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_125": {
                "equation": {
                    "value": "ij,ijk->ik",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "(X, self.pg_weights1(Q))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "einsum_132": {
                "equation": {
                    "value": "ij,ijk->ik",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "(X, self.pg_weights2(Q))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cat_171": {
                "tensors": {
                    "value": "entropy_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_140": {
                "input": {
                    "value": "A @ torch.unsqueeze(X2, 2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_140": {
                "input": {
                    "value": "X2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.W2Dropout(X)",
                            "Call"
                        ],
                        [
                            "X2",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/rl/graph_search/rs_pg.py": {
        "torch": {
            "load_34": {
                "variable": {
                    "value": "fn_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.conve_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_51": {
                "variable": {
                    "value": "complex_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.complex_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_94": {
                "tensors": {
                    "value": "pred_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "load_39": {
                "variable": {
                    "value": "fn_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.distmult_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_42": {
                "variable": {
                    "value": "fn_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.complex_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_45": {
                "variable": {
                    "value": "fn_state_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.conve_state_dict_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "CoPER_MINERVA/src/utils/ops.py": {
        "torch": {
            "exp_54": {
                "variable": {
                    "value": "exp_v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "v in enumerate(l)",
                            "Call"
                        ],
                        [
                            "v.unsqueeze(dim + 1)",
                            "Call"
                        ],
                        [
                            "torch.cat([v] * beam_size, dim=dim + 1)",
                            "Call"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ],
                        [
                            "v",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cat_158": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[v] * beam_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_201": {
                "variable": {
                    "value": "unique_values",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "unique_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(unique_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_202": {
                "variable": {
                    "value": "unique_idx",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "unique_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "randn_207": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randn_211": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_33": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": [
                        [
                            "M",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "index": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "idx",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "gather_35": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": [
                        [
                            "M",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "index": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "idx",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sum_50": {
                "input": {
                    "value": "-p * safe_log(p)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_138": {
                "tensors": {
                    "value": "padded_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_146": {
                "input": {
                    "value": "x + EPSILON",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sum_56": {
                "input": {
                    "value": "weighted_exp_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w * exp_v",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(v.size()) - 1",
                            "BinOp"
                        ],
                        [
                            "-1",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "keepdim": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ConstantPad1d_134": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "(0, res_len)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "padding_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "padding_value",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_113": {
                "*size": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_105": {
                "*size": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_109": {
                "*size": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    }
}