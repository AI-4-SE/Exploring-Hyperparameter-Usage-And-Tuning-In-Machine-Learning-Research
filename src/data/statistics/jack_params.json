{
    "jack/util/preprocessing.py": {
        "sklearn": {
            "TfidfVectorizer_183": {
                "variable": {
                    "value": "tfidf",
                    "type": "Variable",
                    "possible_values": []
                },
                "strip_accents": {
                    "value": "unicode",
                    "type": "Constant",
                    "possible_values": []
                },
                "stop_words": {
                    "value": "spacy.en.STOP_WORDS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decode_error": {
                    "value": "replace",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "pairwise_distances_190": {
                "variable": {
                    "value": "dists",
                    "type": "Variable",
                    "possible_values": []
                },
                "X": {
                    "value": "q_features",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tfidf.transform([reference])",
                            "Call"
                        ]
                    ]
                },
                "Y": {
                    "value": "para_features",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tfidf.fit_transform(candidates)",
                            "Call"
                        ]
                    ]
                },
                "metric": {
                    "value": "cosine",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "bin/create-squad-predictions.py": {
        "tensorflow": {
            "DEFINE_string_17": {
                "name": {
                    "value": "dataset",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "dataset file",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_18": {
                "name": {
                    "value": "loader",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "squad",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "either squad or jack",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_19": {
                "name": {
                    "value": "load_dir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "directory to saved model",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_20": {
                "name": {
                    "value": "out",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "results.json",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "Result file path.",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_21": {
                "name": {
                    "value": "batch_size",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "64",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "batch size",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_22": {
                "name": {
                    "value": "overwrite",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "{}",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "json string that can overwrite configuration.",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "bin/jack-eval.py": {
        "tensorflow": {
            "DEFINE_string_18": {
                "name": {
                    "value": "dataset",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "dataset file",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_19": {
                "name": {
                    "value": "loader",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "jack",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "name of loader",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_20": {
                "name": {
                    "value": "load_dir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "directory to saved model",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_21": {
                "name": {
                    "value": "batch_size",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "64",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "batch size",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_22": {
                "name": {
                    "value": "max_examples",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "maximum number of examples to evaluate",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_23": {
                "name": {
                    "value": "overwrite",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "{}",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "json string that overwrites configuration.",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "data/emoji2vec/visualize.py": {
        "tensorflow": {
            "constant_27": {
                "variable": {
                    "value": "emoji2vec",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.array(vecs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_28": {
                "variable": {
                    "value": "tf_emoji2vec",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "emoji2vec",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[len(vecs), 300]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_35": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_39": {
                "variable": {
                    "value": "summary_writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "dir",
                    "type": "Name",
                    "possible_values": [
                        [
                            "'./jack/data/emoji2vec/'",
                            "Constant"
                        ]
                    ]
                }
            },
            "Session_31": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "jack/core/tensorflow.py": {
        "tensorflow": {
            "trainable_variables_97": {
                "variable": {
                    "value": "old_train_variables",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_98": {
                "variable": {
                    "value": "old_variables",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_118": {
                "variable": {
                    "value": "self._saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "var_list": {
                    "value": "self._training_variables",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_global_step_225": {
                "variable": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_26": {
                "variable": {
                    "value": "session_config",
                    "type": "Variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Session_28": {
                "variable": {
                    "value": "session",
                    "type": "Variable",
                    "possible_values": []
                },
                "config": {
                    "value": "session_config",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_122": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "NewCheckpointReader_134": {
                "variable": {
                    "value": "reader",
                    "type": "Variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "load_dir",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.shared_resources.config.get('load_dir')",
                            "Call"
                        ],
                        [
                            "os.path.join(load_dir, 'model_module')",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_146": {
                "variable": {
                    "value": "saver",
                    "type": "Variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "init_vars",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "create_global_step_227": {
                "variable": {
                    "value": "global_step",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_all_238": {
                "variable": {
                    "value": "summaries",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_100": {
                "name_or_scope": {
                    "value": "self.shared_resources.config.get('name', 'jtreader')",
                    "type": "Call",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Name",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "trainable_variables_117": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_123": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_240": {
                "inputs": {
                    "value": "[tf.nn.l2_loss(v) for v in self.model_module.train_variables]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "global_variables_258": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "l2_loss_240": {
                "t": {
                    "value": "v",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.variables",
                            "Attribute"
                        ]
                    ]
                }
            },
            "clip_by_value_244": {
                "t": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "clip[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "clip[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "clip_by_norm_247": {
                "t": {
                    "value": "grad",
                    "type": "Variable",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "clip",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_global_step_269": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "jack/core/tensorport.py": {
        "tensorflow": {
            "placeholder_with_default_140": {
                "variable": {
                    "value": "ph",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.default_value",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_52": {
                "dtype": {
                    "value": "tf.as_dtype(self.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_52": {
                "type_value": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_141": {
                "type_value": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "is_tensor_87": {
                "obj": {
                    "value": "value",
                    "type": "Call",
                    "possible_values": [
                        [
                            "value.cuda()",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(value)",
                            "Call"
                        ],
                        [
                            "np.array(value, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "value.astype(self.dtype)",
                            "Call"
                        ],
                        [
                            "value.cuda()",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(torch.from_numpy(value))",
                            "Call"
                        ],
                        [
                            "value.data",
                            "Attribute"
                        ],
                        [
                            "self.default_value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "is_tensor_63": {
                "obj": {
                    "value": "value",
                    "type": "Call",
                    "possible_values": [
                        [
                            "value.cuda()",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(value)",
                            "Call"
                        ],
                        [
                            "np.array(value, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "value.astype(self.dtype)",
                            "Call"
                        ],
                        [
                            "value.cuda()",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(torch.from_numpy(value))",
                            "Call"
                        ],
                        [
                            "value.data",
                            "Attribute"
                        ],
                        [
                            "self.default_value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "from_numpy_72": {
                "ndarray": {
                    "value": "value",
                    "type": "Call",
                    "possible_values": [
                        [
                            "value.cuda()",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(value)",
                            "Call"
                        ],
                        [
                            "np.array(value, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "value.astype(self.dtype)",
                            "Call"
                        ],
                        [
                            "value.cuda()",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(torch.from_numpy(value))",
                            "Call"
                        ],
                        [
                            "value.data",
                            "Attribute"
                        ],
                        [
                            "self.default_value",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "jack/readers/extractive_qa/tensorflow/answer_layer.py": {
        "tensorflow": {
            "dense_42": {
                "variable": {
                    "value": "attention_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "encoded_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "question_attention",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_45": {
                "variable": {
                    "value": "question_attention_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "attention_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(encoded_question, 1, name='question_attention')",
                            "Call"
                        ],
                        [
                            "attention_scores + tf.expand_dims(q_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "question_attention_weights",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_46": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "question_attention_weights * encoded_question",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_58": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.layers.dense(question_state, 2 * size, name='hidden')",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "split_59": {
                "variable": {
                    "value": "(hidden_start, hidden_end)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(tf.layers.dense(question_state, 2 * size, name='hidden'), support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(tf.layers.dense(question_state, 2 * size, name='hidden_1'), support2question)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, 2 * size, use_bias=False, name='hidden_2') + tf.expand_dims(hidden, 1)",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "einsum_63": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ik,ijk->ij",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden_start",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, size, use_bias=False, name='hidden_start_2') + tf.expand_dims(hidden_start, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "einsum_66": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ik,ijk->ij",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(end_input, size, use_bias=False, name='hidden_end_2') + tf.expand_dims(hidden_end, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_states], 1), size, name='hidden_end')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_79": {
                "variable": {
                    "value": "static_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.gather(tf.expand_dims(question_state, 1), support2question) * encoded_support, encoded_support]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_82": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.layers.dense(question_state, 2 * size, name='hidden_1')",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "split_86": {
                "variable": {
                    "value": "(hidden_start, hidden_end)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.nn.relu(hidden)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_90": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden_start",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, size, use_bias=False, name='hidden_start_2') + tf.expand_dims(hidden_start, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "start_scores",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_91": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_start, 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_start), 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_start, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_start_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_94": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(end_input, size, use_bias=False, name='hidden_end_2') + tf.expand_dims(hidden_end, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_states], 1), size, name='hidden_end')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "end_scores",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_95": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "end_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_end, 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support_gathered)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_end), 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + tf.gather(support_mask, doc_idx_flat)",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_end, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_end_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unique_with_counts_104": {
                "variable": {
                    "value": "(_, _, num_doc_per_question)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cumsum_105": {
                "variable": {
                    "value": "offsets",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "num_doc_per_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_155": {
                "variable": {
                    "value": "doc_idx_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "doc_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([doc_idx1, doc_idx2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(doc_idx, idx)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_156": {
                "variable": {
                    "value": "pointer_flat1",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pointer1",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_159": {
                "variable": {
                    "value": "scores_gathered2",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "scores2",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "doc_idx_flat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_168": {
                "variable": {
                    "value": "pointer2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "scores_gathered2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(scores2, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "scores_gathered2 + left_mask + right_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_nd_170": {
                "variable": {
                    "value": "topk_score2",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "scores2",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.stack([doc_idx_flat, pointer2], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_179": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "unique_with_counts_198": {
                "variable": {
                    "value": "(_, _, num_doc_per_question)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cumsum_199": {
                "variable": {
                    "value": "offsets",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "num_doc_per_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_202": {
                "variable": {
                    "value": "(doc_idx, start_pointer)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : segment_top_k(start_scores, support2question, topk)[:2]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (tf.expand_dims(answer2support, 1), tf.expand_dims(correct_start, 1))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reshape_207": {
                "variable": {
                    "value": "doc_idx_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "doc_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([doc_idx1, doc_idx2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(doc_idx, idx)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_208": {
                "variable": {
                    "value": "start_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "start_pointer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([start_pointer1, start_pointer2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(start_pointer, idx)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start_pointer, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_nd_210": {
                "variable": {
                    "value": "start_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.stack([doc_idx_flat, start_pointer], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_213": {
                "variable": {
                    "value": "encoded_support_gathered",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "doc_idx_flat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_214": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "doc_idx_flat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_254": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.layers.dense(encoded_support_start, 1, use_bias=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_255": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.layers.dense(encoded_support_end, 1, use_bias=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_268": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "units": {
                    "value": "encoded_support.get_shape()[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_269": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "GRUBlockCell_271": {
                "variable": {
                    "value": "cell",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "stack_304": {
                "variable": {
                    "value": "all_start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "all_start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(all_start_scores)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : all_start_scores * dropout_mask, lambda : all_start_scores)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_305": {
                "variable": {
                    "value": "all_end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "all_end_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(all_end_scores)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : all_end_scores * dropout_mask, lambda : all_end_scores)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_306": {
                "variable": {
                    "value": "dropout_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones([num_steps, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_307": {
                "variable": {
                    "value": "all_start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : all_start_scores * dropout_mask",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : all_start_scores",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_308": {
                "variable": {
                    "value": "all_end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : all_end_scores * dropout_mask",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : all_end_scores",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reduce_mean_310": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(all_start_scores)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : all_start_scores * dropout_mask, lambda : all_start_scores)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_mean_311": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_end_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(all_end_scores)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : all_end_scores * dropout_mask, lambda : all_end_scores)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_109": {
                "variable": {
                    "value": "gathered_end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "end_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_end, 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support_gathered)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_end), 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + tf.gather(support_mask, doc_idx_flat)",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_end, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_end_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "answer2support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_110": {
                "variable": {
                    "value": "gathered_start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_start, 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_start), 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_start, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_start_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "answer2support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "argmax_117": {
                "variable": {
                    "value": "predicted_start_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "gathered_start_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(start_scores, answer2support)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_118": {
                "variable": {
                    "value": "predicted_end_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "gathered_end_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(end_scores, answer2support)",
                            "Call"
                        ],
                        [
                            "gathered_end_scores + left_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_130": {
                "variable": {
                    "value": "doc_idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[doc_idx1, doc_idx2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_131": {
                "variable": {
                    "value": "start_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[start_pointer1, start_pointer2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_132": {
                "variable": {
                    "value": "end_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[end_pointer1, end_pointer2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_133": {
                "variable": {
                    "value": "span_score",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[span_score1, span_score2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "top_k_135": {
                "variable": {
                    "value": "(_, idx)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "span_score",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([span_score1, span_score2], 1)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "topk",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_138": {
                "variable": {
                    "value": "r",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(tf.expand_dims(r, 1), [1, topk])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_140": {
                "variable": {
                    "value": "idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[r, tf.reshape(idx, [-1, 1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_nd_141": {
                "variable": {
                    "value": "doc_idx",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "doc_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([doc_idx1, doc_idx2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(doc_idx, idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([r, tf.reshape(idx, [-1, 1])], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_142": {
                "variable": {
                    "value": "start_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "start_pointer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([start_pointer1, start_pointer2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(start_pointer, idx)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start_pointer, [-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([r, tf.reshape(idx, [-1, 1])], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_143": {
                "variable": {
                    "value": "end_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "end_pointer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([end_pointer1, end_pointer2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(end_pointer, idx)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([r, tf.reshape(idx, [-1, 1])], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_147": {
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "train",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dense_184": {
                "variable": {
                    "value": "hidden_start",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "hidden_start",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "einsum_185": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ik,ijk->ij",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden_start",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, size, use_bias=False, name='hidden_start_2') + tf.expand_dims(hidden_start, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_187": {
                "variable": {
                    "value": "static_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(question_state, 1) * encoded_support, encoded_support]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_188": {
                "variable": {
                    "value": "hidden_start",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "hidden_start_1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_191": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.nn.relu(hidden_start)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "start_scores",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_192": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_start, 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_start), 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_start, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_start_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_216": {
                "variable": {
                    "value": "hidden_end",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([question_state, start_state], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "hidden_end",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "einsum_217": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ik,ijk->ij",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(end_input, size, use_bias=False, name='hidden_end_2') + tf.expand_dims(hidden_end, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_states], 1), size, name='hidden_end')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support_gathered",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(encoded_support, doc_idx_flat)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_219": {
                "variable": {
                    "value": "end_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(start_state, 1) * encoded_support_gathered, tf.gather(static_input, doc_idx_flat)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_222": {
                "variable": {
                    "value": "hidden_end",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([question_state, start_state], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "hidden_end_1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_227": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.nn.relu(hidden_end)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "end_scores",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_228": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "end_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_end, 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support_gathered)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_end), 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + tf.gather(support_mask, doc_idx_flat)",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_end, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_end_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_233": {
                "variable": {
                    "value": "predicted_end_pointer",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "end_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_end, 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support_gathered)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_end), 1, use_bias=False, name='end_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_scores, [2])",
                            "Call"
                        ],
                        [
                            "end_scores + tf.gather(support_mask, doc_idx_flat)",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_end, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_end_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_end, encoded_support)",
                            "Call"
                        ],
                        [
                            "end_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_243": {
                "variable": {
                    "value": "predicted_ends",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "masked_end_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "end_scores + left_mask + right_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_248": {
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "train",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_44": {
                "input": {
                    "value": "q_mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "misc.mask_for_lengths(question_length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_58": {
                "inputs": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "units": {
                    "value": "2 * size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_82": {
                "inputs": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "units": {
                    "value": "2 * size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden_1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_83": {
                "inputs": {
                    "value": "static_input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([tf.gather(tf.expand_dims(question_state, 1), support2question) * encoded_support, encoded_support], 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(question_state, 1) * encoded_support, encoded_support], 2)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "2 * size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden_2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_84": {
                "input": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(tf.layers.dense(question_state, 2 * size, name='hidden'), support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(tf.layers.dense(question_state, 2 * size, name='hidden_1'), support2question)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, 2 * size, use_bias=False, name='hidden_2') + tf.expand_dims(hidden, 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_86": {
                "features": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(tf.layers.dense(question_state, 2 * size, name='hidden'), support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(tf.layers.dense(question_state, 2 * size, name='hidden_1'), support2question)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, 2 * size, use_bias=False, name='hidden_2') + tf.expand_dims(hidden, 1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_103": {
                "input": {
                    "value": "start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_start, 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_start), 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_start, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_start_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_106": {
                "params": {
                    "value": "offsets",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.cumsum(num_doc_per_question, exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(num_doc_per_question, exclusive=True)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_151": {
                "input": {
                    "value": "scores1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cast_162": {
                "x": {
                    "value": "pointer_flat1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(pointer1, [-1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_164": {
                "x": {
                    "value": "pointer_flat1 + max_span_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_170": {
                "values": {
                    "value": "[doc_idx_flat, pointer2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_172": {
                "tensor": {
                    "value": "topk_score2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather_nd(scores2, tf.stack([doc_idx_flat, pointer2], 1))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_197": {
                "input": {
                    "value": "start_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(hidden_start, 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.nn.relu(hidden_start), 1, use_bias=False, name='start_scores')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_scores, [2])",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.squeeze(tf.layers.dense(encoded_support_start, 1, use_bias=False), 2)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(all_start_scores, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.einsum('ik,ijk->ij', hidden_start, encoded_support)",
                            "Call"
                        ],
                        [
                            "start_scores + support_mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "range_200": {},
            "gather_200": {
                "params": {
                    "value": "offsets",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.cumsum(num_doc_per_question, exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(num_doc_per_question, exclusive=True)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_210": {
                "values": {
                    "value": "[doc_idx_flat, start_pointer]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_230": {
                "params": {
                    "value": "support_mask",
                    "type": "Call",
                    "possible_values": [
                        [
                            "misc.mask_for_lengths(support_length)",
                            "Call"
                        ],
                        [
                            "misc.mask_for_lengths(support_length)",
                            "Call"
                        ],
                        [
                            "misc.mask_for_lengths(support_length)",
                            "Call"
                        ],
                        [
                            "misc.mask_for_lengths(support_length)",
                            "Call"
                        ],
                        [
                            "misc.mask_for_lengths(support_length)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "doc_idx_flat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_254": {
                "inputs": {
                    "value": "encoded_support_start",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_255": {
                "inputs": {
                    "value": "encoded_support_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "sequence_encoder.encoder(encoded_support, support_length, name='encoded_support_end', is_eval=is_eval, **encoder)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoded_support, encoded_support_end], 2)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_280": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_283": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_284": {
                "variable": {
                    "value": "support_attn",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "support_attn",
                    "type": "Name",
                    "possible_values": [
                        [
                            "attention.bilinear_attention(question_state, encoded_support, support_length, False, False)[2]",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(support_attn, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_287": {
                "variable": {
                    "value": "hidden_start",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "hidden_start",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "einsum_289": {
                "variable": {
                    "value": "start_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ik,ijk->ij",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden_start",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, size, use_bias=False, name='hidden_start_2') + tf.expand_dims(hidden_start, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "einsum_293": {
                "variable": {
                    "value": "start_states",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,ijk->ik",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "start_probs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "segment_softmax(start_scores, support2question)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_294": {
                "variable": {
                    "value": "start_states",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "start_states",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ij,ijk->ik', start_probs, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_sum(start_states, support2question, tf.shape(question_length)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(start_states, support2question)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "tf.shape(question_length)[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_295": {
                "variable": {
                    "value": "start_states",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "start_states",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ij,ijk->ik', start_probs, encoded_support)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_sum(start_states, support2question, tf.shape(question_length)[0])",
                            "Call"
                        ],
                        [
                            "tf.gather(start_states, support2question)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dense_297": {
                "variable": {
                    "value": "hidden_end",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([question_state, start_states], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "hidden_end",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "einsum_299": {
                "variable": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ik,ijk->ij",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "hidden_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(end_input, size, use_bias=False, name='hidden_end_2') + tf.expand_dims(hidden_end, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_states], 1), size, name='hidden_end')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ones_306": {
                "shape": {
                    "value": "[num_steps, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_121": {
                "params": {
                    "value": "doc_idx_for_support",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.range(tf.shape(support2question)[0]) - tf.gather(offsets, support2question)",
                            "BinOp"
                        ],
                        [
                            "tf.range(tf.shape(support2question)[0]) - tf.gather(offsets, support2question)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "answer2support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tile_138": {
                "input": {
                    "value": "tf.expand_dims(r, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, topk]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_145": {
                "params": {
                    "value": "doc_idx_for_support",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.range(tf.shape(support2question)[0]) - tf.gather(offsets, support2question)",
                            "BinOp"
                        ],
                        [
                            "tf.range(tf.shape(support2question)[0]) - tf.gather(offsets, support2question)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "doc_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([doc_idx1, doc_idx2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(doc_idx, idx)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_189": {
                "inputs": {
                    "value": "static_input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([tf.gather(tf.expand_dims(question_state, 1), support2question) * encoded_support, encoded_support], 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(question_state, 1) * encoded_support, encoded_support], 2)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden_start_2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_190": {
                "input": {
                    "value": "hidden_start",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, size, use_bias=False, name='hidden_start_2') + tf.expand_dims(hidden_start, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_191": {
                "features": {
                    "value": "hidden_start",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(static_input, size, use_bias=False, name='hidden_start_2') + tf.expand_dims(hidden_start, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(question_state, size, name='hidden_start')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_216": {
                "values": {
                    "value": "[question_state, start_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_222": {
                "values": {
                    "value": "[question_state, start_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_224": {
                "inputs": {
                    "value": "end_input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([tf.expand_dims(start_state, 1) * encoded_support_gathered, tf.gather(static_input, doc_idx_flat)], 2)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoded_support.get_shape()[-1].value",
                            "Attribute"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden_end_2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_225": {
                "input": {
                    "value": "hidden_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(end_input, size, use_bias=False, name='hidden_end_2') + tf.expand_dims(hidden_end, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_states], 1), size, name='hidden_end')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_227": {
                "features": {
                    "value": "hidden_end",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_state], 1), size, name='hidden_end_1')",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(end_input, size, use_bias=False, name='hidden_end_2') + tf.expand_dims(hidden_end, 1)",
                            "BinOp"
                        ],
                        [
                            "tf.layers.dense(tf.concat([question_state, start_states], 1), size, name='hidden_end')",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_238": {
                "x": {
                    "value": "start_pointer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([start_pointer1, start_pointer2], 1)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(start_pointer, idx)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start_pointer, [-1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_240": {
                "x": {
                    "value": "start_pointer + max_span_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_246": {
                "params": {
                    "value": "doc_idx_for_support",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.range(tf.shape(support2question)[0]) - tf.gather(offsets, support2question)",
                            "BinOp"
                        ],
                        [
                            "tf.range(tf.shape(support2question)[0]) - tf.gather(offsets, support2question)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "doc_idx_flat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_279": {
                "name_or_scope": {
                    "value": "SAN",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "i > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "gather_79": {
                "params": {
                    "value": "tf.expand_dims(question_state, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_106": {
                "input": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cast_114": {
                "x": {
                    "value": "correct_start",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_137": {
                "input": {
                    "value": "span_score",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([span_score1, span_score2], 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_138": {
                "input": {
                    "value": "r",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(tf.shape(span_score)[0], dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.tile(tf.expand_dims(r, 1), [1, topk]), [-1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_140": {
                "tensor": {
                    "value": "idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([r, tf.reshape(idx, [-1, 1])], 1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_200": {
                "input": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_205": {
                "input": {
                    "value": "correct_start",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_220": {
                "params": {
                    "value": "static_input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([tf.gather(tf.expand_dims(question_state, 1), support2question) * encoded_support, encoded_support], 2)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(question_state, 1) * encoded_support, encoded_support], 2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "doc_idx_flat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(doc_idx, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_297": {
                "values": {
                    "value": "[question_state, start_states]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_79": {
                "input": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_187": {
                "input": {
                    "value": "question_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(question_attention_weights * encoded_question, 1)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, doc_idx_flat)",
                            "Call"
                        ],
                        [
                            "compute_question_state(encoded_question, question_length)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(question_state, encoded_support.get_shape()[-1].value, tf.tanh)",
                            "Call"
                        ],
                        [
                            "tf.gather(question_state, support2question)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(question_state, 1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(question_state, 1)",
                            "Call"
                        ],
                        [
                            "cell(support_attn, question_state)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_219": {
                "input": {
                    "value": "start_state",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather_nd(encoded_support, tf.stack([doc_idx_flat, start_pointer], 1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_294": {
                "input": {
                    "value": "question_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_34": {
                "variable": {
                    "value": "encoded_support_end",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoded_support, encoded_support_end]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/extractive_qa/tensorflow/modular_qa_model.py": {
        "tensorflow": {
            "stack_64": {
                "variable": {
                    "value": "span",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[doc_idx, predicted_start_pointer, predicted_end_pointer]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_51": {
                "variable": {
                    "value": "topk",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "topk",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "shared_resources.config.get('topk', 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_53": {
                "variable": {
                    "value": "topk_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "beam_size_setter",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_30": {
                "input": {
                    "value": "tensors.word_in_question",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_42": {
                "name_or_scope": {
                    "value": "answer_layer",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/link_prediction/scores.py": {
        "tensorflow": {
            "reshape_89": {
                "variable": {
                    "value": "W",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.predicate_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, emb_size, emb_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "split_109": {
                "variable": {
                    "value": "(es_re, es_im)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "self.subject_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_110": {
                "variable": {
                    "value": "(eo_re, eo_im)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "self.object_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_111": {
                "variable": {
                    "value": "(ew_re, ew_im)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "self.predicate_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_70": {
                "input_tensor": {
                    "value": "scaled_subject_embedding * self.object_embeddings",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_91": {
                "input_tensor": {
                    "value": "sW * self.object_embeddings",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_88": {
                "input": {
                    "value": "self.subject_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_90": {
                "a": {
                    "value": "es",
                    "type": "Variable",
                    "possible_values": []
                },
                "b": {
                    "value": "W",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(self.predicate_embeddings, (-1, emb_size, emb_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_114": {
                "input_tensor": {
                    "value": "arg1 * rel * arg2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_88": {
                "input": {
                    "value": "self.subject_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/link_prediction/similarities.py": {
        "tensorflow": {
            "reduce_sum_22": {
                "variable": {
                    "value": "distance",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.abs(x1 - x2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "sqrt_41": {
                "variable": {
                    "value": "distance",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(x1 - x2), axis=axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_59": {
                "variable": {
                    "value": "distance",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x1 - x2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_78": {
                "variable": {
                    "value": "similarity",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x1 * x2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "abs_22": {
                "x": {
                    "value": "x1 - x2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_41": {
                "input_tensor": {
                    "value": "tf.square(x1 - x2)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "square_59": {
                "x": {
                    "value": "x1 - x2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_41": {
                "x": {
                    "value": "x1 - x2",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/natural_language_inference/conditional_bilstm.py": {
        "tensorflow": {
            "concat_31": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[outputs[0], outputs[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_34": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hidden",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(outputs, repr_dim, tf.nn.relu, name='hidden') * tf.expand_dims(tf.sequence_mask(tensors.support_length, maxlen=tf.shape(outputs)[1], dtype=tf.float32), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(hidden, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_36": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(outputs, repr_dim, tf.nn.relu, name='hidden') * tf.expand_dims(tf.sequence_mask(tensors.support_length, maxlen=tf.shape(outputs)[1], dtype=tf.float32), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(hidden, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "classification",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_14": {
                "variable": {
                    "value": "embedded_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "embedded_question",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(embedded_question, repr_dim, tf.tanh, name='projection')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_question, 1.0 - dropout, dropout_shape)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_16": {
                "variable": {
                    "value": "embedded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "embedded_support",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(embedded_support, repr_dim, tf.tanh, name='projection')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_support, 1.0 - dropout, dropout_shape)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_19": {
                "variable": {
                    "value": "embedded_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_question",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(embedded_question, repr_dim, tf.tanh, name='projection')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_question, 1.0 - dropout, dropout_shape)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "dropout_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tf.shape(embedded_question)[0], 1, tf.shape(embedded_question)[2]]",
                            "List"
                        ]
                    ]
                }
            },
            "dropout_20": {
                "variable": {
                    "value": "embedded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_support",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(embedded_support, repr_dim, tf.tanh, name='projection')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_support, 1.0 - dropout, dropout_shape)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "dropout_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tf.shape(embedded_question)[0], 1, tf.shape(embedded_question)[2]]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_13": {
                "name_or_scope": {
                    "value": "embedding_projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_32": {
                "inputs": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([outputs[0], outputs[1]], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(hidden, num_classes, name='classification')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_32": {
                "input": {
                    "value": "tf.sequence_mask(tensors.support_length, maxlen=tf.shape(outputs)[1], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sequence_mask_33": {
                "lengths": {
                    "value": "tensors.support_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(outputs)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_18": {
                "input": {
                    "value": "embedded_question",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(embedded_question, repr_dim, tf.tanh, name='projection')",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(embedded_question, 1.0 - dropout, dropout_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_33": {
                "input": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([outputs[0], outputs[1]], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(hidden, num_classes, name='classification')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "jack/readers/natural_language_inference/decomposable_attention.py": {
        "tensorflow": {
            "cond_48": {
                "variable": {
                    "value": "dropout_keep_prob",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_not(tensors.is_eval)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : 1.0 - dropout_rate",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : 1.0",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_197": {
                "variable": {
                    "value": "sentence_and_alignment",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "values": {
                    "value": "[sentence, soft_alignment]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_27": {
                "variable": {
                    "value": "bos_token_emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bos_token_embedding",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, embedding_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.ones_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_33": {
                "variable": {
                    "value": "t_bos_token_emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bos_token_emb",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable('bos_token_embedding', shape=(1, 1, embedding_size), initializer=tf.ones_initializer())",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_37": {
                "variable": {
                    "value": "embedded_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[t_bos_token_emb, embedded_question]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_38": {
                "variable": {
                    "value": "embedded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[t_bos_token_emb, embedded_support]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "l2_normalize_44": {
                "variable": {
                    "value": "embedded_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_question",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat(values=[t_bos_token_emb, embedded_question], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embedded_question, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "l2_normalize_45": {
                "variable": {
                    "value": "embedded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "embedded_support",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat(values=[t_bos_token_emb, embedded_support], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embedded_support, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_161": {
                "variable": {
                    "value": "self.raw_attentions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "a": {
                    "value": "transformed_sequence1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._transform_attend(sequence1, reuse)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.transpose(transformed_sequence2, [0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_171": {
                "variable": {
                    "value": "attention_transposed",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "self.raw_attentions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_180": {
                "variable": {
                    "value": "alpha",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "self.attention_sentence2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "b": {
                    "value": "sequence1",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "alpha",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_181": {
                "variable": {
                    "value": "beta",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "self.attention_sentence1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "b": {
                    "value": "sequence2",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_222": {
                "variable": {
                    "value": "v1_v2",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "values": {
                    "value": "[v1_sum, v2_sum]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_249": {
                "variable": {
                    "value": "projection",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence",
                    "type": "Variable",
                    "possible_values": []
                },
                "keep_prob": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_255": {
                "variable": {
                    "value": "projection",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "projection",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.fully_connected(inputs=sequence, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=None, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(sequence, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(sequence, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(v1_v2, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_265": {
                "variable": {
                    "value": "projection",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence",
                    "type": "Variable",
                    "possible_values": []
                },
                "keep_prob": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_271": {
                "variable": {
                    "value": "projection",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "projection",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.fully_connected(inputs=sequence, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=None, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(sequence, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(sequence, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(v1_v2, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_281": {
                "variable": {
                    "value": "projection",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v1_v2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat(axis=1, values=[v1_sum, v2_sum])",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_287": {
                "variable": {
                    "value": "projection",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "projection",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.fully_connected(inputs=sequence, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=None, activation_fn=None)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(sequence, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(sequence, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(v1_v2, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(projection, keep_prob=self.dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=projection, num_outputs=self.representation_size, weights_initializer=tf.random_normal_initializer(0.0, self.init_std_dev), biases_initializer=tf.zeros_initializer(), activation_fn=tf.nn.relu)",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_not_48": {
                "x": {
                    "value": "tensors.is_eval",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_153": {
                "name_or_scope": {
                    "value": "attend",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "aggregate",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_240": {
                "name_or_scope": {
                    "value": "transform_embeddings",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_248": {
                "name_or_scope": {
                    "value": "transform_attend",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_264": {
                "name_or_scope": {
                    "value": "transform_compare",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_280": {
                "name_or_scope": {
                    "value": "transform_aggregate",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_31": {
                "input": {
                    "value": "embedded_question",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat(values=[t_bos_token_emb, embedded_question], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(embedded_question, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_161": {
                "a": {
                    "value": "transformed_sequence2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._transform_attend(sequence2, True)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_220": {
                "input_tensor": {
                    "value": "v2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "mask_3d(sequences=v2, sequence_lengths=v2_lengths, mask_value=0, dimension=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_initializer_29": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_227": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_initializer_228": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_242": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_normal_initializer_251": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_253": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_257": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_259": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_267": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_269": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_273": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_275": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_283": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_285": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_normal_initializer_289": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.init_std_dev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_291": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/natural_language_inference/modular_nli_model.py": {
        "tensorflow": {
            "cond_29": {
                "variable": {
                    "value": "inputs[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "pred": {
                    "value": "tensors.is_eval",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : inputs[k]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(inputs[k], 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "variable_scope_37": {
                "name_or_scope": {
                    "value": "prediction_layer",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_29": {
                "x": {
                    "value": "inputs[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/natural_language_inference/prediction_layer.py": {
        "tensorflow": {
            "sequence_mask_23": {
                "variable": {
                    "value": "p_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "premise_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(premise)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_24": {
                "variable": {
                    "value": "h_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "hypothesis_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(hypothesis)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_35": {
                "variable": {
                    "value": "p_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "premise",
                    "type": "Name",
                    "possible_values": [
                        [
                            "premise * tf.expand_dims(p_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_38": {
                "variable": {
                    "value": "h_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_41": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[p_max, p_avg, h_max, h_avg]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_44": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([p_max, p_avg, h_max, h_avg], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max, p_max - h_max, p_max * h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dense_47": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_56": {
                "variable": {
                    "value": "p_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "premise",
                    "type": "Name",
                    "possible_values": [
                        [
                            "premise * tf.expand_dims(p_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_58": {
                "variable": {
                    "value": "h_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_60": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[p_max, h_max]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_63": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([p_max, p_avg, h_max, h_avg], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max, p_max - h_max, p_max * h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dense_66": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_75": {
                "variable": {
                    "value": "p_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "premise",
                    "type": "Name",
                    "possible_values": [
                        [
                            "premise * tf.expand_dims(p_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_76": {
                "variable": {
                    "value": "h_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_78": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[p_max, h_max, p_max - h_max, p_max * h_max]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_81": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([p_max, p_avg, h_max, h_avg], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max, p_max - h_max, p_max * h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dense_84": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sequence_mask_91": {
                "variable": {
                    "value": "h_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "hypothesis_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(hypothesis)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_94": {
                "variable": {
                    "value": "h_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_96": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "h_max",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_max(hypothesis, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(hypothesis, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(hypothesis, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_max(hypothesis, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "activation",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ],
                        [
                            "tf.tanh",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dense_99": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_26": {
                "input": {
                    "value": "p_mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.sequence_mask(premise_length, tf.shape(premise)[1], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_27": {
                "input": {
                    "value": "h_mask",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.sequence_mask(hypothesis_length, tf.shape(hypothesis)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(hypothesis_length, tf.shape(hypothesis)[1], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_43": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(inputs, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_46": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : hidden",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(hidden, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_62": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(inputs, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_65": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : hidden",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(hidden, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_80": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : inputs",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(inputs, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_83": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : hidden",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(hidden, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_92": {
                "input": {
                    "value": "h_mask",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.sequence_mask(hypothesis_length, tf.shape(hypothesis)[1], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(hypothesis_length, tf.shape(hypothesis)[1], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_98": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : hidden",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(hidden, 1.0 - dropout)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "reduce_sum_36": {
                "input_tensor": {
                    "value": "premise",
                    "type": "Name",
                    "possible_values": [
                        [
                            "premise * tf.expand_dims(p_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_36": {
                "input": {
                    "value": "tf.to_float(premise_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_39": {
                "input_tensor": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_39": {
                "input": {
                    "value": "tf.to_float(hypothesis_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_23": {
                "input": {
                    "value": "premise",
                    "type": "Name",
                    "possible_values": [
                        [
                            "premise * tf.expand_dims(p_mask, 2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_24": {
                "input": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_float_36": {
                "x": {
                    "value": "premise_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "to_float_39": {
                "x": {
                    "value": "hypothesis_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_91": {
                "input": {
                    "value": "hypothesis",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hypothesis * tf.expand_dims(h_mask, 2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dropout_43": {
                "x": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([p_max, p_avg, h_max, h_avg], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max, p_max - h_max, p_max * h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_46": {
                "x": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_62": {
                "x": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([p_max, p_avg, h_max, h_avg], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max, p_max - h_max, p_max * h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_65": {
                "x": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_80": {
                "x": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([p_max, p_avg, h_max, h_avg], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.concat([p_max, h_max, p_max - h_max, p_max * h_max], 1)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : inputs, lambda : tf.nn.dropout(inputs, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_83": {
                "x": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_98": {
                "x": {
                    "value": "hidden",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(h_max, size, activation)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : hidden, lambda : tf.nn.dropout(hidden, 1.0 - dropout))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "jack/train_reader.py": {
        "tensorflow": {
            "get_variable_53": {
                "variable": {
                    "value": "learning_rate",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "learning_rate",
                    "type": "Call",
                    "possible_values": [
                        [
                            "configuration.get('learning_rate')",
                            "Call"
                        ],
                        [
                            "tf.get_variable('learning_rate', initializer=learning_rate, dtype=tf.float32, trainable=False)",
                            "Call"
                        ],
                        [
                            "configuration.get('learning_rate')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "set_random_seed_32": {
                "seed": {
                    "value": "seed",
                    "type": "Call",
                    "possible_values": [
                        [
                            "configuration.get('seed', 0)",
                            "Call"
                        ],
                        [
                            "configuration.get('seed')",
                            "Call"
                        ]
                    ]
                }
            },
            "FileWriter_74": {
                "variable": {
                    "value": "sw",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "tensorboard_folder",
                    "type": "Call",
                    "possible_values": [
                        [
                            "configuration.get('tensorboard_folder')",
                            "Call"
                        ],
                        [
                            "configuration.get('tensorboard_folder')",
                            "Call"
                        ]
                    ]
                }
            },
            "FileWriter_173": {
                "variable": {
                    "value": "sw",
                    "type": "Variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "tensorboard_folder",
                    "type": "Call",
                    "possible_values": [
                        [
                            "configuration.get('tensorboard_folder')",
                            "Call"
                        ],
                        [
                            "configuration.get('tensorboard_folder')",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_54": {
                "x": {
                    "value": "learning_rate_decay * learning_rate",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "min_learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "configuration.get('min_learning_rate')",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "torch": {
            "manual_seed_131": {
                "seed": {
                    "value": "seed",
                    "type": "Call",
                    "possible_values": [
                        [
                            "configuration.get('seed', 0)",
                            "Call"
                        ],
                        [
                            "configuration.get('seed')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "jack/util/hooks.py": {
        "tensorflow": {
            "Summary_73": {
                "variable": {
                    "value": "summary",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[tf.Summary.Value(tag=title, simple_value=value)]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/activations.py": {
        "tensorflow": {
            "get_variable_7": {
                "variable": {
                    "value": "alphas",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "{}/alpha.format(name) if name else alpha",
                    "type": "IfExp",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.get_shape()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_11": {
                "features": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "name_scope_15": {
                "name": {
                    "value": "{}/elu.format(name) if name else elu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "constant_initializer_9": {
                "value": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "where_18": {
                "condition": {
                    "value": "x >= 0.0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "alpha * tf.nn.elu(x)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "elu_18": {
                "features": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/attention.py": {
        "tensorflow": {
            "einsum_29": {
                "variable": {
                    "value": "attn_states",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abd,adc->abc",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "attn_probs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "softmax(attn_scores)",
                            "Call"
                        ],
                        [
                            "softmax(tf.concat([s, attn_scores], 2))",
                            "Call"
                        ],
                        [
                            "attn_probs[:, :, 1:]",
                            "Subscript"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "states",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "einsum_39": {
                "variable": {
                    "value": "attn_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abc,adc->abd",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_49": {
                "variable": {
                    "value": "attn_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abc,adc->abd",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_61": {
                "variable": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "attn_weight",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, query.get_shape()[-1].value]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.ones_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_63": {
                "variable": {
                    "value": "attn_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abc,adc->abd",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "v * query",
                    "type": "BinOp",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_75": {
                "variable": {
                    "value": "hidden1",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dense_76": {
                "variable": {
                    "value": "hidden2",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hidden_dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dense_78": {
                "variable": {
                    "value": "attn_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "activation(hidden)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "with_sentinel",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "einsum_99": {
                "variable": {
                    "value": "co_attn_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abd,adc->abc",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "attn_probs1",
                    "type": "Variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "attn_states2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_112": {
                "variable": {
                    "value": "original_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "values",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(distance_bias, clipped_idxs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_114": {
                "variable": {
                    "value": "reshaped_values",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "values",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(distance_bias, clipped_idxs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, original_shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_116": {
                "variable": {
                    "value": "softmax_reshaped_values",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "reshaped_values",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(tensor=values, shape=[-1, original_shape[2]])",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_12": {
                "logits": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_16": {
                "input": {
                    "value": "misc.mask_for_lengths(length, tf.shape(attn_scores)[2])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_24": {
                "variable": {
                    "value": "s",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "s",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('score', [1, 1, 1], tf.float32, tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.tile(s, [tf.shape(attn_scores)[0], tf.shape(attn_scores)[1], 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[tf.shape(attn_scores)[0], tf.shape(attn_scores)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_31": {
                "variable": {
                    "value": "attn_states",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "attn_states",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('abd,adc->abc', attn_probs, states)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_sum(attn_states, seq2_to_seq1, tf.reduce_max(seq2_to_seq1) + 1)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "seq2_to_seq1",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "tf.reduce_max(seq2_to_seq1) + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_38": {
                "variable": {
                    "value": "query",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "seq2_to_seq1",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_48": {
                "variable": {
                    "value": "query",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "seq2_to_seq1",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dense_50": {
                "inputs": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_51": {
                "a": {
                    "value": "tf.layers.dense(key, 1, use_bias=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_60": {
                "variable": {
                    "value": "query",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "seq2_to_seq1",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dense_64": {
                "inputs": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_65": {
                "a": {
                    "value": "tf.layers.dense(key, 1, use_bias=False)",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_74": {
                "variable": {
                    "value": "query",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "seq2_to_seq1",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_118": {
                "tensor": {
                    "value": "softmax_reshaped_values",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.softmax(reshaped_values)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "original_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.shape(values)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_135": {
                "variable": {
                    "value": "distance_bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "dist_bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[window_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "range_136": {
                "variable": {
                    "value": "r",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tile_137": {
                "variable": {
                    "value": "r_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(r, [1, -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.stack([time_steps, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_139": {
                "variable": {
                    "value": "clipped_idxs",
                    "type": "Variable",
                    "possible_values": []
                },
                "t": {
                    "value": "raw_idxs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "r_matrix - tf.reshape(r, [-1, 1])",
                            "BinOp"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "window_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "embedding_lookup_140": {
                "variable": {
                    "value": "values",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "distance_bias",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable('dist_bias', [window_size], initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "clipped_idxs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.clip_by_value(raw_idxs, 0, window_size - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_20": {
                "input": {
                    "value": "tf.diag(tf.fill([tf.shape(attn_scores)[1]], -1000000.0))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_23": {
                "variable": {
                    "value": "s",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "score",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_41": {
                "x": {
                    "value": "float(query.get_shape()[-1].value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_49": {
                "inputs": {
                    "value": "query",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.gather(query, seq2_to_seq1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(seq1, repr_dim, name='query')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "key.get_shape()[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_51": {
                "inputs": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_65": {
                "inputs": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_77": {
                "input": {
                    "value": "tf.expand_dims(hidden1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, tf.shape(key)[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_77": {
                "input": {
                    "value": "hidden1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(query, hidden_dim)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_79": {
                "input": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_87": {
                "variable": {
                    "value": "key",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "seq2",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "repr_dim or seq2.get_shape()[-1].value",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "key",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_88": {
                "variable": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "seq2",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "repr_dim or seq2.get_shape()[-1].value",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "value",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_89": {
                "variable": {
                    "value": "query",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "seq1",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "repr_dim or seq2.get_shape()[-1].value",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "query",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_98": {
                "a": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_133": {
                "name_or_scope": {
                    "value": "distance-bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "diag_20": {
                "diagonal": {
                    "value": "tf.fill([tf.shape(attn_scores)[1]], -1000000.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_22": {
                "name_or_scope": {
                    "value": "sentinel",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_25": {
                "values": {
                    "value": "[s, attn_scores]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_initializer_62": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_86": {
                "name_or_scope": {
                    "value": "key_value_projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_137": {
                "tensor": {
                    "value": "r",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.range(0, time_steps)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_137": {
                "values": {
                    "value": "[time_steps, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_138": {
                "tensor": {
                    "value": "r",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.range(0, time_steps)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_11": {
                "input": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_16": {
                "input": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_20": {
                "dims": {
                    "value": "[tf.shape(attn_scores)[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "-1000000.0",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_initializer_23": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_max_31": {
                "input_tensor": {
                    "value": "seq2_to_seq1",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "zeros_initializer_135": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_24": {
                "input": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_77": {
                "input": {
                    "value": "key",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(seq2, repr_dim, name='key')",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_20": {
                "input": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "attn_scores / math.sqrt(float(query.get_shape()[-1].value))",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', query, key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', tf.layers.dense(query, key.get_shape()[-1].value, use_bias=False), key)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,adc->abd', v * query, key)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(activation(hidden), 1, use_bias=with_sentinel)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "jack/util/tf/dropout.py": {
        "tensorflow": {
            "floor_24": {
                "variable": {
                    "value": "binary_tensor",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "random_tensor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "keep_prob",
                            "Name"
                        ],
                        [
                            "random_tensor + tf.random_uniform(noise_shape, seed=seed, dtype=xs[0].dtype)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_18": {
                "name": {
                    "value": "dropout",
                    "type": "Constant",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "div_27": {
                "x": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "xs",
                            "Name"
                        ]
                    ]
                },
                "y": {
                    "value": "keep_prob",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/embedding.py": {
        "tensorflow": {
            "zeros_16": {
                "variable": {
                    "value": "pad",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([tf.shape(word_lengths)[0], conv_width // 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_17": {
                "variable": {
                    "value": "word_chars",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pad, word_chars, pad]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "random_normal_initializer_9": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_21": {
                "variable": {
                    "value": "char_embedding_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "char_embedding_matrix",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "(num_chars, repr_dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "emb_initializer",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "tf.random_normal_initializer(0.0",
                            "MethodArgument"
                        ],
                        [
                            "tf.random_normal_initializer(0.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_24": {
                "variable": {
                    "value": "max_word_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "word_lengths",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "embedding_lookup_25": {
                "variable": {
                    "value": "embedded_chars",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "char_embedding_matrix",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('char_embedding_matrix', shape=(num_chars, repr_dim), initializer=emb_initializer, trainable=True)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('char_embedding_matrix', shape=(num_chars, embedding_size), initializer=emb_initializer, trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "tf.cast(word_chars, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_36": {
                "variable": {
                    "value": "embedded_words",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "conv_out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(embedded_chars, filter_reshaped, 1, 'VALID')",
                            "Call"
                        ],
                        [
                            "conv_out + conv_mask",
                            "BinOp"
                        ],
                        [
                            "tf.nn.conv1d(embedded_chars_conv, filter_reshaped, 1, 'VALID')",
                            "Call"
                        ],
                        [
                            "conv_out + conv_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "random_normal_initializer_52": {
                "mean": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_68": {
                "variable": {
                    "value": "char_embedding_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "char_embedding_matrix",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "(num_chars, embedding_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "emb_initializer",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "tf.random_normal_initializer(0.0",
                            "MethodArgument"
                        ],
                        [
                            "tf.random_normal_initializer(0.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_71": {
                "variable": {
                    "value": "pad",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.stack([tf.shape(word_lengths)[0], len(filter_sizes) // 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_72": {
                "variable": {
                    "value": "word_chars",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pad, word_chars, pad]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_74": {
                "variable": {
                    "value": "max_word_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "word_lengths",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "embedding_lookup_75": {
                "variable": {
                    "value": "embedded_chars",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "char_embedding_matrix",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('char_embedding_matrix', shape=(num_chars, repr_dim), initializer=emb_initializer, trainable=True)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('char_embedding_matrix', shape=(num_chars, embedding_size), initializer=emb_initializer, trainable=True)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "tf.cast(word_chars, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_76": {
                "variable": {
                    "value": "conv_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "misc.mask_for_lengths(word_lengths, max_length=max_word_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_93": {
                "variable": {
                    "value": "embedded_words",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "embedded_words",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_max(conv_out, 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(embedded_words, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(embedded_words, projection_size)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedded_words, word_idxs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_104": {
                "variable": {
                    "value": "embedded_words",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "embedded_words",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_max(conv_out, 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(embedded_words, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(embedded_words, projection_size)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedded_words, word_idxs)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "word_idxs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "word_sequences",
                            "Name"
                        ],
                        [
                            "word_sequences",
                            "Name"
                        ]
                    ]
                }
            },
            "stack_16": {
                "values": {
                    "value": "[tf.shape(word_lengths)[0], conv_width // 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_19": {
                "name_or_scope": {
                    "value": "scope or 'char_embeddings'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "get_variable_29": {
                "variable": {
                    "value": "filter",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "filter",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[conv_width * repr_dim, repr_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_30": {
                "variable": {
                    "value": "filter_reshaped",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "filter",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('filter', [conv_width * repr_dim, repr_dim])",
                            "Call"
                        ],
                        [
                            "tf.get_variable('filter', [conv_width * embedding_size, size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[conv_width, repr_dim, repr_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv1d_32": {
                "variable": {
                    "value": "conv_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedded_chars",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(char_embedding_matrix, tf.cast(word_chars, tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(char_embedding_matrix, tf.cast(word_chars, tf.int32))",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_reshaped",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(filter, [conv_width, repr_dim, repr_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(filter, [conv_width, embedding_size, size])",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_33": {
                "variable": {
                    "value": "conv_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "misc.mask_for_lengths(word_lengths, max_length=max_word_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_66": {
                "name_or_scope": {
                    "value": "scope or 'char_embeddings'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "dense_95": {
                "variable": {
                    "value": "embedded_words",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "embedded_words",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_max(conv_out, 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(embedded_words, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(embedded_words, projection_size)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedded_words, word_idxs)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "projection_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cast_25": {
                "x": {
                    "value": "word_chars",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([pad, word_chars, pad], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([pad, word_chars, pad], 1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_27": {
                "name_or_scope": {
                    "value": "conv",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_45": {
                "params": {
                    "value": "embedded_words",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_max(conv_out, 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(embedded_words, 1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(embedded_words, projection_size)",
                            "Call"
                        ],
                        [
                            "tf.nn.embedding_lookup(embedded_words, word_idxs)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "word_idxs",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "word_sequences",
                            "Name"
                        ],
                        [
                            "word_sequences",
                            "Name"
                        ]
                    ]
                }
            },
            "stack_71": {
                "values": {
                    "value": "[tf.shape(word_lengths)[0], len(filter_sizes) // 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_75": {
                "x": {
                    "value": "word_chars",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([pad, word_chars, pad], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([pad, word_chars, pad], 1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_85": {
                "variable": {
                    "value": "filter",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "filter",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[conv_width * embedding_size, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_86": {
                "variable": {
                    "value": "filter_reshaped",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "filter",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('filter', [conv_width * repr_dim, repr_dim])",
                            "Call"
                        ],
                        [
                            "tf.get_variable('filter', [conv_width * embedding_size, size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[conv_width, embedding_size, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv1d_89": {
                "variable": {
                    "value": "conv_out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedded_chars_conv",
                    "type": "Name",
                    "possible_values": [
                        [
                            "embedded_chars[:, cut:-cut, :] if cut else embedded_chars",
                            "IfExp"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_reshaped",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(filter, [conv_width, repr_dim, repr_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(filter, [conv_width, embedding_size, size])",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_83": {
                "name_or_scope": {
                    "value": "'conv_%d' % conv_width",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_16": {
                "input": {
                    "value": "word_lengths",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_91": {
                "input_tensor": {
                    "value": "conv_out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(embedded_chars, filter_reshaped, 1, 'VALID')",
                            "Call"
                        ],
                        [
                            "conv_out + conv_mask",
                            "BinOp"
                        ],
                        [
                            "tf.nn.conv1d(embedded_chars_conv, filter_reshaped, 1, 'VALID')",
                            "Call"
                        ],
                        [
                            "conv_out + conv_mask",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_71": {
                "input": {
                    "value": "word_lengths",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/highway.py": {
        "tensorflow": {
            "split_11": {
                "variable": {
                    "value": "(trans, gate)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "trans_gate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.contrib.layers.fully_connected(inputs, 2 * d, activation_fn=None, weights_initializer=None, scope='trans_gate')",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "len(inputs.get_shape()) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_7": {
                "name_or_scope": {
                    "value": "name or 'highway_layer'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_18": {
                "name_or_scope": {
                    "value": "name or 'highway_network'",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Name",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "sigmoid_12": {
                "x": {
                    "value": "gate",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/interaction_layer.py": {
        "tensorflow": {
            "reduce_max_38": {
                "variable": {
                    "value": "max_seq1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "attn_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "attn_scores + tf.expand_dims(mask_for_lengths(seq1_length, tf.shape(attn_scores)[1]), 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_39": {
                "variable": {
                    "value": "seq1_attention",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "max_seq1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(attn_scores, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "einsum_40": {
                "variable": {
                    "value": "seq1_weighted",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ij,ijk->ik",
                    "type": "Constant",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "seq1_attention",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.softmax(max_seq1, 1)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "seq1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_41": {
                "variable": {
                    "value": "seq1_weighted",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "seq1_weighted",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ij,ijk->ik', seq1_attention, seq1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(seq1_weighted, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(seq1_weighted, [1, tf.shape(seq1)[1], 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_42": {
                "variable": {
                    "value": "seq1_weighted",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "seq1_weighted",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.einsum('ij,ijk->ik', seq1_attention, seq1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(seq1_weighted, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(seq1_weighted, [1, tf.shape(seq1)[1], 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, tf.shape(seq1)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_27": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[seq1, out]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_36": {
                "input": {
                    "value": "mask_for_lengths(seq1_length, tf.shape(attn_scores)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_44": {
                "values": {
                    "value": "[seq2_weighted, seq1 * seq2_weighted, seq1 * seq1_weighted]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_86": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[attn_states1, co_attn_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_101": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "seq1 + attn_states1 + co_attn_state",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_10": {
                "name_or_scope": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": [
                        [
                            "'interaction_layer'",
                            "MethodArgument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "Name",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_12": {
                "variable": {
                    "value": "seq2",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "seq2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(seq2, seq1_to_seq2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "seq1_to_seq2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_13": {
                "variable": {
                    "value": "seq2_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "seq2_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(seq2_length, seq1_to_seq2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "seq1_to_seq2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_36": {
                "input": {
                    "value": "attn_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "attn_scores + tf.expand_dims(mask_for_lengths(seq1_length, tf.shape(attn_scores)[1]), 2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_42": {
                "input": {
                    "value": "seq1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_90": {
                "name_or_scope": {
                    "value": "str(i)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/masking.py": {
        "tensorflow": {
            "ones_like_26": {
                "variable": {
                    "value": "ones",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sequences",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(sequences, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_28": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "sequence_lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "time_steps2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tile_30": {
                "variable": {
                    "value": "mask3d",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(mask, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "(1, time_steps1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "where_31": {
                "variable": {
                    "value": "masked",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask3d",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(mask, 1), (1, time_steps1, 1))",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "sequences",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(sequences, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "pad_values",
                    "type": "Name",
                    "possible_values": [
                        [
                            "mask_value * tf.cast(ones, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_24": {
                "variable": {
                    "value": "sequences",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "sequences",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(sequences, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_27": {
                "x": {
                    "value": "ones",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.ones_like(sequences, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_30": {
                "input": {
                    "value": "mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.sequence_mask(sequence_lengths, time_steps2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_32": {
                "a": {
                    "value": "masked",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.where(mask3d, sequences, pad_values)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_25": {
                "input": {
                    "value": "sequences",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(sequences, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "jack/util/tf/misc.py": {
        "tensorflow": {
            "sequence_mask_20": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "max_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/modular_encoder.py": {
        "tensorflow": {
            "concat_58": {
                "variable": {
                    "value": "outputs[out_key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[outputs[k] for k in key]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "module['name']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_n_61": {
                "variable": {
                    "value": "outputs[out_key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[outputs[k] for k in key]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "name": {
                    "value": "module['name']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "subtract_64": {
                "variable": {
                    "value": "outputs[out_key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs[key[0]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "outputs[key[1]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "module['name']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "multiply_70": {
                "variable": {
                    "value": "outputs[out_key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "o",
                    "type": "Name",
                    "possible_values": [
                        [
                            "outputs[key[0]]",
                            "Subscript"
                        ],
                        [
                            "o * outputs[k]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "outputs[key[-1]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "module['name']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "dense_74": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([outputs[k] for k in key], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "outputs[key[0]].get_shape()[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_initializer": {
                    "value": "tf.constant_initializer(bias)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_76": {
                "variable": {
                    "value": "outputs[out_key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "g * outputs[key[0]] + (1.0 - g) * outputs[key[0]]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "module['name']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_74": {
                "values": {
                    "value": "[outputs[k] for k in key]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_75": {
                "value": {
                    "value": "bias",
                    "type": "Name",
                    "possible_values": [
                        [
                            "module.get('bias', 0.0)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "jack/util/tf/pairwise_losses.py": {
        "tensorflow": {
            "relu_22": {
                "variable": {
                    "value": "hinge_losses",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "margin - positive_scores + negative_scores",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_23": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hinge_losses",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.relu(margin - positive_scores + negative_scores)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_40": {
                "variable": {
                    "value": "logistic_losses",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 + tf.exp(1 - positive_scores + negative_scores)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_41": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logistic_losses",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.log(1 + tf.exp(1 - positive_scores + negative_scores))",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_58": {
                "variable": {
                    "value": "mce_losses",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-positive_scores + negative_scores",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_59": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mce_losses",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.sigmoid(-positive_scores + negative_scores)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_78": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "square_square_losses",
                    "type": "Name",
                    "possible_values": [
                        [
                            "-positive_scores + tf.nn.relu(margin + negative_scores) ** 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_97": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "square_exponential_losses",
                    "type": "Name",
                    "possible_values": [
                        [
                            "-positive_scores + gamma * tf.exp(negative_scores)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exp_40": {
                "x": {
                    "value": "1 - positive_scores + negative_scores",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_77": {
                "features": {
                    "value": "margin + negative_scores",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_96": {
                "x": {
                    "value": "negative_scores",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/rnn.py": {
        "tensorflow": {
            "constant_initializer_8": {
                "variable": {
                    "value": "projection_initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.concatenate([np.eye(size), np.eye(size)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_13": {
                "variable": {
                    "value": "projected",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "encoded",
                    "type": "Name",
                    "possible_values": [
                        [
                            "fused_birnn(fused_rnn, inputs, sequence_length=length, dtype=tf.float32, time_major=False)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(encoded, 2)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "projection_initializer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.constant_initializer(np.concatenate([np.eye(size), np.eye(size)]))",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "projection_scope",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reverse_sequence_21": {
                "variable": {
                    "value": "rev_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "sequence_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.cast(sequence_length, tf.int32)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reverse_sequence_24": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "rev_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_lengths": {
                    "value": "sequence_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.cast(sequence_length, tf.int32)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_11": {
                "variable": {
                    "value": "encoded",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "encoded",
                    "type": "Name",
                    "possible_values": [
                        [
                            "fused_birnn(fused_rnn, inputs, sequence_length=length, dtype=tf.float32, time_major=False)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(encoded, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_19": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_26": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reverse_sequence(rev_outputs, sequence_length, 0, 1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(outputs, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_33": {
                "variable": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.cast(sequence_length, tf.int32)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMCell_109": {
                "variable": {
                    "value": "cell_fw",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LSTMCell_114": {
                "variable": {
                    "value": "cell_bw",
                    "type": "Variable",
                    "possible_values": []
                },
                "units": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "state_is_tuple": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.contrib.layers.xavier_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_130": {
                "variable": {
                    "value": "(all_states_fw_bw, final_states_fw_bw)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LSTMCell(output_size, state_is_tuple=True, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.DropoutWrapper(cell=cell_fw, output_keep_prob=drop_keep_prob, input_keep_prob=drop_keep_prob, seed=1233)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LSTMCell(output_size, state_is_tuple=True, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.DropoutWrapper(cell=cell_bw, output_keep_prob=drop_keep_prob, input_keep_prob=drop_keep_prob, seed=1233)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "initial_state_fw": {
                    "value": "initial_state[0]",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "(None",
                            "MethodArgument"
                        ],
                        [
                            "(None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "initial_state_bw": {
                    "value": "initial_state[1]",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "(None",
                            "MethodArgument"
                        ],
                        [
                            "(None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_159": {
                "variable": {
                    "value": "transformed",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "units": {
                    "value": "num_gates * self._num_units",
                    "type": "BinOp",
                    "possible_values": []
                },
                "bias_initializer": {
                    "value": "tf.constant_initializer(self._constant_bias)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_162": {
                "variable": {
                    "value": "gates",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "transformed",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs, num_gates * self._num_units, bias_initializer=tf.constant_initializer(self._constant_bias))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_gates",
                    "type": "Name",
                    "possible_values": [
                        [
                            "3 if self._with_residual else 2",
                            "IfExp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_163": {
                "variable": {
                    "value": "forget_gate",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gates[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_9": {
                "name_or_scope": {
                    "value": "RNN",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "share_rnn",
                    "type": "Name",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "variable_scope_32": {
                "name_or_scope": {
                    "value": "scope or 'BiRNN'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "transpose_35": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_48": {
                "variable": {
                    "value": "outputs_fw",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "outputs_fw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(outputs_fw, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_49": {
                "variable": {
                    "value": "outputs_bw",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "outputs_bw",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(outputs_bw, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_71": {
                "name_or_scope": {
                    "value": "scope or 'paired_LSTM_seq1'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_78": {
                "name_or_scope": {
                    "value": "scope or 'paired_LSTM_seq2'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_108": {
                "name_or_scope": {
                    "value": "scope or 'reader'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "DropoutWrapper_121": {
                "variable": {
                    "value": "cell_fw",
                    "type": "Variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LSTMCell(output_size, state_is_tuple=True, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.DropoutWrapper(cell=cell_fw, output_keep_prob=drop_keep_prob, input_keep_prob=drop_keep_prob, seed=1233)",
                            "Call"
                        ]
                    ]
                },
                "output_keep_prob": {
                    "value": "drop_keep_prob",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "drop_keep_prob",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "seed": {
                    "value": "1233",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DropoutWrapper_125": {
                "variable": {
                    "value": "cell_bw",
                    "type": "Variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LSTMCell(output_size, state_is_tuple=True, initializer=tf.contrib.layers.xavier_initializer())",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.DropoutWrapper(cell=cell_bw, output_keep_prob=drop_keep_prob, input_keep_prob=drop_keep_prob, seed=1233)",
                            "Call"
                        ]
                    ]
                },
                "output_keep_prob": {
                    "value": "drop_keep_prob",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "drop_keep_prob",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "seed": {
                    "value": "1233",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_166": {
                "variable": {
                    "value": "residual_gate",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gates[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_168": {
                "variable": {
                    "value": "new_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, transformed_inputs, forget_gate, residual_gate]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_170": {
                "variable": {
                    "value": "new_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[transformed_inputs, forget_gate]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_195": {
                "variable": {
                    "value": "(base_inputs, transformed_inputs, forget_gate, residual_gate)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_199": {
                "variable": {
                    "value": "(transformed_inputs, forget_gate)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "inputs * (1.0 - residual_gate)",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "device_40": {
                "device_name": {
                    "value": "backward_device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_initializer_160": {
                "value": {
                    "value": "self._constant_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/segment.py": {
        "tensorflow": {
            "exp_18": {
                "variable": {
                    "value": "scores_exp",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "scores - tf.gather(max_per_partition, segment_ids)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_max_71": {
                "variable": {
                    "value": "max_per_partition",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "inputs_max",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(inputs, reduction_indices=list(range(1, len(inputs.get_shape()))))",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scan_86": {
                "variable": {
                    "value": "(_, selection)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "scan_fn",
                    "type": "Variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "(probs, segment_ids)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "(-sampled, False)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "unsorted_segment_max_11": {
                "variable": {
                    "value": "max_per_partition",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_max(scores, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_max_14": {
                "variable": {
                    "value": "max_per_partition",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "scores - tf.gather(max_per_partition, segment_ids)",
                            "BinOp"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_20": {
                "variable": {
                    "value": "scores_exp_sum_per_partition",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_sum(scores_exp, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_24": {
                "variable": {
                    "value": "scores_exp_sum_per_partition",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "scores_exp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.exp(scores)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "num_segments",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "tile_46": {
                "variable": {
                    "value": "row_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(rows), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, cols]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_any_50": {
                "variable": {
                    "value": "row_selected",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "is_max",
                    "type": "Call",
                    "possible_values": [
                        [
                            "segment_is_max(input, segment_ids)",
                            "Call"
                        ],
                        [
                            "segment_is_max(tf.cast(is_max, tf.int32) * (row_indices + 1), segment_ids)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_51": {
                "variable": {
                    "value": "row_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(row_selected)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_52": {
                "variable": {
                    "value": "rows_selected",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(row_selected, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_58": {
                "variable": {
                    "value": "selected_rows_is_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "is_max",
                    "type": "Call",
                    "possible_values": [
                        [
                            "segment_is_max(input, segment_ids)",
                            "Call"
                        ],
                        [
                            "segment_is_max(tf.cast(is_max, tf.int32) * (row_indices + 1), segment_ids)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "row_indices",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(rows), 1), [1, cols])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.where(row_selected))",
                            "Call"
                        ],
                        [
                            "tf.reshape(row_indices, [-1])",
                            "Call"
                        ],
                        [
                            "x[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "argmax_59": {
                "variable": {
                    "value": "col_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(selected_rows_is_max, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_68": {
                "variable": {
                    "value": "inputs_max",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "list(range(1, len(inputs.get_shape())))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_72": {
                "x": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.gather(max_per_partition, segment_ids)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_81": {
                "variable": {
                    "value": "prev_v",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "acc[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "i",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "logical_and_83": {
                "variable": {
                    "value": "select",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(prev_v, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.greater_equal(prev_v + p, 0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "top_k_101": {
                "variable": {
                    "value": "(all_top_k_scores, all_top_k_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "k": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tile_102": {
                "variable": {
                    "value": "rows",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.shape(input)[0], dtype=tf.int32), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_104": {
                "variable": {
                    "value": "result_rows",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_105": {
                "variable": {
                    "value": "result_columns",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_106": {
                "variable": {
                    "value": "result_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[k]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scan_134": {
                "variable": {
                    "value": "(result_rows, result_columns, result_scores, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fn": {
                    "value": "scan_fn",
                    "type": "Variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "(rows, segment_ids, all_top_k_scores, all_top_k_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "(result_rows, result_columns, result_scores, last_index)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "squeeze_138": {
                "variable": {
                    "value": "to_gather",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.where(segment_ids[1:] - segment_ids[:-1] > 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_139": {
                "variable": {
                    "value": "to_gather",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[to_gather, tf.shape(segment_ids, out_type=tf.int64) - 1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_9": {
                "input_tensor": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_12": {
                "input": {
                    "value": "tf.gather(max_per_partition, segment_ids)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_15": {
                "params": {
                    "value": "max_per_partition",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_max(tf.reduce_max(scores, axis=1), segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_max(scores, segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_max(inputs_max, segment_ids, num_segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "name_scope_33": {
                "name": {
                    "value": "segment_argmax",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "variable": {
                    "value": "row_indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "row_indices",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(rows), 1), [1, cols])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(tf.where(row_selected))",
                            "Call"
                        ],
                        [
                            "tf.reshape(row_indices, [-1])",
                            "Call"
                        ],
                        [
                            "x[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_66": {
                "input_tensor": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_72": {
                "params": {
                    "value": "max_per_partition",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_max(tf.reduce_max(scores, axis=1), segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_max(scores, segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_max(inputs_max, segment_ids, num_segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_76": {
                "input_tensor": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "name_scope_100": {
                "name": {
                    "value": "segment_top_k",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_11": {
                "input_tensor": {
                    "value": "scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "scores - tf.gather(max_per_partition, segment_ids)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_12": {
                "params": {
                    "value": "max_per_partition",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_max(tf.reduce_max(scores, axis=1), segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_max(scores, segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_max(inputs_max, segment_ids, num_segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_sum_20": {
                "input_tensor": {
                    "value": "scores_exp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.exp(scores)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_22": {
                "input": {
                    "value": "tf.gather(scores_exp_sum_per_partition, segment_ids)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_25": {
                "params": {
                    "value": "scores_exp_sum_per_partition",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_sum(tf.reduce_sum(scores_exp, axis=1), segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_sum(scores_exp, segment_ids, num_segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_34": {
                "input_tensor": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_44": {
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_45": {
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_46": {
                "input": {
                    "value": "tf.range(rows)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "where_51": {
                "condition": {
                    "value": "row_selected",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_any(is_max, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_52": {
                "x": {
                    "value": "row_selected",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_any(is_max, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_55": {
                "control_inputs": {
                    "value": "[tf.assert_equal(rows_selected, num_partitions)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_59": {
                "x": {
                    "value": "selected_rows_is_max",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(is_max, row_indices)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_82": {
                "indices": {
                    "value": "i",
                    "type": "Variable",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_segments",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                },
                "on_value": {
                    "value": "p",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "less_83": {
                "x": {
                    "value": "prev_v",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(acc[0], i)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "greater_equal_83": {
                "x": {
                    "value": "prev_v + p",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_102": {
                "input": {
                    "value": "tf.range(tf.shape(input)[0], dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_109": {
                "values": {
                    "value": "[old[:-1], tf.expand_dims(new, 0)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_120": {
                "variable": {
                    "value": "new_result_row",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[result_row, row_indices]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_121": {
                "variable": {
                    "value": "new_result_column",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[result_column, col_indices]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_122": {
                "variable": {
                    "value": "new_result_score",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[result_score, top_k_scores]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "top_k_123": {
                "variable": {
                    "value": "(new_result_score, new_top_k_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "new_result_score",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([result_score, top_k_scores], 0)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_124": {
                "variable": {
                    "value": "new_result_row",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_result_row",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([result_row, row_indices], 0)",
                            "Call"
                        ],
                        [
                            "tf.gather(new_result_row, new_top_k_indices[:k])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "new_top_k_indices[:k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_125": {
                "variable": {
                    "value": "new_result_column",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_result_column",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([result_column, col_indices], 0)",
                            "Call"
                        ],
                        [
                            "tf.gather(new_result_column, new_top_k_indices[:k])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "new_top_k_indices[:k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cond_129": {
                "pred": {
                    "value": "segment_idx > last_index",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (row_indices, col_indices, top_k_scores, segment_idx)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "merge",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "where_138": {
                "condition": {
                    "value": "segment_ids[1:] - segment_ids[:-1] > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "gather_141": {
                "params": {
                    "value": "result_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.zeros([k], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "to_gather",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.where(segment_ids[1:] - segment_ids[:-1] > 0))",
                            "Call"
                        ],
                        [
                            "tf.concat([to_gather, tf.shape(segment_ids, out_type=tf.int64) - 1], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_22": {
                "params": {
                    "value": "scores_exp_sum_per_partition",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_sum(tf.reduce_sum(scores_exp, axis=1), segment_ids, num_segments)",
                            "Call"
                        ],
                        [
                            "tf.unsorted_segment_sum(scores_exp, segment_ids, num_segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cast_47": {
                "x": {
                    "value": "is_max",
                    "type": "Call",
                    "possible_values": [
                        [
                            "segment_is_max(input, segment_ids)",
                            "Call"
                        ],
                        [
                            "segment_is_max(tf.cast(is_max, tf.int32) * (row_indices + 1), segment_ids)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_102": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assert_equal_55": {
                "x": {
                    "value": "rows_selected",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.cast(row_selected, tf.int64))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_partitions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_ids) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_109": {
                "input": {
                    "value": "new",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_139": {
                "input": {
                    "value": "segment_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_102": {
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/sequence_encoder.py": {
        "tensorflow": {
            "concat_96": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn.fused_birnn(fused_rnn, sequence, seq_length, dtype=tf.float32, scope='rnn')[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(output, size, kernel_initializer=projection_initializer, name='projection')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_block(output, repr_dim, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv1d(inputs, f, 1, padding='SAME', name=name)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, channels, dilation, conv_width, name=name + '_' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.nn.atrous_conv2d(tf.expand_dims(inputs, 1), f, dilation, 'SAME', name=name)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output, 1)",
                            "Call"
                        ],
                        [
                            "output * tf.sigmoid(gate)",
                            "BinOp"
                        ],
                        [
                            "_convolutional_glu_block(inputs, out_size, name='conv_dim_reduction')",
                            "Call"
                        ],
                        [
                            "_residual_dilated_convolution_block(output, d, conv_width, name='dilated_conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, out_size, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_filter'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[conv_width, channels, out_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv1d_134": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 1)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "f",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable(name + '_filter', [conv_width, channels, out_channels])",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name + '_filter', [1, conv_width, channels, out_channels * 2])",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "'encoder'",
                            "MethodArgument"
                        ],
                        [
                            "'bi_sru'",
                            "MethodArgument"
                        ],
                        [
                            "'conv'",
                            "MethodArgument"
                        ],
                        [
                            "'dilated_conv'",
                            "MethodArgument"
                        ],
                        [
                            "'conv_glu'",
                            "MethodArgument"
                        ],
                        [
                            "'gldr_network'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_139": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_142": {
                "variable": {
                    "value": "depthwise_filter",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "depthwise_filter",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, conv_width, shapes[-1], 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_145": {
                "variable": {
                    "value": "pointwise_filter",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "pointwise_filter",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, shapes[-1], repr_dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "separable_conv2d_147": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 1)",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "depthwise_filter",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable('depthwise_filter', (1, conv_width, shapes[-1], 1), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "pointwise_filter",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable('pointwise_filter', (1, 1, shapes[-1], repr_dim), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "(1, 1, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_152": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.separable_conv2d(inputs, depthwise_filter, pointwise_filter, strides=(1, 1, 1, 1), padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(outputs, 1)",
                            "Call"
                        ],
                        [
                            "outputs + b",
                            "BinOp"
                        ],
                        [
                            "activation(outputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_174": {
                "variable": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '_filter'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, conv_width, channels, out_channels * 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "atrous_conv2d_175": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.expand_dims(inputs, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "filters": {
                    "value": "f",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable(name + '_filter', [conv_width, channels, out_channels])",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name + '_filter', [1, conv_width, channels, out_channels * 2])",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dilation",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "'encoder'",
                            "MethodArgument"
                        ],
                        [
                            "'bi_sru'",
                            "MethodArgument"
                        ],
                        [
                            "'conv'",
                            "MethodArgument"
                        ],
                        [
                            "'dilated_conv'",
                            "MethodArgument"
                        ],
                        [
                            "'conv_glu'",
                            "MethodArgument"
                        ],
                        [
                            "'gldr_network'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "squeeze_176": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn.fused_birnn(fused_rnn, sequence, seq_length, dtype=tf.float32, scope='rnn')[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(output, size, kernel_initializer=projection_initializer, name='projection')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_block(output, repr_dim, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv1d(inputs, f, 1, padding='SAME', name=name)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, channels, dilation, conv_width, name=name + '_' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.nn.atrous_conv2d(tf.expand_dims(inputs, 1), f, dilation, 'SAME', name=name)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output, 1)",
                            "Call"
                        ],
                        [
                            "output * tf.sigmoid(gate)",
                            "BinOp"
                        ],
                        [
                            "_convolutional_glu_block(inputs, out_size, name='conv_dim_reduction')",
                            "Call"
                        ],
                        [
                            "_residual_dilated_convolution_block(output, d, conv_width, name='dilated_conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, out_size, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_177": {
                "variable": {
                    "value": "(output, gate)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn.fused_birnn(fused_rnn, sequence, seq_length, dtype=tf.float32, scope='rnn')[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(output, size, kernel_initializer=projection_initializer, name='projection')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_block(output, repr_dim, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv1d(inputs, f, 1, padding='SAME', name=name)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, channels, dilation, conv_width, name=name + '_' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.nn.atrous_conv2d(tf.expand_dims(inputs, 1), f, dilation, 'SAME', name=name)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output, 1)",
                            "Call"
                        ],
                        [
                            "output * tf.sigmoid(gate)",
                            "BinOp"
                        ],
                        [
                            "_convolutional_glu_block(inputs, out_size, name='conv_dim_reduction')",
                            "Call"
                        ],
                        [
                            "_residual_dilated_convolution_block(output, d, conv_width, name='dilated_conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, out_size, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_221": {
                "variable": {
                    "value": "pos",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.range(0.0, tf.to_float(tf.reduce_max(lengths)), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_224": {
                "variable": {
                    "value": "enc",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.concat([tf.sin(pos / denom), tf.cos(pos / denom)], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_98": {
                "variable": {
                    "value": "projection_initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.concatenate([np.eye(size), np.eye(size)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_99": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn.fused_birnn(fused_rnn, sequence, seq_length, dtype=tf.float32, scope='rnn')[0]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(output, size, kernel_initializer=projection_initializer, name='projection')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_block(output, repr_dim, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv1d(inputs, f, 1, padding='SAME', name=name)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, channels, dilation, conv_width, name=name + '_' + str(i))",
                            "Call"
                        ],
                        [
                            "tf.nn.atrous_conv2d(tf.expand_dims(inputs, 1), f, dilation, 'SAME', name=name)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(output, 1)",
                            "Call"
                        ],
                        [
                            "output * tf.sigmoid(gate)",
                            "BinOp"
                        ],
                        [
                            "_convolutional_glu_block(inputs, out_size, name='conv_dim_reduction')",
                            "Call"
                        ],
                        [
                            "_residual_dilated_convolution_block(output, d, conv_width, name='dilated_conv_%d' % i)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "_convolutional_glu_block(output, out_size, conv_width=conv_width, name='conv_%d' % i)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "projection_initializer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.constant_initializer(np.concatenate([np.eye(size), np.eye(size)]))",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_154": {
                "variable": {
                    "value": "b",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "outputs.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_178": {
                "x": {
                    "value": "gate",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_175": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "range_221": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_224": {
                "values": {
                    "value": "[tf.sin(pos / denom), tf.cos(pos / denom)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_225": {
                "input": {
                    "value": "enc",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.concat([tf.sin(pos / denom), tf.cos(pos / denom)], 1), 0)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[tf.shape(inputs)[0], 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_22": {
                "name_or_scope": {
                    "value": "name",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "'encoder'",
                            "MethodArgument"
                        ],
                        [
                            "'bi_sru'",
                            "MethodArgument"
                        ],
                        [
                            "'conv'",
                            "MethodArgument"
                        ],
                        [
                            "'dilated_conv'",
                            "MethodArgument"
                        ],
                        [
                            "'conv_glu'",
                            "MethodArgument"
                        ],
                        [
                            "'gldr_network'",
                            "MethodArgument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_79": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_and(tf.greater(dropout, 0.0), tf.logical_not(is_eval))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(out, 1.0 - dropout, noise_shape=[tf.shape(out)[0], 1, tf.shape(out)[-1]])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : out",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "to_float_221": {
                "x": {
                    "value": "tf.reduce_max(lengths)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_17": {
                "name_or_scope": {
                    "value": "layernorm",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_initializer_154": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_max_221": {
                "input_tensor": {
                    "value": "lengths",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "sin_224": {
                "x": {
                    "value": "pos / denom",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cos_224": {
                "x": {
                    "value": "pos / denom",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_80": {
                "x": {
                    "value": "tf.greater(dropout, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_not(is_eval)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_225": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_80": {
                "x": {
                    "value": "dropout",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "logical_not_80": {
                "x": {
                    "value": "is_eval",
                    "type": "Name",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dropout_81": {
                "x": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "encoder(sequence, seq_length, repr_dim, module, num_layers - 1, reuse, residual, activation, layer_norm, name, dropout=dropout, is_eval=is_eval, **kwargs)",
                            "Call"
                        ],
                        [
                            "encoder(out, seq_length, repr_dim, module, 1, reuse, residual, activation, layer_norm, name + str(num_layers - 1), dropout=dropout, is_eval=is_eval, **kwargs)",
                            "Call"
                        ],
                        [
                            "bi_lstm(repr_dim, sequence, seq_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "bi_sru(repr_dim, sequence, seq_length, with_residual, **kwargs)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "bi_rnn(repr_dim, tf.nn.rnn_cell.BasicRNNCell(repr_dim, activation_from_string(activation)), sequence, seq_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "out + sequence",
                            "BinOp"
                        ],
                        [
                            "tf.cond(tf.logical_and(tf.greater(dropout, 0.0), tf.logical_not(is_eval)), lambda : tf.nn.dropout(out, 1.0 - dropout, noise_shape=[tf.shape(out)[0], 1, tf.shape(out)[-1]]), lambda : out)",
                            "Call"
                        ],
                        [
                            "bi_rnn(repr_dim, tf.contrib.rnn.GRUBlockCell(repr_dim), sequence, seq_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "gated_linear_dilated_residual_network(repr_dim, sequence, **kwargs)",
                            "Call"
                        ],
                        [
                            "convnet(repr_dim, sequence, 1, activation=activation_from_string(activation), **kwargs)",
                            "Call"
                        ],
                        [
                            "gated_linear_convnet(repr_dim, sequence, 1, **kwargs)",
                            "Call"
                        ],
                        [
                            "depthwise_separable_convolution(repr_dim, sequence, activation=activation_from_string(activation), **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(sequence, repr_dim)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "highway_network(sequence, num_layers, activation_from_string(activation))",
                            "Call"
                        ],
                        [
                            "positional_encoding(sequence, seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat(outs, 2) if num_attn > 1 else outs[0]",
                            "IfExp"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - dropout",
                    "type": "BinOp",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "[tf.shape(out)[0], 1, tf.shape(out)[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BasicRNNCell_33": {
                "num_units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs.get_shape()[-1].value",
                            "Attribute"
                        ],
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "activation": {
                    "value": "activation_from_string(activation)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GRUBlockCell_36": {
                "x": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs.get_shape()[-1].value",
                            "Attribute"
                        ],
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_81": {
                "input": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "encoder(sequence, seq_length, repr_dim, module, num_layers - 1, reuse, residual, activation, layer_norm, name, dropout=dropout, is_eval=is_eval, **kwargs)",
                            "Call"
                        ],
                        [
                            "encoder(out, seq_length, repr_dim, module, 1, reuse, residual, activation, layer_norm, name + str(num_layers - 1), dropout=dropout, is_eval=is_eval, **kwargs)",
                            "Call"
                        ],
                        [
                            "bi_lstm(repr_dim, sequence, seq_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "bi_sru(repr_dim, sequence, seq_length, with_residual, **kwargs)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "bi_rnn(repr_dim, tf.nn.rnn_cell.BasicRNNCell(repr_dim, activation_from_string(activation)), sequence, seq_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "out + sequence",
                            "BinOp"
                        ],
                        [
                            "tf.cond(tf.logical_and(tf.greater(dropout, 0.0), tf.logical_not(is_eval)), lambda : tf.nn.dropout(out, 1.0 - dropout, noise_shape=[tf.shape(out)[0], 1, tf.shape(out)[-1]]), lambda : out)",
                            "Call"
                        ],
                        [
                            "bi_rnn(repr_dim, tf.contrib.rnn.GRUBlockCell(repr_dim), sequence, seq_length, **kwargs)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "gated_linear_dilated_residual_network(repr_dim, sequence, **kwargs)",
                            "Call"
                        ],
                        [
                            "convnet(repr_dim, sequence, 1, activation=activation_from_string(activation), **kwargs)",
                            "Call"
                        ],
                        [
                            "gated_linear_convnet(repr_dim, sequence, 1, **kwargs)",
                            "Call"
                        ],
                        [
                            "depthwise_separable_convolution(repr_dim, sequence, activation=activation_from_string(activation), **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(sequence, repr_dim)",
                            "Call"
                        ],
                        [
                            "activation_from_string(activation)(out)",
                            "Call"
                        ],
                        [
                            "highway_network(sequence, num_layers, activation_from_string(activation))",
                            "Call"
                        ],
                        [
                            "positional_encoding(sequence, seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat(outs, 2) if num_attn > 1 else outs[0]",
                            "IfExp"
                        ]
                    ]
                }
            },
            "dense_51": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "sequence",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.contrib.layers.layer_norm(sequence, scope=str(num_layernorms))",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "repr_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs.get_shape()[-1].value",
                            "Attribute"
                        ],
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_63": {
                "values": {
                    "value": "outs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_60": {
                "name_or_scope": {
                    "value": "str(i)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/tf/simple.py": {
        "tensorflow": {}
    },
    "jack/util/tf/xqa.py": {
        "tensorflow": {
            "gather_nd_15": {
                "variable": {
                    "value": "start_probs",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "start_probs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "segment_softmax(start_scores, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(start_probs, tf.stack([answer2support, start], 1))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.stack([answer2support, start], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_19": {
                "variable": {
                    "value": "is_aligned",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(end_scores)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "num_answers",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.shape(answer_span)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cond_20": {
                "variable": {
                    "value": "end_probs",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_aligned",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.equal(tf.shape(end_scores)[0], num_answers)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.gather_nd(tf.nn.softmax(end_scores), tf.stack([tf.range(num_answers, dtype=tf.int32), end], 1))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.gather_nd(segment_softmax(end_scores, support2question), tf.stack([answer2support, end], 1))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "gather_26": {
                "variable": {
                    "value": "answer2question",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "answer2support",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_max_10": {
                "input_tensor": {
                    "value": "support2question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_15": {
                "values": {
                    "value": "[answer2support, start]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_18": {
                "input": {
                    "value": "answer_span",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_mean_37": {
                "input_tensor": {
                    "value": "tf.log(tf.maximum(1e-06, span_probs + 1e-06))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_19": {
                "input": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_nd_22": {
                "params": {
                    "value": "tf.nn.softmax(end_scores)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.stack([tf.range(num_answers, dtype=tf.int32), end], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_nd_23": {
                "params": {
                    "value": "segment_softmax(end_scores, support2question)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.stack([answer2support, end], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unsorted_segment_sum_29": {
                "data": {
                    "value": "start_probs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "segment_softmax(start_scores, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(start_probs, tf.stack([answer2support, start], 1))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "answer2question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(support2question, answer2support)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_questions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(support2question) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_30": {
                "data": {
                    "value": "end_probs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.cond(is_aligned, lambda : tf.gather_nd(tf.nn.softmax(end_scores), tf.stack([tf.range(num_answers, dtype=tf.int32), end], 1)), lambda : tf.gather_nd(segment_softmax(end_scores, support2question), tf.stack([answer2support, end], 1)))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "answer2question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(support2question, answer2support)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_questions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(support2question) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_max_33": {
                "data": {
                    "value": "start_probs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "segment_softmax(start_scores, support2question)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(start_probs, tf.stack([answer2support, start], 1))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "answer2question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(support2question, answer2support)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_questions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(support2question) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unsorted_segment_max_34": {
                "data": {
                    "value": "end_probs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.cond(is_aligned, lambda : tf.gather_nd(tf.nn.softmax(end_scores), tf.stack([tf.range(num_answers, dtype=tf.int32), end], 1)), lambda : tf.gather_nd(segment_softmax(end_scores, support2question), tf.stack([answer2support, end], 1)))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "answer2question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(support2question, answer2support)",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "num_questions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_max(support2question) + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_37": {
                "x": {
                    "value": "tf.maximum(1e-06, span_probs + 1e-06)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_22": {
                "logits": {
                    "value": "end_scores",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_22": {
                "values": {
                    "value": "[tf.range(num_answers, dtype=tf.int32), end]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_23": {
                "values": {
                    "value": "[answer2support, end]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "maximum_37": {
                "x": {
                    "value": "1e-06",
                    "type": "Constant",
                    "possible_values": []
                },
                "y": {
                    "value": "span_probs + 1e-06",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "range_22": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "projects/knowledge_integration/nli.py": {
        "tensorflow": {
            "concat_319": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[outputs[0], outputs[1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_322": {
                "variable": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "hidden",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(outputs, size, tf.nn.relu, name='hidden') * tf.expand_dims(misc.mask_for_lengths(support_length, max_length=tf.shape(outputs)[1], mask_right=False, value=1.0), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(hidden, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_324": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "hidden",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.layers.dense(outputs, size, tf.nn.relu, name='hidden') * tf.expand_dims(misc.mask_for_lengths(support_length, max_length=tf.shape(outputs)[1], mask_right=False, value=1.0), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_max(hidden, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['answer_size']",
                            "Subscript"
                        ]
                    ]
                },
                "name": {
                    "value": "classification",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_290": {
                "variable": {
                    "value": "emb_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "ids": {
                    "value": "reading_sequence_offset[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "embedded_question",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_292": {
                "variable": {
                    "value": "emb_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "ids": {
                    "value": "reading_sequence_offset[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "embedded_support",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_320": {
                "inputs": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([outputs[0], outputs[1]], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(hidden, num_classes, name='classification')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "hidden",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_320": {
                "input": {
                    "value": "misc.mask_for_lengths(support_length, max_length=tf.shape(outputs)[1], mask_right=False, value=1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "argmax_299": {
                "input": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nli_model(size, num_classes, emb_question, question_length, emb_support, support_length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_305": {
                "logits": {
                    "value": "tensors.logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "labels": {
                    "value": "tensors.target_index",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_321": {
                "input": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.concat([outputs[0], outputs[1]], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(hidden, num_classes, name='classification')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "projects/knowledge_integration/qa/definition_model.py": {
        "tensorflow": {
            "embedding_lookup_224": {
                "variable": {
                    "value": "emb_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, new_word_embeddings, tensors.word_chars, tensors.word_char_length, len(shared_resources.char_vocab))",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : new_word_embeddings, lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "reading_sequence_offset[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "embedded_question",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_226": {
                "variable": {
                    "value": "emb_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, new_word_embeddings, tensors.word_chars, tensors.word_char_length, len(shared_resources.char_vocab))",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : new_word_embeddings, lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "reading_sequence_offset[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "embedded_support",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_262": {
                "variable": {
                    "value": "span",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[doc_idx, predicted_start_pointer, predicted_end_pointer]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_264": {
                "variable": {
                    "value": "span",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[doc_idx, predicted_start_pointer, predicted_end_pointer]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_194": {
                "variable": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "word_embeddings",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.zeros([len(rev_vocab), self.emb_matrix.shape[1]])",
                            "Call"
                        ],
                        [
                            "tensors.word_embeddings",
                            "Attribute"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "embeddings_projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_249": {
                "variable": {
                    "value": "topk",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "topk",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "shared_resources.config.get('topk', 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_251": {
                "variable": {
                    "value": "topk_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "topk_setter",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_202": {
                "variable": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tensors.is_eval",
                            "Attribute"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : new_word_embeddings",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_230": {
                "input": {
                    "value": "tensors.word_in_question",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_240": {
                "name_or_scope": {
                    "value": "answer_layer",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_204": {
                "x": {
                    "value": "new_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, new_word_embeddings, tensors.word_chars, tensors.word_char_length, len(shared_resources.char_vocab))",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : new_word_embeddings, lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1.0 - dropout",
                            "BinOp"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "[1, size]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "projects/knowledge_integration/qa/shared.py": {
        "tensorflow": {
            "embedding_lookup_401": {
                "variable": {
                    "value": "emb_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, new_word_embeddings, tensors.word_chars, tensors.word_char_length, len(shared_resources.char_vocab))",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : new_word_embeddings, lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "reading_sequence_offset[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "embedded_question",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "embedding_lookup_403": {
                "variable": {
                    "value": "emb_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, new_word_embeddings, tensors.word_chars, tensors.word_char_length, len(shared_resources.char_vocab))",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : new_word_embeddings, lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "reading_sequence_offset[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "embedded_support",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_440": {
                "variable": {
                    "value": "span",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[doc_idx, predicted_start_pointer, predicted_end_pointer]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dense_371": {
                "variable": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "word_embeddings",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.zeros([len(rev_vocab), self.emb_matrix.shape[1]])",
                            "Call"
                        ],
                        [
                            "tensors.word_embeddings",
                            "Attribute"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "embeddings_projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_427": {
                "variable": {
                    "value": "topk",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "topk",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "shared_resources.config.get('topk', 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "placeholder_429": {
                "variable": {
                    "value": "topk_p",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "topk_setter",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_379": {
                "variable": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tensors.is_eval",
                            "Attribute"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : new_word_embeddings",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_407": {
                "input": {
                    "value": "tensors.word_in_question",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_408": {
                "input": {
                    "value": "tf.ones(tf.shape(emb_question)[:2], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_418": {
                "name_or_scope": {
                    "value": "answer_layer",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_408": {
                "shape": {
                    "value": "tf.shape(emb_question)[:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_381": {
                "x": {
                    "value": "new_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, new_word_embeddings, tensors.word_chars, tensors.word_char_length, len(shared_resources.char_vocab))",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : new_word_embeddings, lambda : tf.nn.dropout(new_word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1.0 - dropout",
                            "BinOp"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "[1, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_408": {
                "input": {
                    "value": "emb_question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(new_word_embeddings, reading_sequence_offset[1], name='embedded_question')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "projects/knowledge_integration/scripts/extract_side_information_for_dataset.py": {
        "tensorflow": {
            "DEFINE_string_14": {
                "name": {
                    "value": "dataset",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "dataset file.",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_15": {
                "name": {
                    "value": "output",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "output json.",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_16": {
                "name": {
                    "value": "loader",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "squad",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "loader type.",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_17": {
                "name": {
                    "value": "knowledge_store",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "assertion store.",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_18": {
                "name": {
                    "value": "load_dir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "path to reader.",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_19": {
                "name": {
                    "value": "batch_size",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "64",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "batch size.",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "projects/knowledge_integration/scripts/extract_wikipedia_short_abstract.py": {
        "tensorflow": {
            "DEFINE_string_49": {
                "name": {
                    "value": "knowledge_store_path",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "directory to assertion store",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_50": {
                "name": {
                    "value": "short_abstracts",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "path to dbpedia short abstracts",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "anchor_texts",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "path to dbpedia anchor texts",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_52": {
                "name": {
                    "value": "transitive_redirects",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "path to dbpedia transitive redirects",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_53": {
                "name": {
                    "value": "max_articles_per_anchor",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "maximum number of articles per anchor",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_54": {
                "name": {
                    "value": "min_num_anchor_per_article",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "minimum number of mentions per anchor for an article",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_56": {
                "name": {
                    "value": "max_abstract_tokens",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "50",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "maximum number of tokens to take from abstract",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "projects/knowledge_integration/tfutil.py": {
        "tensorflow": {
            "expand_dims_36": {
                "variable": {
                    "value": "offsets",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.range(0, num_words * batch_size, num_words)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_44": {
                "variable": {
                    "value": "word2lemma_off",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "word2lemma_off",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(word2lemma, [1, -1]), [batch_size, 1]) + offsets",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(word2lemma_off, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_88": {
                "variable": {
                    "value": "char_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "char_word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "conv_char_embedding(num_chars, size, unique_word_chars, unique_word_char_length)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(char_word_embeddings)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_89": {
                "variable": {
                    "value": "gate",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([word_embeddings, char_word_embeddings], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "embeddings_gating",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_12": {
                "input_tensor": {
                    "value": "s2b",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dense_18": {
                "variable": {
                    "value": "word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, word_embeddings, unique_word_chars, unique_word_char_length, num_chars)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : word_embeddings, lambda : tf.nn.dropout(word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ],
                        [
                            "word_embeddings * gate + (1.0 - gate) * char_word_embeddings",
                            "BinOp"
                        ]
                    ]
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "embeddings_projection",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_27": {
                "variable": {
                    "value": "ctxt_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, word_embeddings, unique_word_chars, unique_word_char_length, num_chars)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : word_embeddings, lambda : tf.nn.dropout(word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ],
                        [
                            "word_embeddings * gate + (1.0 - gate) * char_word_embeddings",
                            "BinOp"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_23": {
                "variable": {
                    "value": "word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_eval",
                    "type": "Name",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : word_embeddings",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nn.dropout(word_embeddings, keep_prob, [1, size])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "shape_33": {
                "input": {
                    "value": "word2lemma",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tile_43": {
                "input": {
                    "value": "tf.reshape(word2lemma, [1, -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_46": {
                "name_or_scope": {
                    "value": "refinement",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cond_74": {
                "variable": {
                    "value": "new_word_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "num_seq > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "non_zero_batchsize_op",
                    "type": "Variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.zeros_like(ctxt_word_embeddings)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "dense_77": {
                "variable": {
                    "value": "gate",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "tf.concat([ctxt_word_embeddings, new_word_embeddings], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "units": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "embeddings_gating",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_89": {
                "values": {
                    "value": "[word_embeddings, char_word_embeddings]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_12": {
                "values": {
                    "value": "[tf.shape(s)[0] if s2b is None else tf.reduce_max(s2b) + 1 for (s, s2b) in zip(reading_sequence, reading_sequence_2_batch)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "stack_27": {
                "values": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_43": {
                "tensor": {
                    "value": "word2lemma",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "embedding_lookup_54": {
                "variable": {
                    "value": "encoded",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "ctxt_word_embeddings",
                    "type": "Name",
                    "possible_values": [
                        [
                            "word_embeddings",
                            "Name"
                        ],
                        [
                            "tf.tile(word_embeddings, tf.stack([batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "ctxt_word_embeddings * 1.0",
                            "BinOp"
                        ],
                        [
                            "ctxt_word_embeddings * gate + (1.0 - gate) * new_word_embeddings",
                            "BinOp"
                        ]
                    ]
                },
                "ids": {
                    "value": "seq",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "constant_57": {
                "variable": {
                    "value": "mode_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[one_hot]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_58": {
                "variable": {
                    "value": "mode_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mode_feature",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.constant([[one_hot]], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tile(mode_feature, tf.stack([num_seq, max_length, 1]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.stack([num_seq, max_length, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_59": {
                "variable": {
                    "value": "encoded",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[encoded, mode_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_67": {
                "variable": {
                    "value": "seq_lemmas",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "word2lemma_off",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(word2lemma, [1, -1]), [batch_size, 1]) + offsets",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(word2lemma_off, [-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "tf.reshape(seq, [-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unsorted_segment_max_68": {
                "variable": {
                    "value": "new_lemma_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reshape(encoded, [-1, size])",
                    "type": "Call",
                    "possible_values": []
                },
                "segment_ids": {
                    "value": "seq_lemmas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gather(word2lemma_off, tf.reshape(seq, [-1]))",
                            "Call"
                        ]
                    ]
                },
                "num_segments": {
                    "value": "tf.reduce_max(word2lemma_off) + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_70": {
                "variable": {
                    "value": "new_lemma_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "new_lemma_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_max(tf.reshape(encoded, [-1, size]), seq_lemmas, tf.reduce_max(word2lemma_off) + 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(new_lemma_embeddings)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_90": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_40": {
                "params": {
                    "value": "offsets",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.range(0, num_words * batch_size, num_words), 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "s2b",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "shape_50": {
                "input": {
                    "value": "length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "gather_72": {
                "params": {
                    "value": "new_lemma_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.unsorted_segment_max(tf.reshape(encoded, [-1, size]), seq_lemmas, tf.reduce_max(word2lemma_off) + 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(new_lemma_embeddings)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "word2lemma_off",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(word2lemma, [1, -1]), [batch_size, 1]) + offsets",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(word2lemma_off, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_77": {
                "values": {
                    "value": "[ctxt_word_embeddings, new_word_embeddings]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_25": {
                "x": {
                    "value": "word_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.layers.dense(word_embeddings, size, activation=tf.nn.relu, name='embeddings_projection')",
                            "Call"
                        ],
                        [
                            "word_with_char_embed(size, word_embeddings, unique_word_chars, unique_word_char_length, num_chars)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_eval, lambda : word_embeddings, lambda : tf.nn.dropout(word_embeddings, keep_prob, [1, size]))",
                            "Call"
                        ],
                        [
                            "word_embeddings * gate + (1.0 - gate) * char_word_embeddings",
                            "BinOp"
                        ]
                    ]
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "noise_shape": {
                    "value": "[1, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_53": {
                "input": {
                    "value": "seq",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_58": {
                "values": {
                    "value": "[num_seq, max_length, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_65": {
                "input": {
                    "value": "mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "misc.mask_for_lengths(length, max_length, mask_right=False, value=1.0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_67": {
                "tensor": {
                    "value": "seq",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_69": {
                "tensor": {
                    "value": "encoded",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.embedding_lookup(ctxt_word_embeddings, seq)",
                            "Call"
                        ],
                        [
                            "tf.concat([encoded, mode_feature], 2)",
                            "Call"
                        ],
                        [
                            "modular_encoder.modular_encoder(sequence_module, {'text': encoded}, {'text': length}, {'text': None}, size, 1.0 - keep_prob, is_eval)[0]['text']",
                            "Subscript"
                        ],
                        [
                            "encoded * tf.expand_dims(mask, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_like_75": {
                "input": {
                    "value": "ctxt_word_embeddings",
                    "type": "Name",
                    "possible_values": [
                        [
                            "word_embeddings",
                            "Name"
                        ],
                        [
                            "tf.tile(word_embeddings, tf.stack([batch_size, 1]))",
                            "Call"
                        ],
                        [
                            "ctxt_word_embeddings * 1.0",
                            "BinOp"
                        ],
                        [
                            "ctxt_word_embeddings * gate + (1.0 - gate) * new_word_embeddings",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_78": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_69": {
                "input_tensor": {
                    "value": "word2lemma_off",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.reshape(word2lemma, [1, -1]), [batch_size, 1]) + offsets",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(word2lemma_off, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_12": {
                "input": {
                    "value": "s",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "tests/jack/readers/test_fastqa.py": {
        "tensorflow": {
            "reset_default_graph_15": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tests/jack/readers/test_fastqa_loop.py": {
        "tensorflow": {
            "AdagradOptimizer_44": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "0.01",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reset_default_graph_16": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tests/jack/readers/test_kbp.py": {
        "tensorflow": {
            "variable_scope_15": {
                "name_or_scope": {
                    "value": "model_name",
                    "type": "Name",
                    "possible_values": [
                        [
                            "['transe', 'distmult', 'complex']",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "tests/jack/readers/test_readers.py": {
        "tensorflow": {
            "reset_default_graph_20": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_51": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "AdamOptimizer_54": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        },
        "torch": {
            "Adam_60": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "params",
                    "type": "Name",
                    "possible_values": [
                        [
                            "list(reader.model_module.prediction_module.parameters())",
                            "Call"
                        ]
                    ]
                },
                "lr": {
                    "value": "0.01",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "tests/jack/readers/test_serialization.py": {
        "tensorflow": {
            "reset_default_graph_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tests/test_readme.py": {
        "tensorflow": {
            "reset_default_graph_17": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_45": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "jack/core/torch.py": {
        "torch": {
            "load_93": {
                "variable": {
                    "value": "d",
                    "type": "Variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "device_count_82": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "save_88": {
                "obj": {
                    "value": "{'prediction_module': self.prediction_module.state_dict(), 'loss_module': self.loss_module.state_dict()}",
                    "type": "Dict",
                    "possible_values": []
                },
                "f": {
                    "value": "f",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "device_count_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_count_137": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "jack/readers/extractive_qa/torch/fastqa.py": {
        "torch": {
            "Parameter_82": {
                "variable": {
                    "value": "self._question_projection",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.cat([torch.eye(size), torch.eye(size)], dim=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_83": {
                "variable": {
                    "value": "self._support_projection",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.cat([torch.eye(size), torch.eye(size)], dim=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_132": {
                "variable": {
                    "value": "wiq_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "emb_question * v_wiqw",
                    "type": "BinOp",
                    "possible_values": []
                },
                "other": {
                    "value": "emb_support.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_135": {
                "variable": {
                    "value": "wiq_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "wiq_w.view(batch_size * max_question_length, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_138": {
                "variable": {
                    "value": "wiq_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "question_binary_mask.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "wiq_w",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.matmul(emb_question * v_wiqw, emb_support.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "wiq_w + support_mask.unsqueeze(1)",
                            "BinOp"
                        ],
                        [
                            "F.softmax(wiq_w.view(batch_size * max_question_length, -1), dim=1).view(batch_size, max_question_length, -1)",
                            "Call"
                        ],
                        [
                            "torch.matmul(question_binary_mask.unsqueeze(1), wiq_w).squeeze(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_138": {
                "variable": {
                    "value": "wiq_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_141": {
                "variable": {
                    "value": "support_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[word_in_question, wiq_w]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_152": {
                "variable": {
                    "value": "emb_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "emb_question",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cat([emb_question, char_emb_question], 2)",
                            "Call"
                        ],
                        [
                            "self._embedding_projection(emb_question)",
                            "Call"
                        ],
                        [
                            "self._embedding_highway(emb_question)",
                            "Call"
                        ],
                        [
                            "F.dropout(emb_question, dropout, training=not is_eval)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "dropout",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._shared_resources.config.get('dropout', 0.0)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "not is_eval",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dropout_153": {
                "variable": {
                    "value": "emb_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "emb_support",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cat([emb_support, char_emb_support], 2)",
                            "Call"
                        ],
                        [
                            "self._embedding_projection(emb_support)",
                            "Call"
                        ],
                        [
                            "self._embedding_highway(emb_support)",
                            "Call"
                        ],
                        [
                            "F.dropout(emb_support, dropout, training=not is_eval)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "dropout",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._shared_resources.config.get('dropout', 0.0)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "not is_eval",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_156": {
                "variable": {
                    "value": "emb_question_ext",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[emb_question, question_features]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_157": {
                "variable": {
                    "value": "emb_support_ext",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[emb_support, support_features]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tanh_165": {
                "variable": {
                    "value": "encoded_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.linear(encoded_support, self._support_projection)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_166": {
                "variable": {
                    "value": "encoded_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.linear(encoded_question, self._question_projection)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_174": {
                "variable": {
                    "value": "span",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[doc_idx, predicted_start_pointer, predicted_end_pointer]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_185": {
                "variable": {
                    "value": "self._linear_question_attention",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_187": {
                "variable": {
                    "value": "self._linear_q_start_q",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_188": {
                "variable": {
                    "value": "self._linear_q_start",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "2 * self._size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_189": {
                "variable": {
                    "value": "self._linear_start_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_191": {
                "variable": {
                    "value": "self._linear_q_end_q",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_192": {
                "variable": {
                    "value": "self._linear_q_end",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "3 * self._size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_193": {
                "variable": {
                    "value": "self._linear_end_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self._size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_205": {
                "variable": {
                    "value": "question_attention_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._linear_question_attention(encoded_question)",
                            "Call"
                        ],
                        [
                            "attention_scores.squeeze(2) + q_mask",
                            "BinOp"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_206": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "question_attention_weights.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "encoded_question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._bilstm(emb_question_ext)[0]",
                            "Subscript"
                        ],
                        [
                            "F.tanh(F.linear(encoded_question, self._question_projection))",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_206": {
                "variable": {
                    "value": "question_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_211": {
                "variable": {
                    "value": "start_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[question_state.unsqueeze(1) * encoded_support, encoded_support]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_239": {
                "variable": {
                    "value": "u_s",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "u_s",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.stack(u_s)",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_241": {
                "variable": {
                    "value": "end_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[encoded_support * u_s.unsqueeze(1), start_input]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_71": {
                "variable": {
                    "value": "self._embedding_projection",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "size + input_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "Parameter_73": {
                "variable": {
                    "value": "self._v_wiq_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(1, 1, input_size + size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_76": {
                "variable": {
                    "value": "self._v_wiq_w",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(1, 1, input_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_123": {
                "variable": {
                    "value": "emb_question",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[emb_question, char_emb_question]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_124": {
                "variable": {
                    "value": "emb_support",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[emb_support, char_emb_support]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_82": {
                "tensors": {
                    "value": "[torch.eye(size), torch.eye(size)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_83": {
                "tensors": {
                    "value": "[torch.eye(size), torch.eye(size)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_127": {
                "*size": {
                    "value": "batch_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "question_length.data.shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "float_tensor()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "linear_165": {
                "input": {
                    "value": "encoded_support",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._bilstm(emb_support_ext)[0]",
                            "Subscript"
                        ],
                        [
                            "F.tanh(F.linear(encoded_support, self._support_projection))",
                            "Call"
                        ],
                        [
                            "align(encoded_support)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self._support_projection",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_166": {
                "input": {
                    "value": "encoded_question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._bilstm(emb_question_ext)[0]",
                            "Subscript"
                        ],
                        [
                            "F.tanh(F.linear(encoded_question, self._question_projection))",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self._question_projection",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_173": {
                "*size": {
                    "value": "predicted_start_pointer.data.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out": {
                    "value": "long_tensor()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "index_select_221": {
                "input": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "answer2question",
                    "type": "Name",
                    "possible_values": [
                        [
                            "answer2question.type(long_tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_73": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "input_size + size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_76": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "input_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.embeddings.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "size",
                            "Name"
                        ]
                    ]
                }
            },
            "eye_82": {
                "n": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "eye_83": {
                "n": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "shared_resources.config['repr_dim']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "relu_214": {
                "input": {
                    "value": "q_start_state",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._linear_q_start(start_input) + self._linear_q_start_q(question_state).unsqueeze(1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "relu_244": {
                "input": {
                    "value": "q_end_state",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._linear_q_end(end_input) + self._linear_q_end_q(question_state).unsqueeze(1)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "jack/util/torch/embedding.py": {
        "torch": {
            "Embedding_17": {
                "variable": {
                    "value": "self._embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_chars",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Conv1d_19": {
                "variable": {
                    "value": "self._conv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "conv_width",
                    "type": "Name",
                    "possible_values": [
                        [
                            "5",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "math.floor(conv_width / 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_count_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "embedding_39": {
                "input": {
                    "value": "word_idxs.type(long_tensor)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "embedded_words",
                    "type": "Name",
                    "possible_values": [
                        [
                            "conv_out.max(2)[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "jack/util/torch/highway.py": {
        "torch": {
            "ModuleList_13": {
                "variable": {
                    "value": "self.nonlinear",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[nn.Linear(size, size) for _ in range(num_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "ModuleList_15": {
                "variable": {
                    "value": "self.linear",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[nn.Linear(size, size) for _ in range(num_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "ModuleList_17": {
                "variable": {
                    "value": "self.gate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[nn.Linear(size, size) for _ in range(num_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "sigmoid_31": {
                "variable": {
                    "value": "gate",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.gate[layer](x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_13": {
                "in_features": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Linear_15": {
                "in_features": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Linear_17": {
                "in_features": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/torch/misc.py": {
        "torch": {
            "arange_8": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "end": {
                    "value": "max_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "max_length or length.max().data[0]",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "step": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "mask",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cuda.IntTensor() if length.is_cuda else torch.IntTensor()",
                            "IfExp"
                        ],
                        [
                            "torch.arange(0, max_length, 1, out=mask)",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(mask).type_as(length)",
                            "Call"
                        ],
                        [
                            "mask * value",
                            "BinOp"
                        ],
                        [
                            "mask.clamp(0, 1)",
                            "Call"
                        ],
                        [
                            "mask.float()",
                            "Call"
                        ],
                        [
                            "1.0 - mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sort_22": {
                "variable": {
                    "value": "(segment_ids, indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "segment_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "segment_ids.cpu()",
                            "Call"
                        ]
                    ]
                }
            },
            "index_select_23": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(inputs, 0, indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "indices",
                    "type": "Name",
                    "possible_values": [
                        [
                            "ctx.indices",
                            "Attribute"
                        ],
                        [
                            "indices.unsqueeze(dim)",
                            "Call"
                        ]
                    ]
                }
            },
            "sort_84": {
                "variable": {
                    "value": "(_, lengths_sorted)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cuda.LongTensor(lengths) if inputs.is_cuda else torch.LongTensor(lengths)",
                            "IfExp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sort_85": {
                "variable": {
                    "value": "(_, segm_lengths_sorted)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "segm_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cuda.LongTensor(segm_lengths) if inputs.is_cuda else torch.LongTensor(segm_lengths)",
                            "IfExp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_87": {
                "variable": {
                    "value": "inputs_sorted",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(inputs, 0, indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "lengths_sorted",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cat_104": {
                "variable": {
                    "value": "segments",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "segments",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[compute_segment(l, n) for (l, n) in enumerate(num_lengths) if n > 0]",
                            "ListComp"
                        ],
                        [
                            "[zero_t.expand(num_zeros[0], zero_t.shape[1])] + segments",
                            "BinOp"
                        ],
                        [
                            "torch.cat(segments, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sort_105": {
                "variable": {
                    "value": "(_, rev_segm_sorted)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "segm_lengths_sorted",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_112": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "segments",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[compute_segment(l, n) for (l, n) in enumerate(num_lengths) if n > 0]",
                            "ListComp"
                        ],
                        [
                            "[zero_t.expand(num_zeros[0], zero_t.shape[1])] + segments",
                            "BinOp"
                        ],
                        [
                            "torch.cat(segments, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "rev_segm_sorted",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_120": {
                "variable": {
                    "value": "grad_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "grad_outputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(grad_outputs, 0, segm_sorted)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "segm_sorted",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.sort(ctx.rev_segm_sorted)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cat_132": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "segment_grads",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[backward_segment(l, n) for (l, n) in enumerate(ctx.num_lengths) if n > 0]",
                            "ListComp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_134": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "grads",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cat(segment_grads, 0)",
                            "Call"
                        ],
                        [
                            "torch.index_select(grads, 0, rev_length_sorted)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "rev_length_sorted",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.sort(ctx.lengths_sorted)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "is_tensor_38": {
                "obj": {
                    "value": "segment_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "segment_ids.cpu()",
                            "Call"
                        ]
                    ]
                }
            },
            "sort_119": {
                "input": {
                    "value": "ctx.rev_segm_sorted",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sort_133": {
                "input": {
                    "value": "ctx.lengths_sorted",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/torch/rnn.py": {
        "torch": {
            "LSTM_9": {
                "variable": {
                    "value": "self._bilstm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_size",
                    "type": null,
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Parameter_14": {
                "variable": {
                    "value": "self._lstm_start_hidden",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(2, size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_15": {
                "variable": {
                    "value": "self._lstm_start_state",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(2, size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sort_25": {
                "variable": {
                    "value": "(new_lengths, indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "descending": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_26": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.index_select(inputs, 0, indices)",
                            "Call"
                        ],
                        [
                            "nn.utils.rnn.pack_padded_sequence(inputs, new_lengths, batch_first=True)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "pack_padded_sequence_31": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.index_select(inputs, 0, indices)",
                            "Call"
                        ],
                        [
                            "nn.utils.rnn.pack_padded_sequence(inputs, new_lengths, batch_first=True)",
                            "Call"
                        ]
                    ]
                },
                "lengths": {
                    "value": "new_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[l.data[0] for l in new_lengths]",
                            "ListComp"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sort_37": {
                "variable": {
                    "value": "(_, back_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_38": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nn.utils.rnn.pad_packed_sequence(output, batch_first=True)[0]",
                            "Subscript"
                        ],
                        [
                            "torch.index_select(output, 0, back_indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "back_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_39": {
                "variable": {
                    "value": "h_n",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "h_n",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(h_n, 1, back_indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "back_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_40": {
                "variable": {
                    "value": "c_n",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "c_n",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(c_n, 1, back_indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "back_indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_14": {
                "*size": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_15": {
                "*size": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "pad_packed_sequence_36": {
                "sequence": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nn.utils.rnn.pad_packed_sequence(output, batch_first=True)[0]",
                            "Subscript"
                        ],
                        [
                            "torch.index_select(output, 0, back_indices)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_28": {
                "input": {
                    "value": "start_state[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_29": {
                "input": {
                    "value": "start_state[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "indices",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/torch/segment.py": {
        "torch": {
            "arange_8": {
                "variable": {
                    "value": "mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "end": {
                    "value": "max_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "max_length or length.max().data[0]",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "step": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "mask",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cuda.IntTensor() if length.is_cuda else torch.IntTensor()",
                            "IfExp"
                        ],
                        [
                            "torch.arange(0, max_length, 1, out=mask)",
                            "Call"
                        ],
                        [
                            "torch.autograd.Variable(mask).type_as(length)",
                            "Call"
                        ],
                        [
                            "mask * value",
                            "BinOp"
                        ],
                        [
                            "mask.clamp(0, 1)",
                            "Call"
                        ],
                        [
                            "mask.float()",
                            "Call"
                        ],
                        [
                            "1.0 - mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sort_22": {
                "variable": {
                    "value": "(segment_ids, indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "segment_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "segment_ids.cpu()",
                            "Call"
                        ]
                    ]
                }
            },
            "index_select_23": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(inputs, 0, indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "indices",
                    "type": "Name",
                    "possible_values": [
                        [
                            "ctx.indices",
                            "Attribute"
                        ],
                        [
                            "indices.unsqueeze(dim)",
                            "Call"
                        ]
                    ]
                }
            },
            "sort_84": {
                "variable": {
                    "value": "(_, lengths_sorted)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cuda.LongTensor(lengths) if inputs.is_cuda else torch.LongTensor(lengths)",
                            "IfExp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sort_85": {
                "variable": {
                    "value": "(_, segm_lengths_sorted)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "segm_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cuda.LongTensor(segm_lengths) if inputs.is_cuda else torch.LongTensor(segm_lengths)",
                            "IfExp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_87": {
                "variable": {
                    "value": "inputs_sorted",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(inputs, 0, indices)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "lengths_sorted",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cat_104": {
                "variable": {
                    "value": "segments",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "segments",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[compute_segment(l, n) for (l, n) in enumerate(num_lengths) if n > 0]",
                            "ListComp"
                        ],
                        [
                            "[zero_t.expand(num_zeros[0], zero_t.shape[1])] + segments",
                            "BinOp"
                        ],
                        [
                            "torch.cat(segments, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sort_105": {
                "variable": {
                    "value": "(_, rev_segm_sorted)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "segm_lengths_sorted",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_112": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "segments",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[compute_segment(l, n) for (l, n) in enumerate(num_lengths) if n > 0]",
                            "ListComp"
                        ],
                        [
                            "[zero_t.expand(num_zeros[0], zero_t.shape[1])] + segments",
                            "BinOp"
                        ],
                        [
                            "torch.cat(segments, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "rev_segm_sorted",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_120": {
                "variable": {
                    "value": "grad_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "grad_outputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.index_select(grad_outputs, 0, segm_sorted)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "segm_sorted",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.sort(ctx.rev_segm_sorted)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cat_132": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "segment_grads",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[backward_segment(l, n) for (l, n) in enumerate(ctx.num_lengths) if n > 0]",
                            "ListComp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "index_select_134": {
                "variable": {
                    "value": "grads",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "grads",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cat(segment_grads, 0)",
                            "Call"
                        ],
                        [
                            "torch.index_select(grads, 0, rev_length_sorted)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "rev_length_sorted",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.sort(ctx.lengths_sorted)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "is_tensor_38": {
                "obj": {
                    "value": "segment_ids",
                    "type": "Name",
                    "possible_values": [
                        [
                            "segment_ids.cpu()",
                            "Call"
                        ]
                    ]
                }
            },
            "sort_119": {
                "input": {
                    "value": "ctx.rev_segm_sorted",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sort_133": {
                "input": {
                    "value": "ctx.lengths_sorted",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "jack/util/torch/xqa.py": {
        "torch": {
            "stack_34": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "partitioned_loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "mean_34": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_32": {
                "variable": {
                    "value": "partitioned_loss[j]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensors": {
                    "value": "l",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "min_32": {
                "variable": {
                    "value": "partitioned_loss[j]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "index_select_19": {
                "input": {
                    "value": "start_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "start_scores if is_aligned else torch.index_select(start_scores, dim=0, index=answer_to_question)",
                            "IfExp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "answer_to_question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_20": {
                "input": {
                    "value": "end_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "end_scores if is_aligned else torch.index_select(end_scores, dim=0, index=answer_to_question)",
                            "IfExp"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "answer_to_question",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "index_select_28": {
                "input": {
                    "value": "F.log_softmax(end_scores[i], dim=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "end[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "device_count_11": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "index_select_27": {
                "input": {
                    "value": "F.log_softmax(start_scores[i], dim=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "start[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "log_softmax_28": {
                "input": {
                    "value": "end_scores[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "log_softmax_27": {
                "input": {
                    "value": "start_scores[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    }
}