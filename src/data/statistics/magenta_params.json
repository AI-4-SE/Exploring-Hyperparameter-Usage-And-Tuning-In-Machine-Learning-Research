{
    "magenta/common/beam_search_test.py": {
        "tensorflow": {
            "disable_v2_behavior_20": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_90": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/concurrency_test.py": {
        "tensorflow": {
            "main_54": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/nade.py": {
        "tensorflow": {
            "log_29": {
                "x": {
                    "value": "1e-06 + tensor",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_49": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 / math.sqrt(self._num_dims)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_123": {
                "variable": {
                    "value": "log_p_0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unstack_126": {
                "variable": {
                    "value": "x_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.reshape(tf.transpose(x), [self.num_dims, batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unstack_128": {
                "variable": {
                    "value": "w_enc_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.w_enc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unstack_129": {
                "variable": {
                    "value": "w_dec_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.w_dec_t",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unstack_130": {
                "variable": {
                    "value": "b_dec_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.reshape(tf.transpose(b_dec), [self.num_dims, batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_199": {
                "variable": {
                    "value": "log_p_0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unstack_201": {
                "variable": {
                    "value": "w_enc_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.w_enc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unstack_202": {
                "variable": {
                    "value": "w_dec_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self.w_dec_t",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unstack_203": {
                "variable": {
                    "value": "b_dec_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.reshape(tf.transpose(b_dec), [self.num_dims, batch_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_259": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sigmoid_261": {
                "variable": {
                    "value": "cond_p_i",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "cond_l_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_dec_i + tf.matmul(h, w_dec_i)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_53": {
                "variable": {
                    "value": "self.w_enc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_enc",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self._num_dims, 1, self._num_hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.truncated_normal_initializer(stddev=std)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_58": {
                "variable": {
                    "value": "self.w_dec_t",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_dec_t",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self._num_dims, self._num_hidden, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.truncated_normal_initializer(stddev=std)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_117": {
                "variable": {
                    "value": "b_enc",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "b_enc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_enc if b_enc is not None else self.b_enc",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_enc, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_enc if b_enc is not None else self.b_enc",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_enc, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_119": {
                "variable": {
                    "value": "b_dec",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "b_dec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_193": {
                "variable": {
                    "value": "b_enc",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "b_enc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_enc if b_enc is not None else self.b_enc",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_enc, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_enc if b_enc is not None else self.b_enc",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_enc, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_195": {
                "variable": {
                    "value": "b_dec",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "b_dec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_51": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'nade'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_65": {
                "variable": {
                    "value": "self.b_enc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "b_enc",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self._num_hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.truncated_normal_initializer(stddev=std)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_74": {
                "variable": {
                    "value": "self.b_dec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "b_dec",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self._num_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.truncated_normal_initializer(stddev=std)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_110": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_127": {
                "tensor": {
                    "value": "tf.transpose(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_dims, batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_131": {
                "tensor": {
                    "value": "tf.transpose(b_dec)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_dims, batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_162": {
                "input": {
                    "value": "log_p",
                    "type": "variable",
                    "possible_values": []
                },
                "squeeze_dims": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_163": {
                "a": {
                    "value": "tf.squeeze(tf.stack(cond_p), [2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_204": {
                "tensor": {
                    "value": "tf.transpose(b_dec)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_dims, batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_216": {
                "variable": {
                    "value": "v_i",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(cond_p_i, 0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_240": {
                "a": {
                    "value": "tf.squeeze(tf.stack(sample), [2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_241": {
                "input": {
                    "value": "log_p",
                    "type": "variable",
                    "possible_values": []
                },
                "squeeze_dims": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_260": {
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(a)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_dec_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w_dec_arr[i]",
                            "Subscript"
                        ],
                        [
                            "w_dec_arr[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "transpose_127": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "transpose_131": {
                "a": {
                    "value": "b_dec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_153": {
                "a": {
                    "value": "v_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_arr[i]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(cond_p_i, 0.5))",
                            "Call"
                        ],
                        [
                            "bernoulli.sample()",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_enc_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w_enc_arr[i]",
                            "Subscript"
                        ],
                        [
                            "w_enc_arr[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "squeeze_163": {
                "input": {
                    "value": "tf.stack(cond_p)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_189": {
                "input": {
                    "value": "b_enc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_enc if b_enc is not None else self.b_enc",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_enc, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_enc if b_enc is not None else self.b_enc",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_enc, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_204": {
                "a": {
                    "value": "b_dec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "b_dec if b_dec is not None else self.b_dec",
                            "IfExp"
                        ],
                        [
                            "tf.tile(b_dec, [batch_size, 1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_232": {
                "a": {
                    "value": "v_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_arr[i]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(tf.greater_equal(cond_p_i, 0.5))",
                            "Call"
                        ],
                        [
                            "bernoulli.sample()",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_enc_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w_enc_arr[i]",
                            "Subscript"
                        ],
                        [
                            "w_enc_arr[i]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "squeeze_240": {
                "input": {
                    "value": "tf.stack(sample)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_163": {
                "values": {
                    "value": "cond_p",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "greater_equal_216": {
                "x": {
                    "value": "cond_p_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(cond_l_i)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "stack_240": {
                "values": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/nade_test.py": {
        "tensorflow": {
            "disable_v2_behavior_20": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_60": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_34": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_52": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/sequence_example_lib.py": {
        "tensorflow": {
            "RandomShuffleQueue_27": {
                "variable": {
                    "value": "shuffle_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "capacity",
                    "type": "variable",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "min_after_dequeue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "count_records(file_list, stop_at=SHUFFLE_MIN_AFTER_DEQUEUE)",
                            "Call"
                        ]
                    ]
                },
                "dtypes": {
                    "value": "[t.dtype for t in input_tensors]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "QueueRunner_30": {
                "variable": {
                    "value": "runner",
                    "type": "variable",
                    "possible_values": []
                },
                "queue": {
                    "value": "shuffle_queue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.RandomShuffleQueue(capacity, min_after_dequeue, dtypes=[t.dtype for t in input_tensors])",
                            "Call"
                        ]
                    ]
                },
                "enqueue_ops": {
                    "value": "[enqueue_op] * num_threads",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "string_input_producer_66": {
                "variable": {
                    "value": "file_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "string_tensor": {
                    "value": "file_list",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TFRecordReader_67": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parse_single_sequence_example_76": {
                "variable": {
                    "value": "(_, sequence)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized_example",
                    "type": "variable",
                    "possible_values": []
                },
                "sequence_features": {
                    "value": "sequence_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'inputs': tf.FixedLenSequenceFeature(shape=[input_size], dtype=tf.float32), 'labels': tf.FixedLenSequenceFeature(shape=label_shape or [], dtype=tf.int64)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "add_queue_runner_31": {
                "qr": {
                    "value": "runner",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.QueueRunner(shuffle_queue, [enqueue_op] * num_threads)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_99": {
                "msg": {
                    "value": "input_tensors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[sequence['inputs'], sequence['labels'], length]",
                            "List"
                        ],
                        [
                            "_shuffle_inputs(input_tensors, capacity=QUEUE_CAPACITY, min_after_dequeue=min_after_dequeue, num_threads=shuffle_threads)",
                            "Call"
                        ]
                    ]
                }
            },
            "batch_100": {
                "tensors": {
                    "value": "input_tensors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[sequence['inputs'], sequence['labels'], length]",
                            "List"
                        ],
                        [
                            "_shuffle_inputs(input_tensors, capacity=QUEUE_CAPACITY, min_after_dequeue=min_after_dequeue, num_threads=shuffle_threads)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "QUEUE_CAPACITY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "500",
                            "int"
                        ]
                    ]
                },
                "num_threads": {
                    "value": "num_enqueuing_threads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_enqueuing_threads - shuffle_threads",
                            "BinOp"
                        ],
                        [
                            "4",
                            "Method Argument"
                        ]
                    ]
                },
                "dynamic_pad": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_127": {
                "msg": {
                    "value": "Total records: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "num_records",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "num_records + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_154": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.sequence_mask(lengths)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_157": {
                "pred": {
                    "value": "tf.equal(tf.reduce_min(lengths), tf.shape(maybe_padded_sequences)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "flatten_unpadded_sequences",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "flatten_padded_sequences",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_71": {
                "shape": {
                    "value": "[input_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenSequenceFeature_73": {
                "shape": {
                    "value": "label_shape or []",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_79": {
                "input": {
                    "value": "sequence['inputs']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "info_121": {
                "msg": {
                    "value": "Counting records in %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "tfrecord_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "file_list",
                            "variable"
                        ]
                    ]
                }
            },
            "tf_record_iterator_122": {
                "path": {
                    "value": "tfrecord_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "file_list",
                            "variable"
                        ]
                    ]
                }
            },
            "reshape_147": {
                "tensor": {
                    "value": "maybe_padded_sequences",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1] + maybe_padded_sequences.shape.as_list()[2:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_nd_155": {
                "params": {
                    "value": "maybe_padded_sequences",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.sequence_mask(lengths))",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_158": {
                "x": {
                    "value": "tf.reduce_min(lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.shape(maybe_padded_sequences)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sequence_mask_154": {
                "lengths": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_min_158": {
                "input_tensor": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_125": {
                "msg": {
                    "value": "Number of records is at least %d.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "num_records",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "num_records + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_158": {
                "input": {
                    "value": "maybe_padded_sequences",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/state_util.py": {
        "tensorflow": {
            "map_structure_48": {
                "func": {
                    "value": "lambda x: x[i]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "batched_states",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "map_structure_75": {
                "func": {
                    "value": "stack_and_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "*states",
                    "type": "Starred",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/state_util_test.py": {
        "tensorflow": {
            "main_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assert_same_structure_45": {
                "nest1": {
                    "value": "struct1",
                    "type": "variable",
                    "possible_values": []
                },
                "nest2": {
                    "value": "struct2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "flatten_46": {
                "structure": {
                    "value": "struct2",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/common/tf_utils.py": {
        "tensorflow": {
            "to_float_63": {
                "variable": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(predictions)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_64": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_62": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "multiply_69": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.multiply(labels, tf.log(predictions + epsilon)) - tf.multiply(1 - labels, tf.log(1 - predictions + epsilon))",
                            "BinOp"
                        ],
                        [
                            "tf.multiply(losses, weights)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "multiply_66": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(labels)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.log(predictions + epsilon)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_67": {
                "x": {
                    "value": "1 - predictions + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_66": {
                "x": {
                    "value": "predictions + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/contrib/rnn.py": {
        "tensorflow": {
            "LSTMBlockCellGrad_639": {
                "variable": {
                    "value": "(cs_prev_grad, dgates, wci_grad, wcf_grad, wco_grad)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "cs_prev": {
                    "value": "cs_prev",
                    "type": "variable",
                    "possible_values": []
                },
                "h_prev": {
                    "value": "h_prev",
                    "type": "variable",
                    "possible_values": []
                },
                "w": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "wci": {
                    "value": "wci",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.float32, shape=[cell_size])",
                            "Call"
                        ],
                        [
                            "self._w_i_diag",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "wcf": {
                    "value": "wcf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wci",
                            "variable"
                        ],
                        [
                            "self._w_f_diag",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "wco": {
                    "value": "wco",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wci",
                            "variable"
                        ],
                        [
                            "self._w_o_diag",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "i": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "cs": {
                    "value": "cs",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm(f, 'forget', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "o": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "ci": {
                    "value": "ci",
                    "type": "variable",
                    "possible_values": []
                },
                "co": {
                    "value": "co",
                    "type": "variable",
                    "possible_values": []
                },
                "cs_grad": {
                    "value": "cs_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "h_grad": {
                    "value": "h_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "use_peephole": {
                    "value": "op.get_attr('use_peephole')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_659": {
                "variable": {
                    "value": "xh_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "dgates",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "slice_661": {
                "variable": {
                    "value": "x_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "xh_grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(dgates, w, transpose_b=True)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "(0, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "size": {
                    "value": "(batch_size, input_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "slice_664": {
                "variable": {
                    "value": "h_prev_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "xh_grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(dgates, w, transpose_b=True)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "(0, input_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "size": {
                    "value": "(batch_size, cell_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_668": {
                "variable": {
                    "value": "xh",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, h_prev]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_669": {
                "variable": {
                    "value": "w_grad",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "xh",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, h_prev], 1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "dgates",
                    "type": "variable",
                    "possible_values": []
                },
                "transpose_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "RegisterGradient_621": {
                "op_type": {
                    "value": "LSTMBlockCell",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_scope_123": {
                "variable": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reshape_306": {
                "variable": {
                    "value": "attn_states",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "attn_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(states, [0, self._cell.state_size + self._attn_size], [-1, self._attn_size * self._attn_length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(attn_states, [-1, self._attn_length, self._attn_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._attn_length, self._attn_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_324": {
                "variable": {
                    "value": "new_attn_states",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_attn_states, tf.expand_dims(output, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_326": {
                "variable": {
                    "value": "new_attn_states",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "new_attn_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([new_attn_states, tf.expand_dims(output, 1)], 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(new_attn_states, [-1, self._attn_length * self._attn_size])",
                            "Call"
                        ],
                        [
                            "tf.slice(attn_states, [0, 1, 0], [-1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._attn_length * self._attn_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_560": {
                "variable": {
                    "value": "wci",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[cell_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "LSTMBlockCell_564": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "cs_prev": {
                    "value": "cs_prev",
                    "type": "variable",
                    "possible_values": []
                },
                "h_prev": {
                    "value": "h_prev",
                    "type": "variable",
                    "possible_values": []
                },
                "w": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "wci": {
                    "value": "wci",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0, dtype=tf.float32, shape=[cell_size])",
                            "Call"
                        ],
                        [
                            "self._w_i_diag",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "wcf": {
                    "value": "wcf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wci",
                            "variable"
                        ],
                        [
                            "self._w_f_diag",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "wco": {
                    "value": "wco",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wci",
                            "variable"
                        ],
                        [
                            "self._w_o_diag",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "forget_bias": {
                    "value": "forget_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                },
                "cell_clip": {
                    "value": "cell_clip if cell_clip is not None else -1",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_peephole": {
                    "value": "use_peephole",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'lstm_cell'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "InputSpec_734": {
                "variable": {
                    "value": "self.input_spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ndim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_867": {
                "variable": {
                    "value": "gamma_init",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._norm_gain",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_868": {
                "variable": {
                    "value": "beta_init",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._norm_shift",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_880": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_881": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[args]",
                            "List"
                        ],
                        [
                            "[args]",
                            "List"
                        ],
                        [
                            "tf.concat([inputs, h], 1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_890": {
                "variable": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_894": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_125": {
                "variable": {
                    "value": "self._weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "_WEIGHTS_VARIABLE_NAME",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'kernel'",
                            "str"
                        ]
                    ]
                },
                "shape": {
                    "value": "[total_arg_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_144": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self._weights",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_147": {
                "variable": {
                    "value": "one",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_148": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat(args, one)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._weights",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_150": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(args[0], self._weights)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat(args, one), self._weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(res, self._biases)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._biases",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "slice_300": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state",
                            "variable"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, self._cell.state_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_301": {
                "variable": {
                    "value": "attns",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state",
                            "variable"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, self._cell.state_size]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, self._attn_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_303": {
                "variable": {
                    "value": "attn_states",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state",
                            "variable"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, self._cell.state_size + self._attn_size]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, self._attn_size * self._attn_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_316": {
                "variable": {
                    "value": "new_state_cat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.nest.flatten(new_state)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_330": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "list(new_state)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_340": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "attn_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, self._attn_size, self._attn_vec_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_342": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "attn_v",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self._attn_vec_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_343": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "attn_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(states, [0, self._cell.state_size + self._attn_size], [-1, self._attn_size * self._attn_length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(attn_states, [-1, self._attn_length, self._attn_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._attn_length, 1, self._attn_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_349": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._linear3(query)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [-1, 1, 1, self._attn_vec_size])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1, 1, self._attn_vec_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_354": {
                "variable": {
                    "value": "new_attns",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reduce_sum(tf.reshape(a, [-1, self._attn_length, 1, 1]) * hidden, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._attn_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_355": {
                "variable": {
                    "value": "new_attn_states",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "attn_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(states, [0, self._cell.state_size + self._attn_size], [-1, self._attn_size * self._attn_length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(attn_states, [-1, self._attn_length, self._attn_size])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_453": {
                "name_or_scope": {
                    "value": "scope or 'stack_bidirectional_rnn'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "zeros_771": {
                "variable": {
                    "value": "wci",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self._num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_883": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_884": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_903": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_124": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable_scope()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "warn_184": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_200": {
                "name": {
                    "value": "type(self).__name__ + 'ZeroState'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "warn_263": {
                "msg": {
                    "value": "%s: Using a concatenated state is slower and will soon be deprecated.  Use state_is_tuple=True.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_320": {
                "name_or_scope": {
                    "value": "attn_output_projection",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_339": {
                "name_or_scope": {
                    "value": "attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_463": {
                "variable": {
                    "value": "(outputs, (state_fw, state_bw))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell_fw",
                    "type": "variable",
                    "possible_values": []
                },
                "cell_bw": {
                    "value": "cell_bw",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat(outputs, 2)",
                            "Call"
                        ]
                    ]
                },
                "initial_state_fw": {
                    "value": "initial_state_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "initial_states_fw[i]",
                            "Subscript"
                        ]
                    ]
                },
                "initial_state_bw": {
                    "value": "initial_state_bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "initial_states_bw[i]",
                            "Subscript"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "time_major": {
                    "value": "time_major",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_475": {
                "variable": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "warn_845": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_869": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable_scope()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_871": {
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shapes",
                            "variable"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "gamma_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(self._norm_gain)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_872": {
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shapes",
                            "variable"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "beta_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(self._norm_shift)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_909": {
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_134": {
                "variable": {
                    "value": "self._biases",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "_BIAS_VARIABLE_NAME",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'bias'",
                            "str"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_148": {
                "values": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[args]",
                            "List"
                        ],
                        [
                            "[args]",
                            "List"
                        ],
                        [
                            "tf.concat([inputs, h], 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "one",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(1, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_316": {
                "structure": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(new_state, new_attns, new_attn_states)",
                            "Tuple"
                        ],
                        [
                            "tf.concat(list(new_state), 1)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LSTMStateTuple(cs, h)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_325": {
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._linear2([cell_output, new_attns])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_462": {
                "name_or_scope": {
                    "value": "'cell_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_753": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sigmoid_906": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_130": {
                "name_or_scope": {
                    "value": "outer_scope",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_initializer_133": {
                "variable": {
                    "value": "bias_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[a.dtype for a in args][0]",
                            "Subscript"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_353": {
                "tensor": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "softmax(s)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._attn_length, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/contrib/rnn_test.py": {
        "tensorflow": {
            "disable_eager_execution_25": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "random_uniform_initializer_276": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.01",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_278": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_300": {
                "variable": {
                    "value": "inputs_c",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, input_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.array([[1.0, 1.0, 1.0, 1.0], [2.0, 2.0, 2.0, 2.0], [3.0, 3.0, 3.0, 3.0]], dtype=np.float32), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform((batch_size, num_units), 0.0, 1.0, seed=seed + 5)",
                            "Call"
                        ],
                        [
                            "max_length * [tf.placeholder(tf.float32, shape=(batch_size, input_size) if use_shape else (None, input_size))]",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_301": {
                "variable": {
                    "value": "inputs_c",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(inputs_c, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "main_955": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_random_seed_207": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "12345",
                            "int"
                        ]
                    ]
                }
            },
            "global_variables_467": {
                "variable": {
                    "value": "all_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_509": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None, input_dim)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "dynamic_rnn_511": {
                "variable": {
                    "value": "(output, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "contrib_rnn.InputProjectionWrapper(rnn_cell.GRUCell(3), num_proj=3)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(cell_size)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LSTMCell(10)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(10)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([single_cell() for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(2)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([single_cell() for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(2, layer_norm=False)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([contrib_rnn.LayerNormBasicLSTMCell(2) for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([contrib_rnn.LayerNormBasicLSTMCell(2, layer_norm=True, norm_gain=1.0, norm_shift=0.0) for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(num_units, layer_norm=False, dropout_keep_prob=keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, shape=(None, None, input_dim))",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 3])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 3])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 5])",
                            "Call"
                        ]
                    ]
                },
                "time_major": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_573": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_581": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.01",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "19890212",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_623": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_631": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.01",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "seed": {
                    "value": "19890212",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_36": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_37": {
                "variable": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_initializer_329": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_329": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_408": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_408": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_466": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_470": {
                "msg": {
                    "value": "'StackRNN with scope: %s (%s)' % (prefix, 'scope' if use_outer_scope else 'str')",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_522": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_523": {
                "variable": {
                    "value": "m0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_524": {
                "variable": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_525": {
                "variable": {
                    "value": "m2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_526": {
                "variable": {
                    "value": "m3",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "static_rnn_551": {
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "contrib_rnn.InputProjectionWrapper(rnn_cell.GRUCell(3), num_proj=3)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(cell_size)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LSTMCell(10)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(10)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([single_cell() for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(2)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([single_cell() for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(2, layer_norm=False)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([contrib_rnn.LayerNormBasicLSTMCell(2) for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([contrib_rnn.LayerNormBasicLSTMCell(2, layer_norm=True, norm_gain=1.0, norm_shift=0.0) for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(num_units, layer_norm=False, dropout_keep_prob=keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, input_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.array([[1.0, 1.0, 1.0, 1.0], [2.0, 2.0, 2.0, 2.0], [3.0, 3.0, 3.0, 3.0]], dtype=np.float32), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform((batch_size, num_units), 0.0, 1.0, seed=seed + 5)",
                            "Call"
                        ],
                        [
                            "max_length * [tf.placeholder(tf.float32, shape=(batch_size, input_size) if use_shape else (None, input_size))]",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "basic",
                    "type": "str",
                    "possible_values": []
                }
            },
            "static_rnn_552": {
                "cell": {
                    "value": "pcell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn_cell.LSTMCell(10, use_peepholes=True)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(10, use_peephole=True)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, input_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.array([[1.0, 1.0, 1.0, 1.0], [2.0, 2.0, 2.0, 2.0], [3.0, 3.0, 3.0, 3.0]], dtype=np.float32), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform((batch_size, num_units), 0.0, 1.0, seed=seed + 5)",
                            "Call"
                        ],
                        [
                            "max_length * [tf.placeholder(tf.float32, shape=(batch_size, input_size) if use_shape else (None, input_size))]",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "peephole",
                    "type": "str",
                    "possible_values": []
                }
            },
            "static_rnn_562": {
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "contrib_rnn.InputProjectionWrapper(rnn_cell.GRUCell(3), num_proj=3)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(lstm_cell, attn_length, state_is_tuple=state_is_tuple)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(cell_size)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LSTMCell(10)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(10)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([single_cell() for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(2)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([single_cell() for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(2, layer_norm=False)",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([contrib_rnn.LayerNormBasicLSTMCell(2) for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "rnn_cell.MultiRNNCell([contrib_rnn.LayerNormBasicLSTMCell(2, layer_norm=True, norm_gain=1.0, norm_shift=0.0) for _ in range(2)])",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LayerNormBasicLSTMCell(num_units, layer_norm=False, dropout_keep_prob=keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, input_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.array([[1.0, 1.0, 1.0, 1.0], [2.0, 2.0, 2.0, 2.0], [3.0, 3.0, 3.0, 3.0]], dtype=np.float32), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform((batch_size, num_units), 0.0, 1.0, seed=seed + 5)",
                            "Call"
                        ],
                        [
                            "max_length * [tf.placeholder(tf.float32, shape=(batch_size, input_size) if use_shape else (None, input_size))]",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "basic",
                    "type": "str",
                    "possible_values": []
                }
            },
            "static_rnn_563": {
                "cell": {
                    "value": "pcell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn_cell.LSTMCell(10, use_peepholes=True)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.LSTMBlockCell(10, use_peephole=True)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, input_size], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.array([[1.0, 1.0, 1.0, 1.0], [2.0, 2.0, 2.0, 2.0], [3.0, 3.0, 3.0, 3.0]], dtype=np.float32), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform((batch_size, num_units), 0.0, 1.0, seed=seed + 5)",
                            "Call"
                        ],
                        [
                            "max_length * [tf.placeholder(tf.float32, shape=(batch_size, input_size) if use_shape else (None, input_size))]",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ],
                        [
                            "[tf.zeros([4, 5])] * 6",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "peephole",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_584": {
                "variable": {
                    "value": "m0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_585": {
                "variable": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_586": {
                "variable": {
                    "value": "m2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_587": {
                "variable": {
                    "value": "m3",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_601": {
                "variable": {
                    "value": "m0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_602": {
                "variable": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_603": {
                "variable": {
                    "value": "m2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_604": {
                "variable": {
                    "value": "m3",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_634": {
                "variable": {
                    "value": "m0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_635": {
                "variable": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_636": {
                "variable": {
                    "value": "m2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_637": {
                "variable": {
                    "value": "m3",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_654": {
                "variable": {
                    "value": "m0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_655": {
                "variable": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_656": {
                "variable": {
                    "value": "m2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_657": {
                "variable": {
                    "value": "m3",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_683": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_684": {
                "variable": {
                    "value": "c0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_685": {
                "variable": {
                    "value": "h0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_687": {
                "variable": {
                    "value": "c1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_688": {
                "variable": {
                    "value": "h1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_724": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_726": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_727": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_751": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_752": {
                "variable": {
                    "value": "c0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_753": {
                "variable": {
                    "value": "h0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_755": {
                "variable": {
                    "value": "c1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_756": {
                "variable": {
                    "value": "h1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_792": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_794": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_795": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_818": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_819": {
                "variable": {
                    "value": "c0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_820": {
                "variable": {
                    "value": "h0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_822": {
                "variable": {
                    "value": "c1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_823": {
                "variable": {
                    "value": "h1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_856": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_857": {
                "variable": {
                    "value": "c0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_858": {
                "variable": {
                    "value": "h0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_860": {
                "variable": {
                    "value": "c1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_861": {
                "variable": {
                    "value": "h1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_915": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_916": {
                "variable": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_917": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_34": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_82": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_131": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_210": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_296": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, input_size) if use_shape else (None, input_size)",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "placeholder_391": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, layer * 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_396": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, layer * 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "info_473": {
                "msg": {
                    "value": "v.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_513": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_520": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_583": {
                "name_or_scope": {
                    "value": "basic",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_600": {
                "name_or_scope": {
                    "value": "block",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_633": {
                "name_or_scope": {
                    "value": "basic",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_653": {
                "name_or_scope": {
                    "value": "block",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ],
                        [
                            "tf.random_uniform_initializer(-0.01, 0.01, seed=19890212)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_681": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_722": {
                "name_or_scope": {
                    "value": "other",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_749": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_790": {
                "name_or_scope": {
                    "value": "other",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_816": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_854": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_913": {
                "name_or_scope": {
                    "value": "other",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_102": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, input_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_157": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.array([[1.0, 1.0, 1.0, 1.0], [2.0, 2.0, 2.0, 2.0], [3.0, 3.0, 3.0, 3.0]], dtype=np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_211": {
                "name_or_scope": {
                    "value": "state_is_tuple",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "state_is_tuple",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[False, True]",
                            "List"
                        ],
                        [
                            "[False, True]",
                            "List"
                        ],
                        [
                            "[False, True]",
                            "List"
                        ],
                        [
                            "[False, True]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.glorot_uniform_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_235": {
                "variable": {
                    "value": "zero_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[zero_state[0][0], zero_state[0][1], zero_state[1], zero_state[2]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_248": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state[0][0], state[0][1], state[1], state[2]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Graph_325": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_387": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_458": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_460": {
                "name_or_scope": {
                    "value": "prefix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prefix or 'stack_bidirectional_rnn'",
                            "BoolOp"
                        ],
                        [
                            "'prefix'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Graph_502": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_519": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_547": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_550": {
                "shape": {
                    "value": "[4, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "trainable_variables_555": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_558": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_561": {
                "shape": {
                    "value": "[4, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "trainable_variables_566": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_35": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_41": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_84": {
                "name_or_scope": {
                    "value": "'state_is_tuple_' + str(state_is_tuple)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_91": {
                "variable": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_92": {
                "variable": {
                    "value": "attn_state_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, attn_length * num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_96": {
                "variable": {
                    "value": "zero_state",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, num_units * 2 + attn_length * num_units + num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_133": {
                "name_or_scope": {
                    "value": "'state_is_tuple_' + str(state_is_tuple)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_140": {
                "variable": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.1 * np.ones([batch_size, num_units], dtype=np.float32)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_143": {
                "variable": {
                    "value": "attn_state_zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.1 * np.ones([batch_size, attn_length * num_units], dtype=np.float32)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_149": {
                "variable": {
                    "value": "zero_state",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.1 * np.ones([batch_size, num_units * 2 + num_units + attn_length * num_units], dtype=np.float32)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_164": {
                "variable": {
                    "value": "concat_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state[0][0], state[0][1], state[1], state[2]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_521": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_530": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_591": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_608": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_644": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_661": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_682": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_694": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_723": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_731": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_750": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_762": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_791": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_799": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_817": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_828": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_855": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "global_variables_initializer_869": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_914": {
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_923": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_123": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_168": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_122": {
                "input_tensor": {
                    "value": "tf.abs(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_122": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.placeholder(tf.float32, shape=(None, None, input_dim))",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 3])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 3])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 2])",
                            "Call"
                        ],
                        [
                            "tf.zeros([1, 5])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/contrib/seq2seq.py": {
        "tensorflow": {
            "rank_47": {
                "variable": {
                    "value": "x_rank",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "transpose_48": {
                "variable": {
                    "value": "x_t",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "perm": {
                    "value": "tf.concat(([1, 0], tf.range(2, x_rank)), axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_default_graph_295": {
                "variable": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_547": {
                "variable": {
                    "value": "batch_shape_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits, name='probs')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(probs, name='probs')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_560": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(logits, name='logits')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_structure_286": {
                "func": {
                    "value": "_create",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._cell.output_size",
                            "Attribute"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(self._initial_state)[0].dtype",
                            "Attribute"
                        ],
                        [
                            "tf.int32",
                            "Method Argument"
                        ],
                        [
                            "tf.int32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_like_380": {
                "variable": {
                    "value": "initial_sequence_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_or(initial_finished, 0 >= maximum_iterations)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_382": {
                "variable": {
                    "value": "initial_time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_structure_402": {
                "variable": {
                    "value": "initial_outputs_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_create_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "decoder.output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "decoder.output_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "while_loop_483": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "condition",
                    "type": "variable",
                    "possible_values": []
                },
                "body": {
                    "value": "body",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "(initial_time, initial_outputs_ta, initial_state, initial_inputs, initial_finished, initial_sequence_lengths)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "32",
                            "Method Argument"
                        ],
                        [
                            "32",
                            "Method Argument"
                        ]
                    ]
                },
                "maximum_iterations": {
                    "value": "maximum_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(maximum_iterations, dtype=tf.int32, name='maximum_iterations')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_structure_502": {
                "variable": {
                    "value": "final_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda ta: ta.stack()",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "final_outputs_ta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "res[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "convert_to_tensor_525": {
                "variable": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sample_shape, dtype=tf.int32, name='sample_shape')",
                            "Call"
                        ],
                        [
                            "tf.reshape(sample_shape, tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1))",
                            "Call"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "sample_shape",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_528": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(tf.rank(sample_shape), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_529": {
                "variable": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sample_shape, dtype=tf.int32, name='sample_shape')",
                            "Call"
                        ],
                        [
                            "tf.reshape(sample_shape, tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1))",
                            "Call"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_536": {
                "variable": {
                    "value": "final_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sample_shape, batch_event_shape]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_544": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(logits, name='logits')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "probs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_546": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits, name='probs')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(probs, name='probs')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "probs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_550": {
                "variable": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[[n], batch_shape_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_570": {
                "variable": {
                    "value": "draws",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "variable"
                        ],
                        [
                            "tf.reshape(logits, [-1, event_size])",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": []
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "output_dtype": {
                    "value": "sample_dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.int64 if logits.dtype.size > 4 else tf.int32",
                            "IfExp"
                        ]
                    ]
                }
            },
            "reshape_572": {
                "variable": {
                    "value": "draws",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.transpose(draws)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.concat([[n], batch_shape_tensor], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorArray_580": {
                "dtype": {
                    "value": "inp.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "tf.shape(inp)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "element_shape": {
                    "value": "inp.get_shape()[1:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "unstack_580": {
                "value": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TensorShape_657": {
                "variable": {
                    "value": "self._sample_ids_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dims": {
                    "value": "sample_ids_shape or []",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "TensorShape_941": {
                "variable": {
                    "value": "self._sample_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dims": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sample_shape, dtype=tf.int32, name='sample_shape')",
                            "Call"
                        ],
                        [
                            "tf.reshape(sample_shape, tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1))",
                            "Call"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_945": {
                "variable": {
                    "value": "self._start_inputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "start_inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_961": {
                "variable": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[False]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[self._batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_49": {
                "values": {
                    "value": "([1, 0], tf.range(2, x_rank))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_51": {
                "dims": {
                    "value": "[x_static_shape[1], x_static_shape[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concatenate_51": {
                "arys": {
                    "value": "x_static_shape[2:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_346": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_353": {
                "variable": {
                    "value": "maximum_iterations",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "maximum_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(maximum_iterations, dtype=tf.int32, name='maximum_iterations')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "maximum_iterations",
                    "type": "str",
                    "possible_values": []
                }
            },
            "logical_or_378": {
                "variable": {
                    "value": "initial_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "initial_finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_or(initial_finished, 0 >= maximum_iterations)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0 >= maximum_iterations",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "map_structure_478": {
                "variable": {
                    "value": "outputs_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda ta, out: ta.write(time, out)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "outputs_ta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda ta, out: ta.write(time, out), outputs_ta, emit)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "emit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda out, zero: tf.where(finished, zero, out), next_outputs, zero_outputs)",
                            "Call"
                        ],
                        [
                            "next_outputs",
                            "variable"
                        ]
                    ]
                }
            },
            "map_structure_512": {
                "variable": {
                    "value": "final_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_transpose_batch_time",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "final_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda ta: ta.stack(), final_outputs_ta)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, final_outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_524": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "values": {
                    "value": "[sample_shape]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_537": {
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sample_n_fn(tf.reduce_prod(sample_shape))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "final_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([sample_shape, batch_event_shape], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_553": {
                "x": {
                    "value": "tf.less(uniform, probs)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(self._initial_state)[0].dtype",
                            "Attribute"
                        ],
                        [
                            "tf.int32",
                            "Method Argument"
                        ],
                        [
                            "tf.int32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_561": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(logits, name='logits')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_562": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(logits, name='logits')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_568": {
                "variable": {
                    "value": "logits_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(logits, name='logits')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, event_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_575": {
                "x": {
                    "value": "draws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits_2d, n, seed=seed, output_dtype=sample_dtype)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(draws), tf.concat([[n], batch_shape_tensor], 0))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(self._initial_state)[0].dtype",
                            "Attribute"
                        ],
                        [
                            "tf.int32",
                            "Method Argument"
                        ],
                        [
                            "tf.int32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_713": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_structure_718": {
                "variable": {
                    "value": "self._input_tas",
                    "type": "Attribute",
                    "possible_values": []
                },
                "func": {
                    "value": "_unstack_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_719": {
                "variable": {
                    "value": "self._sequence_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "sequence_length",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_structure_726": {
                "variable": {
                    "value": "self._zero_inputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda inp: tf.zeros_like(inp[0, :])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "size_729": {
                "variable": {
                    "value": "self._batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TensorShape_745": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_753": {
                "variable": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "self._sequence_length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_all_754": {
                "variable": {
                    "value": "all_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_755": {
                "variable": {
                    "value": "next_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "all_finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : self._zero_inputs",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nest.map_structure(lambda inp: inp.read(0), self._input_tas)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_763": {
                "variable": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(outputs, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_all_773": {
                "variable": {
                    "value": "all_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_776": {
                "variable": {
                    "value": "next_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "all_finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : self._zero_inputs",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.nest.map_structure(read_from_ta, self._input_tas)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "convert_to_tensor_815": {
                "variable": {
                    "value": "self._sampling_probability",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "sampling_probability",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "sampling_probability",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_870": {
                "variable": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.argmax(outputs, axis=-1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(sample_ids, tf.bool)",
                            "Call"
                        ],
                        [
                            "self._helper.sample(time=time, outputs=cell_outputs, state=cell_state)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_all_912": {
                "variable": {
                    "value": "all_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_not_913": {
                "variable": {
                    "value": "no_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_any(sample_ids)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_914": {
                "variable": {
                    "value": "next_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.logical_or(all_finished, no_samples)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : base_next_inputs",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "maybe_sample",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "map_structure_1029": {
                "variable": {
                    "value": "output_shape_with_unknown_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda s: tf.TensorShape([None]).concatenate(s)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._cell.output_size",
                            "Attribute"
                        ]
                    ]
                }
            },
            "get_default_graph_374": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_value_389": {
                "variable": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "pylist": {
                    "value": "tf.convert_to_tensor(batch_size, name='batch_size')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorArray_396": {
                "dtype": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "0 if dynamic_size else maximum_iterations",
                    "type": "IfExp",
                    "possible_values": []
                },
                "dynamic_size": {
                    "value": "dynamic_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "maximum_iterations is None or not is_xla",
                            "BoolOp"
                        ]
                    ]
                },
                "element_shape": {
                    "value": "_shape(decoder.batch_size, s)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_407": {
                "x": {
                    "value": "tf.reduce_all(finished)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_or_437": {
                "variable": {
                    "value": "next_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "decoder_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_444": {
                "variable": {
                    "value": "next_sequence_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.logical_not(finished)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.fill(tf.shape(sequence_lengths), time + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(lengths, tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "assert_same_structure_449": {
                "nest1": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "nest2": {
                    "value": "decoder_state",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "assert_same_structure_450": {
                "nest1": {
                    "value": "outputs_ta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda ta, out: ta.write(time, out), outputs_ta, emit)",
                            "Call"
                        ]
                    ]
                },
                "nest2": {
                    "value": "next_outputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "assert_same_structure_451": {
                "nest1": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                },
                "nest2": {
                    "value": "next_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(all_finished, lambda : self._zero_inputs, lambda : tf.nest.map_structure(lambda inp: inp.read(0), self._input_tas))",
                            "Call"
                        ],
                        [
                            "tf.cond(all_finished, lambda : self._zero_inputs, lambda : tf.nest.map_structure(read_from_ta, self._input_tas))",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.logical_or(all_finished, no_samples), lambda : base_next_inputs, maybe_sample)",
                            "Call"
                        ],
                        [
                            "sample_ids",
                            "variable"
                        ],
                        [
                            "self._next_inputs_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_structure_455": {
                "variable": {
                    "value": "emit",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda out, zero: tf.where(finished, zero, out)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "next_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "zero_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_create_zero_outputs(decoder.output_size, decoder.output_dtype, decoder.batch_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_structure_473": {
                "variable": {
                    "value": "next_state",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_maybe_copy_state",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "decoder_state",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "equal_528": {
                "x": {
                    "value": "tf.rank(sample_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_531": {
                "tensor": {
                    "value": "tf.shape(sample_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[pad, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_prod_534": {
                "input_tensor": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sample_shape, dtype=tf.int32, name='sample_shape')",
                            "Call"
                        ],
                        [
                            "tf.reshape(sample_shape, tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1))",
                            "Call"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_535": {
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sample_n_fn(tf.reduce_prod(sample_shape))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_553": {
                "x": {
                    "value": "uniform",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform(new_shape, seed=seed, dtype=probs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(logits, name='probs')",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(probs, name='probs')",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_573": {
                "a": {
                    "value": "draws",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits_2d, n, seed=seed, output_dtype=sample_dtype)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(draws), tf.concat([[n], batch_shape_tensor], 0))",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_574": {
                "values": {
                    "value": "[[n], batch_shape_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_675": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "size_678": {
                "variable": {
                    "value": "self._batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_682": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_687": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_712": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_structure_716": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_transpose_batch_time",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_752": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_762": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_769": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_813": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_825": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_826": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(auxiliary_inputs, name='auxiliary_inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, auxiliary_inputs)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda ta: ta.read(next_time), self._auxiliary_input_tas)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(auxiliary_inputs, indices)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "auxiliary_inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "map_structure_828": {
                "variable": {
                    "value": "maybe_concatenated_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x, y: tf.concat((x, y), -1)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs, name='inputs')",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(auxiliary_inputs, name='auxiliary_inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, auxiliary_inputs)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda ta: ta.read(next_time), self._auxiliary_input_tas)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(auxiliary_inputs, indices)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_853": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_861": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_894": {
                "variable": {
                    "value": "where_sampling",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(sample_ids)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_896": {
                "variable": {
                    "value": "where_not_sampling",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.logical_not(sample_ids))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_nd_898": {
                "variable": {
                    "value": "outputs_sampling",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicDecoderOutput(cell_outputs, sample_ids)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "where_sampling",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(sample_ids), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_899": {
                "variable": {
                    "value": "inputs_not_sampling",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "base_next_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "where_not_sampling",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(tf.logical_not(sample_ids)), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_904": {
                "variable": {
                    "value": "base_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "base_next_inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_944": {
                "input": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "map_structure_1033": {
                "func": {
                    "value": "lambda s: s[1:]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "layer_output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._output_layer.compute_output_shape(output_shape_with_unknown_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_structure_1049": {
                "func": {
                    "value": "lambda _: dtype",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "self._rnn_output_size()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_1075": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TensorShape_391": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concatenate_391": {
                "arys": {
                    "value": "from_shape",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_all_407": {
                "input_tensor": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_435": {
                "variable": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "getattr(decoder_state, 'lengths', None)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "rank_528": {
                "input": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sample_shape, dtype=tf.int32, name='sample_shape')",
                            "Call"
                        ],
                        [
                            "tf.reshape(sample_shape, tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1))",
                            "Call"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_531": {
                "input": {
                    "value": "sample_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(sample_shape, dtype=tf.int32, name='sample_shape')",
                            "Call"
                        ],
                        [
                            "tf.reshape(sample_shape, tf.pad(tf.shape(sample_shape), paddings=[[pad, 0]], constant_values=1))",
                            "Call"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ],
                        [
                            "()",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "argmax_764": {
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "BasicDecoderOutput(cell_outputs, sample_ids)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_structure_832": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_transpose_batch_time",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(auxiliary_inputs, name='auxiliary_inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, auxiliary_inputs)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda ta: ta.read(next_time), self._auxiliary_input_tas)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(auxiliary_inputs, indices)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_structure_836": {
                "func": {
                    "value": "_unstack_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(auxiliary_inputs, name='auxiliary_inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, auxiliary_inputs)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda ta: ta.read(next_time), self._auxiliary_input_tas)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(auxiliary_inputs, indices)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_structure_881": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda ta: ta.read(next_time)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "self._auxiliary_input_tas",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_913": {
                "input_tensor": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.argmax(outputs, axis=-1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(sample_ids, tf.bool)",
                            "Call"
                        ],
                        [
                            "self._helper.sample(time=time, outputs=cell_outputs, state=cell_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_or_915": {
                "x": {
                    "value": "all_finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ],
                        [
                            "tf.reduce_all(finished)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "no_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_not(tf.reduce_any(sample_ids))",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_1047": {
                "structure": {
                    "value": "self._initial_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_390": {
                "value": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor_util.constant_value(tf.convert_to_tensor(batch_size, name='batch_size'))",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "batch_size",
                    "type": "str",
                    "possible_values": []
                }
            },
            "logical_not_445": {
                "x": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_446": {
                "dims": {
                    "value": "tf.shape(sequence_lengths)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "time + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "where_470": {
                "condition": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "cur",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "new",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_like_727": {
                "input": {
                    "value": "inp[0, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "map_structure_757": {
                "func": {
                    "value": "lambda inp: inp.read(0)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "self._input_tas",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_structure_778": {
                "func": {
                    "value": "read_from_ta",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "self._input_tas",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_nd_884": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(auxiliary_inputs, name='auxiliary_inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, auxiliary_inputs)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda ta: ta.read(next_time), self._auxiliary_input_tas)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(auxiliary_inputs, indices)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_structure_885": {
                "func": {
                    "value": "lambda x, y: tf.concat((x, y), -1)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "outputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(auxiliary_inputs, name='auxiliary_inputs')",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(_transpose_batch_time, auxiliary_inputs)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda ta: ta.read(next_time), self._auxiliary_input_tas)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(auxiliary_inputs, indices)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_890": {
                "condition": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.argmax(outputs, axis=-1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(sample_ids, tf.bool)",
                            "Call"
                        ],
                        [
                            "self._helper.sample(time=time, outputs=cell_outputs, state=cell_state)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "maybe_concatenate_auxiliary_inputs(outputs)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "base_next_inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "where_895": {
                "condition": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.argmax(outputs, axis=-1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(sample_ids, tf.bool)",
                            "Call"
                        ],
                        [
                            "self._helper.sample(time=time, outputs=cell_outputs, state=cell_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_897": {
                "condition": {
                    "value": "tf.logical_not(sample_ids)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scatter_nd_905": {
                "indices": {
                    "value": "where_sampling",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(sample_ids), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "sampled_next_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "maybe_concatenate_auxiliary_inputs(self._next_inputs_fn(outputs_sampling), where_sampling)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "base_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(base_next_inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "scatter_nd_908": {
                "indices": {
                    "value": "where_not_sampling",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.where(tf.logical_not(sample_ids)), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "inputs_not_sampling",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(base_next_inputs, where_not_sampling)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "base_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(base_next_inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_1030": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concatenate_1030": {
                "arys": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_446": {
                "input": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(lengths, tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_456": {
                "condition": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(0, self._sequence_length)",
                            "Call"
                        ],
                        [
                            "next_time >= self._sequence_length",
                            "Compare"
                        ],
                        [
                            "tf.tile([False], [self._batch_size])",
                            "Call"
                        ],
                        [
                            "self._end_fn(sample_ids)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "zero",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_581": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "concat_829": {
                "values": {
                    "value": "(x, y)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "logical_not_897": {
                "x": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.argmax(outputs, axis=-1), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(sample_ids, tf.bool)",
                            "Call"
                        ],
                        [
                            "self._helper.sample(time=time, outputs=cell_outputs, state=cell_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_886": {
                "values": {
                    "value": "(x, y)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/contrib/seq2seq_test.py": {
        "tensorflow": {
            "disable_v2_behavior_21": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_408": {
                "variable": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "np.ones(batch_size) * start_token",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "vocabulary_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "7",
                            "int"
                        ],
                        [
                            "7",
                            "int"
                        ]
                    ]
                }
            },
            "one_hot_487": {
                "variable": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "np.ones(batch_size) * start_token",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "vocabulary_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "7",
                            "int"
                        ],
                        [
                            "7",
                            "int"
                        ]
                    ]
                }
            },
            "main_559": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LSTMCell_41": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cell_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "input_depth",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ]
                    ]
                }
            },
            "LSTMCell_119": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cell_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "input_depth",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ]
                    ]
                }
            },
            "LSTMCell_181": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cell_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "input_depth",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ]
                    ]
                }
            },
            "LSTMCell_272": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cell_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "input_depth",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ]
                    ]
                }
            },
            "constant_273": {
                "variable": {
                    "value": "sampling_probability",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sampling_probability",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(sampling_probability)",
                            "Call"
                        ]
                    ]
                }
            },
            "dynamic_rnn_136": {
                "variable": {
                    "value": "(final_rnn_outputs, final_rnn_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(cell_depth)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(cell_depth)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(cell_depth)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(cell_depth)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(vocabulary_size)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(vocabulary_size)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.randn(max_time, batch_size, input_depth).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "np.random.randn(batch_size, max_time, input_depth).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "np.random.randn(batch_size, max_time, input_depth).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "np.random.randn(batch_size, max_time, input_depth).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "np.random.randn(batch_size, max_time, input_depth).astype(np.float32)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_length if use_sequence_length else None",
                    "type": "IfExp",
                    "possible_values": []
                },
                "initial_state": {
                    "value": "zero_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell.zero_state(dtype=tf.float32, batch_size=batch_size)",
                            "Call"
                        ]
                    ]
                },
                "scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dense_185": {
                "variable": {
                    "value": "output_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "output_layer_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "int"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "one_hot_416": {
                "indices": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "depth": {
                    "value": "vocabulary_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "7",
                            "int"
                        ],
                        [
                            "7",
                            "int"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_417": {
                "x": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sess_results['step_outputs'].sample_id",
                            "Attribute"
                        ],
                        [
                            "sess_results['step_outputs'].sample_id",
                            "Attribute"
                        ],
                        [
                            "sess_results['step_outputs'].sample_id",
                            "Attribute"
                        ]
                    ]
                },
                "y": {
                    "value": "end_token",
                    "type": "variable",
                    "possible_values": [
                        [
                            "6",
                            "int"
                        ],
                        [
                            "6",
                            "int"
                        ]
                    ]
                }
            },
            "LSTMCell_423": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "vocabulary_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "7",
                            "int"
                        ],
                        [
                            "7",
                            "int"
                        ]
                    ]
                }
            },
            "LSTMCell_502": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "vocabulary_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "7",
                            "int"
                        ],
                        [
                            "7",
                            "int"
                        ]
                    ]
                }
            },
            "global_variables_initializer_72": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_127": {
                "name_or_scope": {
                    "value": "root",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_135": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "global_variables_initializer_143": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_209": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_227": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "argmax_278": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_309": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_326": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_420": {
                "name_or_scope": {
                    "value": "testStepWithInferenceHelper",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.01)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_499": {
                "name_or_scope": {
                    "value": "testStepWithInferenceHelper",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.01)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorShape_200": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_279": {
                "indices": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(outputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "cell_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "10",
                            "int"
                        ],
                        [
                            "input_depth",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ],
                        [
                            "vocabulary_size",
                            "variable"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_300": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_445": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_458": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_524": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_537": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_422": {
                "value": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "TensorShape_436": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_initializer_501": {
                "value": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/interfaces/midi/magenta_midi.py": {
        "tensorflow": {
            "disable_v2_behavior_36": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DEFINE_bool_40": {
                "name": {
                    "value": "list_ports",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "help": {
                    "value": "Only list available MIDI ports.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_44": {
                "name": {
                    "value": "input_ports",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "magenta_in",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of names of the input MIDI ports.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_48": {
                "name": {
                    "value": "output_ports",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "magenta_out",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of names of the output MIDI ports.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_bool_52": {
                "name": {
                    "value": "passthrough",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "help": {
                    "value": "Whether to pass input messages through to the output port.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_56": {
                "name": {
                    "value": "clock_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use with value 127 as a signal for a tick of the external clock. If None, an internal clock is used that ticks once per bar based on the qpm.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_62": {
                "name": {
                    "value": "end_call_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use with value 127 as a signal to end the call phrase on the next tick.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_67": {
                "name": {
                    "value": "panic_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use with value 127 as a panic signal to close open notes and clear playback sequence.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_72": {
                "name": {
                    "value": "mutate_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use with value 127 as a mutate signal to generate a new response using the current response sequence as a seed.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_77": {
                "name": {
                    "value": "min_listen_ticks_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use for controlling minimum listen duration. The value for the control number will be used in clock ticks. Inputs less than this length will be ignored.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_83": {
                "name": {
                    "value": "max_listen_ticks_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use for controlling maximum listen duration. The value for the control number will be used in clock ticks. After this number of ticks, a response will automatically be generated. A 0 value signifies infinite duration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_90": {
                "name": {
                    "value": "response_ticks_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use for controlling response duration. The value for the control number will be used in clock ticks. If not set, the response duration will match the call duration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_96": {
                "name": {
                    "value": "temperature_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use for controlling softmax temperature.The value of control changes with this number will be used to set the temperature in a linear range between 0.1 and 2.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_111": {
                "name": {
                    "value": "metronome_channel",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The 0-based MIDI channel to output the metronome on. Ignored if `enable_metronome` is False or `clock_control_number` is provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_116": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "120",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to use for the metronome and generated sequence. Overriden by values of control change signals for `tempo_control_number`.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_121": {
                "name": {
                    "value": "tempo_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use for controlling tempo. qpm will be set to 60 more than the value of the control change.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_126": {
                "name": {
                    "value": "loop_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control number to use for determining whether to loop the response. A value of 127 turns looping on and any other value turns it off.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_131": {
                "name": {
                    "value": "bundle_files",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A comma-separated list of the location of the bundle files to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_135": {
                "name": {
                    "value": "generator_select_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control number to use for selecting between generators when multiple bundle files are specified. Required unless only a single bundle file is specified.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_141": {
                "name": {
                    "value": "state_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The control number to use for sending the state. A value of 0 represents `IDLE`, 1 is `LISTENING`, and 2 is `RESPONDING`.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_146": {
                "name": {
                    "value": "playback_offset",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "Time in seconds to adjust playback time by.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_150": {
                "name": {
                    "value": "playback_channel",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "MIDI channel to send play events.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_158": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "WARN",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged. DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_310": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_390": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_261": {
                "msg": {
                    "value": "You have specified multiple bundle files (generators), without setting `--generator_select_control_number`. You will only be able to use the first generator (%s).",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.bundle_files[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/interfaces/midi/midi_clock.py": {
        "tensorflow": {
            "disable_v2_behavior_21": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DEFINE_string_25": {
                "name": {
                    "value": "output_ports",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "magenta_in",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of names of output MIDI ports.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_29": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "120",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to use for the clock.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_33": {
                "name": {
                    "value": "clock_control_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "42",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The control change number to use with value 127 as a signal for a tick of the clock (1 bar) and a value of 0 for each sub-tick (1 beat).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_38": {
                "name": {
                    "value": "channel",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "0-based MIDI channel numbers to output to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_42": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "WARN",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged. DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_49": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_75": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/interfaces/midi/midi_hub.py": {
        "tensorflow": {
            "warn_50": {
                "msg": {
                    "value": "Could not import RtMidi. Virtual ports are disabled.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warn_921": {
                "msg": {
                    "value": "No input port specified. Capture disabled.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1009": {
                "msg": {
                    "value": "Control change %d: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "msg.control",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "msg.value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warn_680": {
                "msg": {
                    "value": "Skipping %d %.3fs period(s) to catch up on iteration.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "skipped_periods",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(time.time() - next_yield_time) // period",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "period",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_931": {
                "msg": {
                    "value": "\"Opening '%s' as a virtual MIDI port for output.\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "port",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_midi_ports",
                            "variable"
                        ],
                        [
                            "output_midi_ports",
                            "variable"
                        ]
                    ]
                }
            },
            "info_912": {
                "msg": {
                    "value": "\"Opening '%s' as a virtual MIDI port for input.\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "port",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_midi_ports",
                            "variable"
                        ],
                        [
                            "output_midi_ports",
                            "variable"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/interfaces/midi/midi_hub_test.py": {
        "tensorflow": {
            "main_711": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/interfaces/midi/midi_interaction.py": {
        "tensorflow": {
            "info_270": {
                "msg": {
                    "value": "State: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.State.to_string(state)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_275": {
                "msg": {
                    "value": "End call signal received.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_280": {
                "msg": {
                    "value": "Panic signal received.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_285": {
                "msg": {
                    "value": "Mutate signal received.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_336": {
                "msg": {
                    "value": "\"Generating sequence using '%s' generator.\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self._sequence_generator.details.id",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_339": {
                "msg": {
                    "value": "Generator Details: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self._sequence_generator.details",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_341": {
                "msg": {
                    "value": "Bundle Details: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self._sequence_generator.bundle_details",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_343": {
                "msg": {
                    "value": "Generator Options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_492": {
                "msg": {
                    "value": "Ignoring mutate request with nothing to mutate.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_426": {
                "msg": {
                    "value": "Input too short (%d vs %d). Skipping.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "listen_ticks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "listen_ticks + 1",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self._min_listen_ticks",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warn_468": {
                "msg": {
                    "value": "Response too late. Pushing back %d ticks.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "push_ticks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(time.time() - response_start_time) // tick_duration + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_build_mobilenet_model.py": {
        "tensorflow": {
            "reduce_mean_163": {
                "variable": {
                    "value": "bottleneck_feat",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "feat_convlayer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "end_points[mobilenet_end_point]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_149": {
                "name": {
                    "value": "style_prediction_mobilenet",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_149": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_161": {
                "name": {
                    "value": "bottleneck",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_178": {
                "name_or_scope": {
                    "value": "style_params",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_scope_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_167": {
                "name_or_scope": {
                    "value": "mobilenet_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_180": {
                "name_or_scope": {
                    "value": "activation_names[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squeeze_191": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(bottleneck_feat, activation_depths[i], [1, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(beta, [1, 2], name='SpatialSqueeze')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "SpatialSqueeze",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_199": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(bottleneck_feat, activation_depths[i], [1, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(gamma, [1, 2], name='SpatialSqueeze')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "SpatialSqueeze",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_build_model.py": {
        "tensorflow": {
            "reduce_mean_151": {
                "variable": {
                    "value": "bottleneck_feat",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "feat_convlayer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "end_points[inception_end_point]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "name_scope_132": {
                "name": {
                    "value": "style_prediction",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_132": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_149": {
                "name": {
                    "value": "bottleneck",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_165": {
                "name_or_scope": {
                    "value": "style_params",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_scope_133": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_167": {
                "name_or_scope": {
                    "value": "activation_names[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squeeze_179": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(bottleneck_feat, activation_depths[i], [1, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(beta, [1, 2], name='SpatialSqueeze')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "SpatialSqueeze",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_187": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(bottleneck_feat, activation_depths[i], [1, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(gamma, [1, 2], name='SpatialSqueeze')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "SpatialSqueeze",
                    "type": "str",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_231": {
                "stddev": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_convert_tflite.py": {
        "tensorflow": {
            "Saver_53": {
                "variable": {
                    "value": "model_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TFRecordDataset_243": {
                "variable": {
                    "value": "style_dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "style_dataset_file",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Glob_251": {
                "variable": {
                    "value": "data_files",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "tf_record_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(imagenet_data_dir, '%s-*' % 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordDataset_252": {
                "variable": {
                    "value": "content_dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "data_files",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gfile.Glob(tf_record_pattern)",
                            "Call"
                        ]
                    ]
                }
            },
            "load_310": {
                "variable": {
                    "value": "loaded",
                    "type": "variable",
                    "possible_values": []
                },
                "export_dir": {
                    "value": "session",
                    "type": "variable",
                    "possible_values": []
                },
                "tags": {
                    "value": "['serve']",
                    "type": "List",
                    "possible_values": []
                },
                "options": {
                    "value": "predict_saved_model",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "make_initializable_iterator_316": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "style_dataset.batch(1)",
                            "Call"
                        ],
                        [
                            "style_dataset.batch(batch_size)",
                            "Call"
                        ],
                        [
                            "content_dataset.batch(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "IsDirectory_55": {
                "dirname": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(checkpoint)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_56": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(checkpoint)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_78": {
                "variable": {
                    "value": "style_image_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "style_image",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "content_image_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "content_image",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_146": {
                "msg": {
                    "value": "'Converted to TF Lite float model: %s; Size: %d KB.' % (float_tflite_file, len(tflite_float_model) / 1024)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_154": {
                "msg": {
                    "value": "'Converted to TF Lite weight quantized model: %s; Size: %d KB.' % (quantized_tflite_file, len(tflite_quantize_model) / 1024)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_185": {
                "msg": {
                    "value": "'Converted to TF Lite full integer quantized model: %s; Size: %d KB.' % (calibrated_tflite_file, len(tflite_full_int8_quantize_model) / 1024)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "parse_single_example_205": {
                "variable": {
                    "value": "image_raw",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "{raw_image_key_name: tf.FixedLenFeature([], tf.string)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "decode_jpeg_209": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_raw[raw_image_key_name]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_210": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_raw[raw_image_key_name])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(image, (image_size, image_size))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(image, axis=0)",
                            "Call"
                        ],
                        [
                            "image / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "resize_bilinear_211": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_raw[raw_image_key_name])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(image, (image_size, image_size))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(image, axis=0)",
                            "Call"
                        ],
                        [
                            "image / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "size": {
                    "value": "(image_size, image_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "squeeze_212": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_raw[raw_image_key_name])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(image, (image_size, image_size))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(image, axis=0)",
                            "Call"
                        ],
                        [
                            "image / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_227": {
                "x": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(image)[2]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "make_initializable_iterator_276": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "style_dataset.batch(1)",
                            "Call"
                        ],
                        [
                            "style_dataset.batch(batch_size)",
                            "Call"
                        ],
                        [
                            "content_dataset.batch(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_307": {
                "msg": {
                    "value": "Started calculating style bottlenecks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_331": {
                "msg": {
                    "value": "Finished calculating style bottlenecks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "make_initializable_iterator_364": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "style_dataset.batch(1)",
                            "Call"
                        ],
                        [
                            "style_dataset.batch(batch_size)",
                            "Call"
                        ],
                        [
                            "content_dataset.batch(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_379": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "isdir_388": {
                "path": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_468": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_469": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_57": {
                "msg": {
                    "value": "'loading latest checkpoint file: {}'.format(checkpoint)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "simple_save_102": {
                "session": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "export_dir": {
                    "value": "predict_saved_model_folder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(saved_model_dir, 'predict')",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "{style_image_tensor.name: style_image_tensor}",
                    "type": "Dict",
                    "possible_values": []
                },
                "outputs": {
                    "value": "{'style_bottleneck': bottleneck_feat}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "debug_107": {
                "msg": {
                    "value": "Export predict SavedModel to",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "predict_saved_model_folder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(saved_model_dir, 'predict')",
                            "Call"
                        ]
                    ]
                }
            },
            "simple_save_109": {
                "session": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "export_dir": {
                    "value": "transform_saved_model_folder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(saved_model_dir, 'transform')",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "{content_image_tensor.name: content_image_tensor, 'style_bottleneck': bottleneck_feat}",
                    "type": "Dict",
                    "possible_values": []
                },
                "outputs": {
                    "value": "{'stylized_image': stylized_images}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "debug_117": {
                "msg": {
                    "value": "Export transform SavedModel to",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "transform_saved_model_folder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(saved_model_dir, 'transform')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_143": {
                "name": {
                    "value": "float_tflite_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_151": {
                "name": {
                    "value": "quantized_tflite_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_182": {
                "name": {
                    "value": "calibrated_tflite_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_226": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_raw[raw_image_key_name])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(image, (image_size, image_size))",
                            "Call"
                        ],
                        [
                            "tf.squeeze(image, axis=0)",
                            "Call"
                        ],
                        [
                            "image / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "warn_389": {
                "msg": {
                    "value": "'Folder %s already existed.' % output_dir",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_425": {
                "graph": {
                    "value": "tf.Graph()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FixedLenFeature_207": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Graph_425": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_distill_mobilenet.py": {
        "tensorflow": {
            "set_verbosity_75": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_184": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_185": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_squared_error_133": {
                "variable": {
                    "value": "mse_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "inception_bottleneck_feat",
                    "type": "variable",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "bottleneck_feat",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "AdamOptimizer_153": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "FLAGS.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_80": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks, worker_device=device)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_97": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_130": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_143": {
                "name": {
                    "value": "total_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mse_loss",
                            "variable"
                        ],
                        [
                            "total_loss + true_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "image_144": {
                "name": {
                    "value": "image/0_content_inputs",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "content_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_145": {
                "name": {
                    "value": "image/1_style_inputs_orig",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "style_inputs_orig_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_146": {
                "name": {
                    "value": "image/2_style_inputs_aug",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "style_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_147": {
                "name": {
                    "value": "image/3_stylized_images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stylized_images",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "replica_device_setter_81": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "worker_device": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/cpu:0' if not FLAGS.ps_tasks else '/job:worker/cpu:0'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "replica_device_setter_97": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_141": {
                "name": {
                    "value": "mse",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "mse_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.losses.mean_squared_error(inception_bottleneck_feat, bottleneck_feat)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_142": {
                "name": {
                    "value": "true_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "true_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.true_loss_weight * true_loss",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_evaluate.py": {
        "tensorflow": {
            "set_verbosity_53": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_131": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_132": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_55": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "image_102": {
                "name": {
                    "value": "'image/{}/0_eval_content_inputs'.format(FLAGS.eval_name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "eval_content_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_104": {
                "name": {
                    "value": "'image/{}/1_eval_style_inputs'.format(FLAGS.eval_name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "eval_style_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_106": {
                "name": {
                    "value": "'image/{}/2_eval_stylized_images'.format(FLAGS.eval_name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "stylized_images",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_108": {
                "name": {
                    "value": "'image/{}/3_stylized_noise'.format(FLAGS.eval_name)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "stylized_noise",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_113": {
                "variable": {
                    "value": "metrics[key]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "a": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "slice_78": {
                "input_": {
                    "value": "eval_style_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[min(4, FLAGS.batch_size), -1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_losses.py": {
        "tensorflow": {
            "reduce_mean_100": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(end_points[name] - stylized_end_points[name]) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_132": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(learning_utils.gram_matrix(stylized_end_points[name]) - learning_utils.gram_matrix(style_end_points[name])) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "name_scope_47": {
                "name": {
                    "value": "content_endpoints",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_49": {
                "name": {
                    "value": "style_endpoints",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_51": {
                "name": {
                    "value": "stylized_endpoints",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_55": {
                "name": {
                    "value": "content_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_60": {
                "name": {
                    "value": "style_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_65": {
                "name": {
                    "value": "total_variation_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_70": {
                "name": {
                    "value": "total_loss",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_train.py": {
        "tensorflow": {
            "set_verbosity_69": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_157": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_158": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_70": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "AdamOptimizer_120": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "FLAGS.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_74": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks, worker_device=device)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_91": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_114": {
                "name": {
                    "value": "image/0_content_inputs",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "content_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_115": {
                "name": {
                    "value": "image/1_style_inputs_orig",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "style_inputs_orig_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_116": {
                "name": {
                    "value": "image/2_style_inputs_aug",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "style_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_117": {
                "name": {
                    "value": "image/3_stylized_images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stylized_images",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "replica_device_setter_75": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "worker_device": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/cpu:0' if not FLAGS.ps_tasks else '/job:worker/cpu:0'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "replica_device_setter_91": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_111": {
                "name": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_train_mobile.py": {
        "tensorflow": {
            "set_verbosity_70": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_159": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_160": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "AdamOptimizer_123": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "FLAGS.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_75": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks, worker_device=device)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_91": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_118": {
                "name": {
                    "value": "image/0_content_inputs",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "content_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_119": {
                "name": {
                    "value": "image/1_style_inputs_aug",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "style_inputs_",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_120": {
                "name": {
                    "value": "image/2_stylized_images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stylized_images",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "replica_device_setter_76": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "worker_device": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/cpu:0' if not FLAGS.ps_tasks else '/job:worker/cpu:0'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "replica_device_setter_91": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_115": {
                "name": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/arbitrary_image_stylization_with_weights.py": {
        "tensorflow": {
            "set_verbosity_57": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_63": {
                "variable": {
                    "value": "style_img_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_72": {
                "variable": {
                    "value": "content_img_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Glob_102": {
                "variable": {
                    "value": "style_img_list",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "FLAGS.style_images_paths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Glob_109": {
                "variable": {
                    "value": "content_img_list",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "FLAGS.content_images_paths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_177": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_178": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Exists_58": {
                "filename": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MkDir_59": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Graph_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "IsDirectory_90": {
                "dirname": {
                    "value": "FLAGS.checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "latest_checkpoint_91": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_94": {
                "msg": {
                    "value": "'loading latest checkpoint file: {}'.format(checkpoint)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "local_variables_initializer_98": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_138": {
                "msg": {
                    "value": "'Stylizing (%d) %s with (%d) %s' % (content_i, content_img_name, style_i, style_img_name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/export_hub.py": {
        "tensorflow": {
            "wrap_function_73": {
                "variable": {
                    "value": "umbrella_wrapped",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "umbrella_function",
                    "type": "variable",
                    "possible_values": []
                },
                "signature": {
                    "value": "input_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.TensorSpec((None, None, None, 3), tf.float32), tf.TensorSpec((None, None, None, 3), tf.float32)]",
                            "List"
                        ]
                    ]
                }
            },
            "Checkpoint_80": {
                "variable": {
                    "value": "obj",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_94": {
                "msg": {
                    "value": "Saved hub module in: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.export_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_98": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_99": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TensorSpec_59": {
                "shape": {
                    "value": "(None, None, None, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorSpec_60": {
                "shape": {
                    "value": "(None, None, None, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Session_90": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_92": {
                "var_list": {
                    "value": "obj.variables",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_93": {
                "obj": {
                    "value": "obj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Checkpoint()",
                            "Call"
                        ],
                        [
                            "create_hub_module_object()",
                            "Call"
                        ]
                    ]
                },
                "export_dir": {
                    "value": "FLAGS.export_path",
                    "type": "Attribute",
                    "possible_values": []
                },
                "signatures": {
                    "value": "obj.__call__",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "initialize_all_variables_91": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/arbitrary_image_stylization/nza_model.py": {
        "tensorflow": {
            "variable_scope_50": {
                "name_or_scope": {
                    "value": "transformer",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_70": {
                "name_or_scope": {
                    "value": "residual",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_76": {
                "name_or_scope": {
                    "value": "expand",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_normal_initializer_55": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_57": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "variable_scope_66": {
                "name_or_scope": {
                    "value": "contract",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/coconet_evaluate.py": {
        "tensorflow": {
            "ListDirectory_58": {
                "variable": {
                    "value": "possible_checkpoint_dirs",
                    "type": "variable",
                    "possible_values": []
                },
                "dirname": {
                    "value": "FLAGS.eval_logdir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_94": {
                "msg": {
                    "value": "Done",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_109": {
                "msg": {
                    "value": "'Writing to path: %s' % log_fpath",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_135": {
                "msg": {
                    "value": "Retrieving pianorolls from %s set of %s dataset.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "fold",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "hparams.dataset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_145": {
                "msg": {
                    "value": "Retrieving pianorolls from %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "pianoroll_fpath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), path)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_158": {
                "msg": {
                    "value": "# of total pieces in set: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "len(pianorolls)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_162": {
                "msg": {
                    "value": "max_len %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "max(lengths)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_163": {
                "msg": {
                    "value": "unique lengths %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "np.unique(sorted((pianoroll.shape[0] for pianoroll in pianorolls)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_166": {
                "msg": {
                    "value": "shape %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "pianorolls[0].shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_170": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_171": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_172": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_78": {
                "dirname": {
                    "value": "eval_logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.eval_logdir, EVAL_SUBDIR)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_127": {
                "msg": {
                    "value": "Writing evaluation statistics to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "log_fpath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(eval_logdir, log_fname)",
                            "Call"
                        ],
                        [
                            "os.path.join(eval_logdir, log_fname)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_data_files_path_144": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_149": {
                "msg": {
                    "value": "pianorolls.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_157": {
                "msg": {
                    "value": "pianorolls.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_161": {
                "msg": {
                    "value": "lengths %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "np.sort(lengths)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_67": {
                "msg": {
                    "value": "Using checkpoint dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint",
                            "Attribute"
                        ],
                        [
                            "os.path.join(FLAGS.eval_logdir, possible_checkpoint_dirs[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "IsDirectory_61": {
                "dirname": {
                    "value": "os.path.join(FLAGS.eval_logdir, i)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/coconet_sample.py": {
        "tensorflow": {
            "info_71": {
                "msg": {
                    "value": "basepath: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "basepath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.generation_output_dir, label)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_72": {
                "dirname": {
                    "value": "basepath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.generation_output_dir, label)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_76": {
                "dirname": {
                    "value": "midi_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'midi')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_77": {
                "msg": {
                    "value": "Made directory %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "midi_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'midi')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_81": {
                "msg": {
                    "value": "Writing final result to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "result_npy_save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'generated_result.npy')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_97": {
                "msg": {
                    "value": "Reading to check %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "intermediate_steps_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'intermediate_steps.npz')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_115": {
                "msg": {
                    "value": "Done",
                    "type": "str",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_687": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_688": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_86": {
                "msg": {
                    "value": "Done",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_92": {
                "msg": {
                    "value": "Writing intermediate steps to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "intermediate_steps_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'intermediate_steps.npz')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_171": {
                "msg": {
                    "value": "Tentative shape of pianorolls to be generated: %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[gen_batch_size] + self.hparams.pianoroll_shape",
                            "BinOp"
                        ],
                        [
                            "[gen_batch_size] + self.hparams.pianoroll_shape",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_257": {
                "msg": {
                    "value": "Tentative shape of pianorolls to be generated: %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[gen_batch_size] + self.hparams.pianoroll_shape",
                            "BinOp"
                        ],
                        [
                            "[gen_batch_size] + self.hparams.pianoroll_shape",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_270": {
                "msg": {
                    "value": "output pianorolls shape: %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.pianorolls.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_286": {
                "msg": {
                    "value": "pianoroll shape: %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "pianoroll.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_295": {
                "msg": {
                    "value": "Writing midi to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "midi_fpath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(midi_path, '%s_%i.midi' % (label, i))",
                            "Call"
                        ]
                    ]
                }
            },
            "info_350": {
                "msg": {
                    "value": "requested_shape: %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "requested_shape",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_360": {
                "msg": {
                    "value": "resulting shape: %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "rolls.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_356": {
                "msg": {
                    "value": "'WARNING: requested tt %r != prime tt %r' % (tt, mroll.shape[0])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_104": {
                "msg": {
                    "value": "Writing context to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "context_fpath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'context.npy')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/coconet/coconet_train.py": {
        "tensorflow": {
            "Summary_206": {
                "variable": {
                    "value": "summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_213": {
                "msg": {
                    "value": "%s, epoch %d: loss (mask): %.4f, loss (unmask): %.4f, loss (total): %.4f, log lr: %.4f, time taken: %.4f",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "experiment_type",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "epoch_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "epoch_count + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "set_verbosity_228": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_252": {
                "dirname": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.logdir, hparams.log_subdir_str)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_254": {
                "msg": {
                    "value": "Writing to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "config_fpath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(logdir, 'config')",
                            "Call"
                        ]
                    ]
                }
            },
            "no_op_260": {
                "variable": {
                    "value": "no_op",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Supervisor_275": {
                "variable": {
                    "value": "sv",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.logdir, hparams.log_subdir_str)",
                            "Call"
                        ]
                    ]
                },
                "saver": {
                    "value": "tf.train.Supervisor.USE_DEFAULT if FLAGS.log_progress else None",
                    "type": "IfExp",
                    "possible_values": []
                },
                "summary_op": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "save_model_secs": {
                    "value": "FLAGS.save_model_secs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_313": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "disable_v2_behavior_381": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_382": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "fatal_231": {
                "msg": {
                    "value": "No input directory was provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_259": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_264": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_324": {
                "msg": {
                    "value": "Previous best %s: %.4f.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.label",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.best",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_325": {
                "dirname": {
                    "value": "os.path.dirname(self.save_path)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_327": {
                "msg": {
                    "value": "'Storing best model so far with loss %.4f at %s.' % (loss, self.save_path)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/export_saved_model.py": {
        "tensorflow": {
            "info_38": {
                "msg": {
                    "value": "Loaded graph.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_52": {
                "msg": {
                    "value": "Exported SavedModel to %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.destination",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_56": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/export_saved_model_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_64": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_35": {
                "dirname": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tempfile.mkdtemp()",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_42": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_45": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DeleteRecursively_60": {
                "dirname": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.save_checkpoint()",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_40": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Exists_58": {
                "filename": {
                    "value": "os.path.join(destination_dir, 'saved_model.pb')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_initializer_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/lib_data.py": {
        "tensorflow": {
            "get_data_files_path_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/lib_evaluation.py": {
        "tensorflow": {
            "info_72": {
                "msg": {
                    "value": "%s loss %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "prefix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "Method Argument"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "_statstr(_flatcat(losses))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_46": {
                "msg": {
                    "value": "evaluating piece %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "pi",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/lib_graph.py": {
        "tensorflow": {
            "random_uniform_initializer_393": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-hparams.init_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "hparams.init_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_139": {
                "variable": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.hparams.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_146": {
                "variable": {
                    "value": "self.decay_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "0.5 * self.learning_rate",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "AdamOptimizer_147": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_170": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(batch_duration)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_171": {
                "variable": {
                    "value": "pad_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "indices[None, :, None, None] < self.lengths[:, None, None, None]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_sum_184": {
                "variable": {
                    "value": "reduced_dd",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "dd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.lengths[:, None, None, None] * tf.to_float(tf.shape(self.pianorolls)[variable_axis])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_187": {
                "variable": {
                    "value": "mask_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pad_mask * self.masks",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, variable_axis]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_188": {
                "variable": {
                    "value": "unmask_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "unmask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pad_mask * (1.0 - self.masks)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, variable_axis]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_201": {
                "variable": {
                    "value": "self.reduced_mask_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask_size[:, :, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_202": {
                "variable": {
                    "value": "self.reduced_unmask_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "unmask_size[:, :, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "group_204": {
                "variable": {
                    "value": "assert_partition_op",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tf.assert_equal(tf.reduce_sum(mask * unmask), 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.assert_equal(self.reduced_mask_size + self.reduced_unmask_size, reduced_dd)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "he_normal_257": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_317": {
                "variable": {
                    "value": "gammas",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_320": {
                "variable": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_323": {
                "variable": {
                    "value": "popmean",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "popmean",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "collections": {
                    "value": "[tf.GraphKeys.MODEL_VARIABLES, tf.GraphKeys.GLOBAL_VARIABLES]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_331": {
                "variable": {
                    "value": "popvariance",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "popvariance",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, output_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "collections": {
                    "value": "[tf.GraphKeys.MODEL_VARIABLES, tf.GraphKeys.GLOBAL_VARIABLES]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_407": {
                "msg": {
                    "value": "Loading checkpoint from %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Session_414": {
                "variable": {
                    "value": "wmodel.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_415": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_129": {
                "values": {
                    "value": "[pianorolls, masks]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "no_op_135": {
                "variable": {
                    "value": "self.train_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_op_136": {
                "variable": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_154": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_264": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "filter_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer['filters']",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "initializer if self.is_training else None",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "conv2d_269": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x + self.output_for_residual",
                            "BinOp"
                        ]
                    ]
                },
                "filters": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', filter_shape, initializer=initializer if self.is_training else None)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, stride, stride, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "layer.get('conv_pad', 'SAME')",
                    "type": "Call",
                    "possible_values": []
                },
                "dilations": {
                    "value": "[1] + dilation_rates + [1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "separable_conv2d_283": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x + self.output_for_residual",
                            "BinOp"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "num_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filter_shape[-1]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "filter_shape[:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth_multiplier": {
                    "value": "self.hparams.sep_conv_depth_multiplier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "layer.get('conv_stride', [1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "layer.get('conv_pad', 'SAME')",
                    "type": "Call",
                    "possible_values": []
                },
                "dilation_rate": {
                    "value": "dilation_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer.get('dilation_rate', [1, 1])",
                            "Call"
                        ]
                    ]
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "depthwise_initializer": {
                    "value": "initializer if self.is_training else None",
                    "type": "IfExp",
                    "possible_values": []
                },
                "pointwise_initializer": {
                    "value": "initializer if self.is_training else None",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "get_variable_308": {
                "variable": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[conv.get_shape()[-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_311": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, weights, strides=[1, stride, stride, 1], padding=layer.get('conv_pad', 'SAME'), dilations=[1] + dilation_rates + [1])",
                            "Call"
                        ],
                        [
                            "tf.layers.separable_conv2d(x, num_outputs, filter_shape[:2], depth_multiplier=self.hparams.sep_conv_depth_multiplier, strides=layer.get('conv_stride', [1, 1]), padding=layer.get('conv_pad', 'SAME'), dilation_rate=dilation_rate, activation=None, depthwise_initializer=initializer if self.is_training else None, pointwise_initializer=initializer if self.is_training else None)",
                            "Call"
                        ],
                        [
                            "tf.concat(pointwise_splits, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [conv.get_shape()[-1]], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                }
            },
            "moments_342": {
                "variable": {
                    "value": "(batchmean, batchvariance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x + self.output_for_residual",
                            "BinOp"
                        ]
                    ]
                },
                "axes": {
                    "value": "[0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_356": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x + self.output_for_residual",
                            "BinOp"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "variance": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "offset": {
                    "value": "betas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('beta', [output_dim], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gammas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('gamma', [1, 1, 1, output_dim], initializer=tf.constant_initializer(0.1))",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "self.hparams.batch_norm_variance_epsilon",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool_367": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x + self.output_for_residual",
                            "BinOp"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, pooling[0], pooling[1], 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, pooling[0], pooling[1], 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "layer['pool_pad']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_395": {
                "name_or_scope": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(-hparams.init_scale, hparams.init_scale)",
                            "Call"
                        ],
                        [
                            "tf.keras.initializers.he_normal()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_416": {
                "msg": {
                    "value": "loading checkpoint %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_115": {
                "msg": {
                    "value": "%s_%r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "var.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "var.get_shape().as_list()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_153": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_162": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_169": {
                "input": {
                    "value": "self.pianorolls",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_182": {
                "x": {
                    "value": "tf.shape(self.pianorolls)[variable_axis]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_195": {
                "input_tensor": {
                    "value": "unreduced_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "unreduced_loss * (dd / mask_size)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "assert_equal_205": {
                "x": {
                    "value": "tf.reduce_sum(mask * unmask)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "assert_equal_206": {
                "x": {
                    "value": "self.reduced_mask_size + self.reduced_unmask_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "reduced_dd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(dd)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_208": {
                "control_inputs": {
                    "value": "[assert_partition_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "info_279": {
                "msg": {
                    "value": "num_splits %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "num_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer.get('num_pointwise_splits', 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_280": {
                "msg": {
                    "value": "dilation_rate %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "dilation_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer.get('dilation_rate', [1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_295": {
                "variable": {
                    "value": "splits",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, weights, strides=[1, stride, stride, 1], padding=layer.get('conv_pad', 'SAME'), dilations=[1] + dilation_rates + [1])",
                            "Call"
                        ],
                        [
                            "tf.layers.separable_conv2d(x, num_outputs, filter_shape[:2], depth_multiplier=self.hparams.sep_conv_depth_multiplier, strides=layer.get('conv_stride', [1, 1]), padding=layer.get('conv_pad', 'SAME'), dilation_rate=dilation_rate, activation=None, depthwise_initializer=initializer if self.is_training else None, pointwise_initializer=initializer if self.is_training else None)",
                            "Call"
                        ],
                        [
                            "tf.concat(pointwise_splits, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer.get('num_pointwise_splits', 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_302": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "pointwise_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.layers.dense(splits[i], filter_shape[3] / num_splits, name='split_%d_%d' % (layer_idx, i)) for i in range(num_splits)]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "placeholder_376": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, hparams.num_pitches, hparams.num_instruments]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_379": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, hparams.num_pitches, hparams.num_instruments]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_382": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_94": {
                "name_or_scope": {
                    "value": "'conv%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_global_step_149": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_205": {
                "input_tensor": {
                    "value": "mask * unmask",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_210": {
                "input_tensor": {
                    "value": "mask * unreduced_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_212": {
                "input_tensor": {
                    "value": "unmask * unreduced_loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_319": {
                "value": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_321": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_330": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_338": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "control_dependencies_349": {
                "control_inputs": {
                    "value": "updates",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[popmean.assign_sub(decay * (popmean - mean)), popvariance.assign_sub(decay * (popvariance - variance))]",
                            "List"
                        ]
                    ]
                }
            },
            "log_softmax_160": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_183": {
                "input": {
                    "value": "self.pianorolls",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_299": {
                "inputs": {
                    "value": "splits[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "units": {
                    "value": "filter_shape[3] / num_splits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "'split_%d_%d' % (layer_idx, i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_310": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "identity_350": {
                "input": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/lib_hparams.py": {
        "tensorflow": {
            "info_121": {
                "msg": {
                    "value": "Instantiating hparams...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_266": {
                "msg": {
                    "value": "model_type=%s, input_depth=%d, output_depth=%d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.key",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "input_depth",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_287": {
                "msg": {
                    "value": "num_layers=%d, num_filters=%d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "len(self.layers)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "num_filters",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_302": {
                "msg": {
                    "value": "model_type=%s, input_depth=%d, output_depth=%d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.key",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "input_depth",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_361": {
                "msg": {
                    "value": "num_layers=%d, num_filters=%d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "len(self.layers)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "num_filters",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_324": {
                "msg": {
                    "value": "Increasing max dilation level from %s to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "max_dilation_level",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max(max_time_dilation_level, max_pitch_dilation_level)",
                            "Call"
                        ],
                        [
                            "max_dilation_level + 1",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "max_dilation_level + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_348": {
                "msg": {
                    "value": "layer_dilation_rates %r",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "layer_dilation_rates",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[time_dilation_rate, 1]",
                            "List"
                        ],
                        [
                            "[time_dilation_rate, pitch_dilation_rate]",
                            "List"
                        ]
                    ]
                }
            },
            "info_353": {
                "msg": {
                    "value": "num_split %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "current_num_pointwise_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_pointwise_splits",
                            "variable"
                        ],
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/coconet/lib_pianoroll.py": {
        "tensorflow": {
            "debug_162": {
                "msg": {
                    "value": "Roll shape: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "roll.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_164": {
                "msg": {
                    "value": "Roll argmax: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "np.argmax(roll, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "debug_180": {
                "msg": {
                    "value": "# of instr %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "len(midi.instruments)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "debug_200": {
                "msg": {
                    "value": "Requested roll shape: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "requested_shape",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "debug_201": {
                "msg": {
                    "value": "Roll argmax: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "np.argmax(pianorolls, axis=2) + self.min_pitch",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "warning_192": {
                "msg": {
                    "value": "WARNING: input midi is a longer sequence then the requestedsize (%d > %d)",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "max_tt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.max([roll.shape[0] for roll in instr_rolls])",
                            "Call"
                        ],
                        [
                            "tt",
                            "variable"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(len(sequence) / step_size)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/coconet/lib_saved_model.py": {
        "tensorflow": {
            "predict_signature_def_32": {
                "inputs": {
                    "value": "{'pianorolls': model.model.pianorolls, 'masks': model.model.masks, 'lengths': model.model.lengths}",
                    "type": "Dict",
                    "possible_values": []
                },
                "outputs": {
                    "value": "{'predictions': model.model.predictions}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "load_64": {
                "export_dir": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "tags": {
                    "value": "tags",
                    "type": "variable",
                    "possible_values": []
                },
                "options": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "predict_signature_def_26": {
                "inputs": {
                    "value": "{'pianorolls': model.inputs['pianorolls']}",
                    "type": "Dict",
                    "possible_values": []
                },
                "outputs": {
                    "value": "{'predictions': tf.cast(model.samples, tf.bool)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "error_45": {
                "msg": {
                    "value": "No model or destination provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_30": {
                "x": {
                    "value": "model.samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/coconet/lib_tfsampling.py": {
        "tensorflow": {
            "to_float_276": {
                "variable": {
                    "value": "pianorolls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(pianorolls)",
                            "Call"
                        ],
                        [
                            "np.zeros(target_shape, dtype=np.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_all_277": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.equal(pianorolls, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tile_288": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.to_float(tf.less(probs, pm))[:, :, None, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, pp, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_302": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_315": {
                "variable": {
                    "value": "choices",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(temperature, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.argmax(tf.nn.softmax(logits), -1)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : sample_from_logits(logits)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "one_hot_318": {
                "variable": {
                    "value": "samples_onehot",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "choices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(temperature, 0.0), lambda : tf.argmax(tf.nn.softmax(logits), -1), lambda : sample_from_logits(logits))",
                            "Call"
                        ],
                        [
                            "tf.multinomial(reshaped_logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(choices, tf.shape(logits)[:logits.get_shape().ndims - 1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "pitch_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(logits)[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_float_81": {
                "variable": {
                    "value": "outer_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outer_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(outer_masks)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.reduce_all(tf.equal(outer_masks, 0)), lambda : make_completion_masks(input_pianorolls), lambda : outer_masks)",
                            "Call"
                        ],
                        [
                            "self.inputs['outer_masks']",
                            "Subscript"
                        ],
                        [
                            "self.make_outer_masks(outer_masks, input_pianorolls)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cond_85": {
                "variable": {
                    "value": "outer_masks",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.reduce_all(tf.equal(outer_masks, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : make_completion_masks(input_pianorolls)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : outer_masks",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "to_float_111": {
                "variable": {
                    "value": "sample_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.inputs['sample_steps']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_116": {
                "variable": {
                    "value": "input_pianorolls",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['pianorolls']",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(input_pianorolls)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cond_120": {
                "variable": {
                    "value": "total_gibbs_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(total_gibbs_steps, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.to_float(tt * self.hparams.num_instruments)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.to_float(total_gibbs_steps)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_126": {
                "variable": {
                    "value": "sample_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(sample_steps, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : total_gibbs_steps",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.to_float(sample_steps)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "to_float_155": {
                "variable": {
                    "value": "current_step",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.inputs['current_step']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "while_loop_162": {
                "variable": {
                    "value": "(self.samples, current_step)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda samples, current_step: current_step < sample_steps",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "infer_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[samples, current_step]",
                    "type": "List",
                    "possible_values": []
                },
                "shape_invariants": {
                    "value": "[tf.TensorShape([None, None, None, None]), tf.TensorShape(None)]",
                    "type": "List",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "coco_while",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_193": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_194": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "latest_checkpoint_195": {
                "variable": {
                    "value": "chkpt_fpath",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "self.chkpt_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multinomial_310": {
                "variable": {
                    "value": "choices",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "reshaped_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(logits, [-1, tf.shape(logits)[-1]]) / temperature",
                            "BinOp"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_311": {
                "variable": {
                    "value": "choices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "choices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(temperature, 0.0), lambda : tf.argmax(tf.nn.softmax(logits), -1), lambda : sample_from_logits(logits))",
                            "Call"
                        ],
                        [
                            "tf.multinomial(reshaped_logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(choices, tf.shape(logits)[:logits.get_shape().ndims - 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(logits)[:logits.get_shape().ndims - 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "transpose_319": {
                "a": {
                    "value": "samples_onehot",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(choices, pitch_range)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_324": {
                "x": {
                    "value": "pmin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "pmax - wat / alpha",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_336": {
                "msg": {
                    "value": "num of notes in piece %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "np.sum(generated_piece)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_338": {
                "msg": {
                    "value": "Done.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_342": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_343": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assert_equal_144": {
                "variable": {
                    "value": "check_completion_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.equal(tf.reduce_max(masks, axis=2), 1.0), tf.reduce_max(outputs, axis=2), tf.reduce_max(pianorolls, axis=2))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "get_variable_scope_160": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_196": {
                "msg": {
                    "value": "loading checkpoint %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "chkpt_fpath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(self.chkpt_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_scope_198": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "RunOptions_257": {
                "variable": {
                    "value": "run_options",
                    "type": "variable",
                    "possible_values": []
                },
                "timeout_in_ms": {
                    "value": "timeout_ms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_271": {
                "msg": {
                    "value": "'exit  %s (%.3fmin)' % (label, time_taken)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_277": {
                "x": {
                    "value": "pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(pianorolls)",
                            "Call"
                        ],
                        [
                            "np.zeros(target_shape, dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_278": {
                "x": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.equal(pianorolls, 0), axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.to_float(tf.less(probs, pm))[:, :, None, :], [1, 1, pp, 1])",
                            "Call"
                        ],
                        [
                            "make_bernoulli_masks(tf.shape(pianorolls), mask_prob, outer_masks)",
                            "Call"
                        ],
                        [
                            "np.zeros_like(pianorolls)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_303": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_307": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_315": {
                "x": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['temperature']",
                            "Subscript"
                        ],
                        [
                            "0.99",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_all_86": {
                "input_tensor": {
                    "value": "tf.equal(outer_masks, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_110": {
                "input": {
                    "value": "input_pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['pianorolls']",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(input_pianorolls)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "equal_121": {
                "x": {
                    "value": "total_gibbs_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['total_gibbs_steps']",
                            "Subscript"
                        ],
                        [
                            "tf.cond(tf.equal(total_gibbs_steps, 0), lambda : tf.to_float(tt * self.hparams.num_instruments), lambda : tf.to_float(total_gibbs_steps))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_127": {
                "x": {
                    "value": "sample_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self.inputs['sample_steps'])",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(sample_steps, 0), lambda : total_gibbs_steps, lambda : tf.to_float(sample_steps))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "identity_150": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pianorolls * (1 - masks) + samples * masks",
                            "BinOp"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_158": {
                "x": {
                    "value": "input_pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['pianorolls']",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(input_pianorolls)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_288": {
                "x": {
                    "value": "tf.less(probs, pm)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_306": {
                "control_inputs": {
                    "value": "[tf.assert_greater(temperature, 0.0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_309": {
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, tf.shape(logits)[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_316": {
                "input": {
                    "value": "tf.nn.softmax(logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "placeholder_56": {
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, hparams.num_pitches, hparams.num_instruments]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "pianorolls",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_with_default_63": {
                "input": {
                    "value": "np.zeros((1, 1, hparams.num_pitches, hparams.num_instruments), dtype=np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, hparams.num_pitches, hparams.num_instruments]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "outer_masks",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_with_default_69": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "sample_steps",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_with_default_70": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "total_gibbs_steps",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_with_default_72": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "current_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_with_default_73": {
                "input": {
                    "value": "0.99",
                    "type": "float",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                }
            },
            "equal_86": {
                "x": {
                    "value": "outer_masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(outer_masks)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.reduce_all(tf.equal(outer_masks, 0)), lambda : make_completion_masks(input_pianorolls), lambda : outer_masks)",
                            "Call"
                        ],
                        [
                            "self.inputs['outer_masks']",
                            "Subscript"
                        ],
                        [
                            "self.make_outer_masks(outer_masks, input_pianorolls)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_122": {
                "x": {
                    "value": "tt * self.hparams.num_instruments",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_123": {
                "x": {
                    "value": "total_gibbs_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['total_gibbs_steps']",
                            "Subscript"
                        ],
                        [
                            "tf.cond(tf.equal(total_gibbs_steps, 0), lambda : tf.to_float(tt * self.hparams.num_instruments), lambda : tf.to_float(total_gibbs_steps))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_129": {
                "x": {
                    "value": "sample_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self.inputs['sample_steps'])",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.equal(sample_steps, 0), lambda : total_gibbs_steps, lambda : tf.to_float(sample_steps))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_136": {
                "input": {
                    "value": "pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(pianorolls)",
                            "Call"
                        ],
                        [
                            "np.zeros(target_shape, dtype=np.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_145": {
                "condition": {
                    "value": "tf.equal(tf.reduce_max(masks, axis=2), 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_max(outputs, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_max(pianorolls, axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_149": {
                "control_inputs": {
                    "value": "[check_completion_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_179": {
                "x": {
                    "value": "[tf.shape(pianorolls)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_288": {
                "x": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([bb, tt, ii])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "pm",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_312": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_316": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_145": {
                "x": {
                    "value": "tf.reduce_max(masks, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_max_146": {
                "input_tensor": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pianorolls * (1 - masks) + samples * masks",
                            "BinOp"
                        ],
                        [
                            "tf.identity(outputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_147": {
                "input_tensor": {
                    "value": "pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(pianorolls)",
                            "Call"
                        ],
                        [
                            "np.zeros(target_shape, dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_166": {
                "dims": {
                    "value": "[None, None, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_167": {
                "dims": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "assert_greater_306": {
                "x": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.inputs['temperature']",
                            "Subscript"
                        ],
                        [
                            "0.99",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_max_145": {
                "input_tensor": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_all(tf.equal(pianorolls, 0), axis=2, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.to_float(tf.less(probs, pm))[:, :, None, :], [1, 1, pp, 1])",
                            "Call"
                        ],
                        [
                            "make_bernoulli_masks(tf.shape(pianorolls), mask_prob, outer_masks)",
                            "Call"
                        ],
                        [
                            "np.zeros_like(pianorolls)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_309": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(logits, [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.identity(logits)",
                            "Call"
                        ],
                        [
                            "self.predict(tf.to_float(input_pianorolls), outer_masks)",
                            "Call"
                        ],
                        [
                            "self.predict(pianorolls, masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_179": {
                "input": {
                    "value": "pianorolls",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(pianorolls)",
                            "Call"
                        ],
                        [
                            "np.zeros(target_shape, dtype=np.float32)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/coconet/lib_tfutil.py": {
        "tensorflow": {}
    },
    "magenta/models/coconet/lib_util.py": {
        "tensorflow": {
            "Rename_47": {
                "oldname": {
                    "value": "'%s.tmp' % path",
                    "type": "BinOp",
                    "possible_values": []
                },
                "newname": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Copy_46": {
                "oldpath": {
                    "value": "tmp.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "newpath": {
                    "value": "'%s.tmp' % path",
                    "type": "BinOp",
                    "possible_values": []
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/drums_rnn/drums_rnn_config_flags.py": {
        "tensorflow": {
            "DEFINE_string_21": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "drum_kit",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"Which config to use. Must be one of 'one_drum' or 'drum_kit'.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_25": {
                "name": {
                    "value": "generator_id",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A unique ID for the generator, overriding the default.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_29": {
                "name": {
                    "value": "generator_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A description of the generator, overriding the default.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_33": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/drums_rnn/drums_rnn_create_dataset.py": {
        "tensorflow": {
            "set_verbosity_46": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_62": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/drums_rnn/drums_rnn_create_dataset_test.py": {
        "tensorflow": {
            "disable_v2_behavior_28": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_77": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/drums_rnn/drums_rnn_generate.py": {
        "tensorflow": {
            "DEFINE_string_34": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where the latest checkpoint will be loaded from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "checkpoint_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the checkpoint file. run_dir will take priority over this flag.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_40": {
                "name": {
                    "value": "bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the bundle file. If specified, this will take priority over run_dir and checkpoint_file, unless save_generator_bundle is True, in which case both this flag and either run_dir or checkpoint_file are required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_50": {
                "name": {
                    "value": "bundle_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A short, human-readable text description of the bundle (e.g., training data, hyper parameters, etc.).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_54": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/drums_rnn/generated",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory where MIDI files will be saved to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_57": {
                "name": {
                    "value": "num_outputs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of drum tracks to generate. One MIDI file will be created for each.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_61": {
                "name": {
                    "value": "num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The total number of steps the generated drum tracks should be, priming drum track length + generated steps. Each step is a 16th of a bar.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_65": {
                "name": {
                    "value": "primer_drums",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of tuples containing drum pitch values. For example: \"[(36,42),(),(),(),(42,),(),(),()]\". If specified, this drum track will be used as the priming drum track. If a priming drum track is not specified, drum tracks will be generated from scratch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_72": {
                "name": {
                    "value": "primer_midi",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to a MIDI file containing a drum track that will be used as a priming drum track. If a primer drum track is not specified, drum tracks will be generated from scratch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_77": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to play generated output at. If a primer MIDI is given, the qpm from that will override this flag. If qpm is None, qpm will default to 120.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_82": {
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "The randomness of the generated drum tracks. 1.0 uses the unaltered softmax probabilities, greater than 1.0 makes tracks more random, less than 1.0 makes tracks less random.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_87": {
                "name": {
                    "value": "beam_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The beam size to use for beam search when generating drum tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_90": {
                "name": {
                    "value": "branch_factor",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The branch factor to use for beam search when generating drum tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_93": {
                "name": {
                    "value": "steps_per_iteration",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of steps to take per beam search iteration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_96": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_207": {
                "msg": {
                    "value": "input_sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "primer_sequence",
                            "variable"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_208": {
                "msg": {
                    "value": "generator_options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_221": {
                "msg": {
                    "value": "Wrote %d MIDI files to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.num_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_verbosity_227": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_259": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_260": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_141": {
                "msg": {
                    "value": "--output_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_149": {
                "filename": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_150": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_252": {
                "msg": {
                    "value": "Saving generator bundle to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "bundle_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.bundle_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_164": {
                "msg": {
                    "value": "No priming sequence specified. Defaulting to a single bass drum hit.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_190": {
                "msg": {
                    "value": "Priming sequence is longer than the total number of steps requested: Priming sequence length: %s, Generation length requested: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generate_section.start_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "total_seconds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.num_steps * seconds_per_step",
                            "BinOp"
                        ]
                    ]
                }
            },
            "warning_251": {
                "msg": {
                    "value": "No bundle description provided.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/drums_rnn/drums_rnn_train.py": {
        "tensorflow": {
            "DEFINE_string_26": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/drums_rnn/logdir/run1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where checkpoints and summary events will be saved during training and evaluation. Separate subdirectories for training events and eval events will be created within `run_dir`. Multiple runs can be stored within the parent directory of `run_dir`. Point TensorBoard to the parent directory of `run_dir` to see all your runs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "sequence_example_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to TFRecord file containing tf.SequenceExample records for training or evaluation. A filepattern may also be provided, which will be expanded to all matching files.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "num_training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The the number of global training steps your model should take before exiting training. Leave as 0 to run until terminated manually.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_44": {
                "name": {
                    "value": "num_eval_examples",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of evaluation examples your model should process for each evaluation step.Leave as 0 to use the entire evaluation set.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_48": {
                "name": {
                    "value": "summary_frequency",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "A summary statement will be logged every `summary_frequency` steps during training or every `summary_frequency` seconds during evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_53": {
                "name": {
                    "value": "num_checkpoints",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of most recent checkpoints to keep in the training directory. Keeps all if 0.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_59": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_74": {
                "variable": {
                    "value": "sequence_example_file_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "os.path.expanduser(FLAGS.sequence_example_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_65": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_87": {
                "msg": {
                    "value": "Train dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_108": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_109": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_68": {
                "msg": {
                    "value": "--run_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_71": {
                "msg": {
                    "value": "--sequence_example_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_86": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_93": {
                "msg": {
                    "value": "Eval dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_92": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/gansynth_generate.py": {
        "tensorflow": {
            "set_verbosity_57": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_112": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_113": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Exists_73": {
                "filename": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.expand_path(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_74": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.expand_path(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/gansynth_train.py": {
        "tensorflow": {
            "set_verbosity_58": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_135": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_136": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reset_default_graph_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Exists_122": {
                "filename": {
                    "value": "flags['train_root_dir']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "MakeDirs_123": {
                "dirname": {
                    "value": "flags['train_root_dir']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "device_93": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(config['ps_tasks'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_97": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "replica_device_setter_93": {
                "ps_tasks": {
                    "value": "config['ps_tasks']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/data_helpers.py": {
        "tensorflow": {
            "zeros_127": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(waves)[0], 768, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_128": {
                "variable": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[pad, waves, pad]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_129": {
                "values": {
                    "value": "[waves, waves]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_58": {
                "name": {
                    "value": "inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_64": {
                "name": {
                    "value": "inputs",
                    "type": "str",
                    "possible_values": []
                }
            },
            "make_initializable_iterator_72": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.dataset.provide_dataset()",
                            "Call"
                        ],
                        [
                            "dataset.shuffle(buffer_size=1000)",
                            "Call"
                        ],
                        [
                            "dataset.map(self._map_fn, num_parallel_calls=4)",
                            "Call"
                        ],
                        [
                            "dataset.batch(batch_size)",
                            "Call"
                        ],
                        [
                            "dataset.prefetch(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_59": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_65": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_73": {
                "name": {
                    "value": "tf.GraphKeys.TABLE_INITIALIZERS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "iterator.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_127": {
                "input": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wave[tf.newaxis, :, :]",
                            "Subscript"
                        ],
                        [
                            "waves[:, :, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([pad, waves, pad], axis=1)",
                            "Call"
                        ],
                        [
                            "wave[tf.newaxis, :, :]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/lib/data_normalizer.py": {
        "tensorflow": {
            "constant_166": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (2.0 / (max_x - min_x))",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_a, p_a])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_a, p_a], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_167": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (-2.0 * min_x / (max_x - min_x) - 1.0)",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_b, p_b])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_b, p_b], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_172": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (2.0 / (max_x - min_x))",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_a, p_a])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_a, p_a], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_173": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (-2.0 * min_x / (max_x - min_x) - 1.0)",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_b, p_b])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_b, p_b], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_205": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (2.0 / (max_x - min_x))",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_a, p_a])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_a, p_a], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_206": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (-2.0 * min_x / (max_x - min_x) - 1.0)",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_b, p_b])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_b, p_b], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_211": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (2.0 / (max_x - min_x))",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_a, p_a])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_a, p_a], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(a, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_212": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "margin * (-2.0 * min_x / (max_x - min_x) - 1.0)",
                            "BinOp"
                        ],
                        [
                            "np.asarray([m_b, p_b])[None, None, None, :]",
                            "Subscript"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "np.concatenate([m_b, p_b], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ],
                        [
                            "tf.constant(b, dtype=x.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Exists_63": {
                "filename": {
                    "value": "self._done_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_140": {
                "t": {
                    "value": "self._a * x + self._b",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clip_by_value_168": {
                "t": {
                    "value": "a * x + b",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "clip_by_value_207": {
                "t": {
                    "value": "a * x + b",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "MonitoredTrainingSession_50": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Exists_75": {
                "filename": {
                    "value": "self._work_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_76": {
                "dirname": {
                    "value": "self._work_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/datasets.py": {
        "tensorflow": {
            "reshape_88": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.multinomial(tf.log([tf.to_float(counts)]), batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_90": {
                "variable": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.multinomial(tf.log([tf.to_float(counts)]), batch_size), [batch_size])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "len(pitches)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "StaticVocabularyTable_100": {
                "variable": {
                    "value": "label_index_table",
                    "type": "variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.lookup.KeyValueTensorInitializer(keys=pitches, values=np.arange(len(pitches)), key_dtype=tf.int64, value_dtype=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_oov_buckets": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_114": {
                "variable": {
                    "value": "one_hot_label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label_index_table.lookup(label)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "len(pitches)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multinomial_89": {
                "logits": {
                    "value": "tf.log([tf.to_float(counts)])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "KeyValueTensorInitializer_101": {
                "keys": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sorted(pitch_counts.keys())",
                            "Call"
                        ],
                        [
                            "sorted(pitch_counts.keys())",
                            "Call"
                        ]
                    ]
                },
                "values": {
                    "value": "np.arange(len(pitches))",
                    "type": "Call",
                    "possible_values": []
                },
                "key_dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value_dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warning_71": {
                "msg": {
                    "value": "\"To train with the NSynth dataset, you must either set the \\tfds_data_dir' hparam to 'gs://tfds-data/datasets' (recommended if running on GCP) or to a local directory where the dataset has been downloaded. You can download the dataset with the command `python -m tensorflow_datasets.scripts.download_and_prepare --datasets=nsynth/gansynth_subset --data_dir=/path/to/local/dir`.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_89": {
                "x": {
                    "value": "[tf.to_float(counts)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_89": {
                "x": {
                    "value": "counts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[pitch_counts[p] for p in pitches]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/lib/layers.py": {
        "tensorflow": {
            "batch_to_space_nd_135": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.tile(images, [scale, 1, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "block_shape": {
                    "value": "[scale]",
                    "type": "List",
                    "possible_values": []
                },
                "crops": {
                    "value": "[[0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_152": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_174": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "random_normal_initializer_226": {
                "variable": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "init_scale",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_228": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "bias_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_322": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "avg_pool_70": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_to_space_nd(tf.tile(images, [scale, 1, 1, 1]), block_shape=[scale], crops=[[0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, scale, scale, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, scale, scale, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "batch_to_space_93": {
                "input": {
                    "value": "tf.tile(images, [scale ** 2, 1, 1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "crops": {
                    "value": "[[0, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "block_size": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(scale)",
                            "Call"
                        ],
                        [
                            "_get_validated_scale(scale)",
                            "Call"
                        ],
                        [
                            "_get_validated_scale(scale)",
                            "Call"
                        ],
                        [
                            "_get_validated_scale(scale)",
                            "Call"
                        ],
                        [
                            "_get_validated_scale(scale)",
                            "Call"
                        ]
                    ]
                }
            },
            "avg_pool_115": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_to_space_nd(tf.tile(images, [scale, 1, 1, 1]), block_shape=[scale], crops=[[0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, scale, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, scale, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_154": {
                "input_tensor": {
                    "value": "tf.sqrt(var + 1e-06)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_175": {
                "values": {
                    "value": "[tensor, tf.ones([shape[i] for i in range(ndims - 1)] + [1]) * scalar]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "ndims - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Print_198": {
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "data": {
                    "value": "[tf.reduce_min(x), tf.reduce_mean(x), tf.reduce_max(x)]",
                    "type": "List",
                    "possible_values": []
                },
                "message": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name + ('\\t' + x.name)",
                            "BinOp"
                        ],
                        [
                            "''",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "rsqrt_42": {
                "x": {
                    "value": "tf.reduce_mean(tf.square(images), axis=3, keepdims=True) + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_94": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_to_space_nd(tf.tile(images, [scale, 1, 1, 1]), block_shape=[scale], crops=[[0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[scale ** 2, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_136": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_to_space_nd(tf.tile(images, [scale, 1, 1, 1]), block_shape=[scale], crops=[[0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[scale, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_154": {
                "x": {
                    "value": "var + 1e-06",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "conv2d_276": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_shape[0:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal_initializer(stddev=init_scale)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_285": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'custom_conv2d'",
                            "Method Argument"
                        ],
                        [
                            "'custom_dense'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dense_325": {
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "kernel_shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal_initializer(stddev=init_scale)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_331": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'custom_conv2d'",
                            "Method Argument"
                        ],
                        [
                            "'custom_dense'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_min_199": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_199": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_199": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.flatten(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_initializer_229": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_43": {
                "input_tensor": {
                    "value": "tf.square(images)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ones_177": {
                "shape": {
                    "value": "[shape[i] for i in range(ndims - 1)] + [1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_43": {
                "x": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.batch_to_space_nd(tf.tile(images, [scale, 1, 1, 1]), block_shape=[scale], crops=[[0, 0]])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/lib/model.py": {
        "tensorflow": {
            "latest_checkpoint_172": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "weights_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, last_stage_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_or_create_global_step_199": {
                "variable": {
                    "value": "current_image_id",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Variable_203": {
                "variable": {
                    "value": "train_time",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_353": {
                "variable": {
                    "value": "generator_ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0.999",
                    "type": "float",
                    "possible_values": []
                }
            },
            "variable_scope_358": {
                "variable": {
                    "value": "load_scope",
                    "type": "variable",
                    "possible_values": []
                },
                "name_or_scope": {
                    "value": "gan_model.generator_scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "custom_getter": {
                    "value": "train_util.make_var_scope_custom_getter_for_ema(generator_ema)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_372": {
                "variable": {
                    "value": "labels_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_373": {
                "variable": {
                    "value": "noises_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, config['latent_vector_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_376": {
                "variable": {
                    "value": "one_hot_labels_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_ph",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, [batch_size])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(pitch_counts)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_416": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_417": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_201": {
                "name": {
                    "value": "current_image_id",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "current_image_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_204": {
                "name": {
                    "value": "train_time",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "train_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(0.0, dtype=tf.float32, trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_243": {
                "name": {
                    "value": "progress",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "progress",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_blocks - 1.0",
                            "BinOp"
                        ],
                        [
                            "networks.compute_progress_from_time(train_time, config['num_resolutions'], num_blocks, stage_times)",
                            "Call"
                        ],
                        [
                            "networks.compute_progress(current_image_id, config['stable_stage_num_images'], config['transition_stage_num_images'], num_blocks)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_287": {
                "variable": {
                    "value": "mag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stfts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sh.melspecgrams_to_stfts(data)",
                            "Call"
                        ],
                        [
                            "sh.specgrams_to_stfts(data)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_288": {
                "variable": {
                    "value": "new_mag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "new_stfts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sh.waves_to_stfts(waves)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_293": {
                "x": {
                    "value": "mag_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_max(mag)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_mag_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_max(new_mag)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_295": {
                "variable": {
                    "value": "mag_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(mag_diff)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_271": {
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits_v2(labels=tf.stop_gradient(target_one_hot_labels), logits=end_points['classification_logits'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_298": {
                "name": {
                    "value": "losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_334": {
                "name": {
                    "value": "fake_ac_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "fake_ac_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_compute_ac_loss(gan_model.generated_data, gen_one_hot_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_335": {
                "name": {
                    "value": "real_ac_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "real_ac_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_compute_ac_loss(gan_model.real_data, real_one_hot_labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_336": {
                "name": {
                    "value": "wx_fake_ac_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "wx_fake_ac_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gen_ac_loss_weight * fake_ac_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_337": {
                "name": {
                    "value": "wx_real_ac_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "wx_real_ac_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dis_ac_loss_weight * real_ac_loss",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_338": {
                "name": {
                    "value": "total_gen_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "gan_loss.generator_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_339": {
                "name": {
                    "value": "total_dis_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "gan_loss.discriminator_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "audio_427": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sh.stfts_to_waves(stfts)",
                            "Call"
                        ],
                        [
                            "self.sess.run(self.fake_waves_ph, feed_dict={self.labels_ph: labels[start:end], self.noises_ph: z[start:end]})",
                            "Call"
                        ]
                    ]
                },
                "sample_rate": {
                    "value": "config['sample_rate']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.config",
                            "Attribute"
                        ]
                    ]
                },
                "max_outputs": {
                    "value": "max_outputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "image_433": {
                "name": {
                    "value": "name + '_m'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "specgrams[:, :, :, 0:1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "max_outputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "image_435": {
                "name": {
                    "value": "name + '_p'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "specgrams[:, :, :, 1:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "max_outputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_152": {
                "name": {
                    "value": "experiment_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'experiment.json')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_269": {
                "name_or_scope": {
                    "value": "gan_model.discriminator_scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_v2_272": {
                "labels": {
                    "value": "tf.stop_gradient(target_one_hot_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "end_points['classification_logits']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_max_290": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "(1, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "square_295": {
                "x": {
                    "value": "mag_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(mag - new_mag) / mag_scale",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_342": {
                "name": {
                    "value": "fake_gl_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "fake_gl_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_compute_gl_consistency_loss(gan_model.generated_data)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_343": {
                "name": {
                    "value": "real_gl_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "real_gl_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_compute_gl_consistency_loss(gan_model.real_data)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_344": {
                "name": {
                    "value": "wx_fake_gl_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "wx_fake_gl_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "fake_gl_loss * gen_gl_consistency_loss_weight",
                            "BinOp"
                        ]
                    ]
                }
            },
            "ListDirectory_163": {
                "dirname": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "path.rstrip('/')",
                            "Call"
                        ],
                        [
                            "util.expand_path(path)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_273": {
                "input": {
                    "value": "target_one_hot_labels",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/network_functions.py": {
        "tensorflow": {
            "concat_38": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_75": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "end_points['last_conv']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_37": {
                "name_or_scope": {
                    "value": "generator_cond",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_74": {
                "name_or_scope": {
                    "value": "discriminator_cond",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/networks.py": {
        "tensorflow": {
            "minimum_160": {
                "variable": {
                    "value": "capped_current_image_id",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "current_image_id",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "min_total_num_images(stable_stage_num_images, transition_stage_num_images, num_blocks) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "floordiv_166": {
                "variable": {
                    "value": "progress_integer",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "capped_current_image_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(current_image_id, min_total_num_images(stable_stage_num_images, transition_stage_num_images, num_blocks) - 1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "stage_num_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stable_stage_num_images + transition_stage_num_images",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_167": {
                "variable": {
                    "value": "progress_fraction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(tf.mod(capped_current_image_id, stage_num_images) - stable_stage_num_images) / tf.to_float(transition_stage_num_images)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "minimum_200": {
                "variable": {
                    "value": "progress",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "progress",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "progress + this_stage_progress",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(progress, max_progress)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_progress",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_blocks - 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "clip_by_value_198": {
                "variable": {
                    "value": "this_stage_progress",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "this_stage_progress",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(train_time - stage_times[i - 1]) / (stage_times[i] - stage_times[i - 1])",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(this_stage_progress, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "maximum_225": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.minimum(progress - (block_id - 2), block_id - progress)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_252": {
                "t": {
                    "value": "block_id - progress",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_n_281": {
                "inputs": {
                    "value": "x_blend",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_n_421": {
                "variable": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "to_float_172": {
                "x": {
                    "value": "progress_integer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.floordiv(capped_current_image_id, stage_num_images)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_226": {
                "x": {
                    "value": "progress - (block_id - 2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "block_id - progress",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_349": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'progressive_gan_generator'",
                            "Method Argument"
                        ],
                        [
                            "'progressive_gan_discriminator'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_483": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'progressive_gan_generator'",
                            "Method Argument"
                        ],
                        [
                            "'progressive_gan_discriminator'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_169": {
                "x": {
                    "value": "tf.mod(capped_current_image_id, stage_num_images) - stable_stage_num_images",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_171": {
                "x": {
                    "value": "transition_stage_num_images",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_350": {
                "name": {
                    "value": "input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_354": {
                "name_or_scope": {
                    "value": "block_name(1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_356": {
                "variable": {
                    "value": "x_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dense_357": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "units": {
                    "value": "start_h * start_w * num_filters_fn(1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_359": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_360": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[x_shape[0], start_h, start_w, num_filters_fn(1)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_362": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_366": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_530": {
                "name_or_scope": {
                    "value": "block_name(1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_533": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.shape(x)[0], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_534": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "units": {
                    "value": "num_filters_fn(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "last_conv",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_536": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.shape(x)[0], 1, 1, num_filters_fn(0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_537": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dense_544": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_379": {
                "name_or_scope": {
                    "value": "block_name(block_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_transpose_381": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_filters_fn(block_id)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(resolution_schedule.scale_base, 1)",
                            "Tuple"
                        ],
                        [
                            "(resolution_schedule.scale_base, resolution_schedule.scale_base)",
                            "Tuple"
                        ],
                        [
                            "(resolution_schedule.scale_base, 1)",
                            "Tuple"
                        ],
                        [
                            "(resolution_schedule.scale_base, resolution_schedule.scale_base)",
                            "Tuple"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_388": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_397": {
                "name_or_scope": {
                    "value": "block_name(block_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_400": {
                "variable": {
                    "value": "lod",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lods[block_id - 1]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv2d(lod, colors, kernel_size=1, padding='SAME', name='to_rgb', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "to_rgb_activation(lod)",
                            "Call"
                        ],
                        [
                            "_to_rgb(lods[block_id - 1])",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(lod, scale)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x0, scale)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(lod, num_filters_fn(block_id), kernel_size=1, padding='SAME', name='from_rgb', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(lod)",
                            "Call"
                        ],
                        [
                            "_from_rgb(lod, block_id)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "colors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "to_rgb",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_489": {
                "name_or_scope": {
                    "value": "block_name(block_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_494": {
                "variable": {
                    "value": "lod",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lods[block_id - 1]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv2d(lod, colors, kernel_size=1, padding='SAME', name='to_rgb', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "to_rgb_activation(lod)",
                            "Call"
                        ],
                        [
                            "_to_rgb(lods[block_id - 1])",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(lod, scale)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x0, scale)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(lod, num_filters_fn(block_id), kernel_size=1, padding='SAME', name='from_rgb', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(lod)",
                            "Call"
                        ],
                        [
                            "_from_rgb(lod, block_id)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_filters_fn(block_id)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "from_rgb",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_501": {
                "variable": {
                    "value": "lod",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "lod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lods[block_id - 1]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv2d(lod, colors, kernel_size=1, padding='SAME', name='to_rgb', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "to_rgb_activation(lod)",
                            "Call"
                        ],
                        [
                            "_to_rgb(lods[block_id - 1])",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(lod, scale)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x0, scale)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(lod, num_filters_fn(block_id), kernel_size=1, padding='SAME', name='from_rgb', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(lod)",
                            "Call"
                        ],
                        [
                            "_from_rgb(lod, block_id)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_512": {
                "name_or_scope": {
                    "value": "block_name(block_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_514": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_filters_fn(block_id - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(resolution_schedule.scale_base, 1)",
                            "Tuple"
                        ],
                        [
                            "(resolution_schedule.scale_base, resolution_schedule.scale_base)",
                            "Tuple"
                        ],
                        [
                            "(resolution_schedule.scale_base, 1)",
                            "Tuple"
                        ],
                        [
                            "(resolution_schedule.scale_base, resolution_schedule.scale_base)",
                            "Tuple"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Method Argument"
                        ],
                        [
                            "3",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "he_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ],
                        [
                            "tf_slim.variance_scaling_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_522": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mod_170": {
                "x1": {
                    "value": "capped_current_image_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(current_image_id, min_total_num_images(stable_stage_num_images, transition_stage_num_images, num_blocks) - 1)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "stage_num_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stable_stage_num_images + transition_stage_num_images",
                            "BinOp"
                        ]
                    ]
                }
            },
            "leaky_relu_332": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_533": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_536": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.flatten(z)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, start_h * start_w * num_filters_fn(1), kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [x_shape[0], start_h, start_w, num_filters_fn(1)])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), 1)",
                            "Call"
                        ],
                        [
                            "layers.pixel_norm(x)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[0] * 2, [start_h - 1] * 2, [start_w - 1] * 2, [0] * 2])",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, (start_h, start_w), num_filters_fn(1), 'VALID')",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(x, num_filters_fn(block_id), kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "resolution_schedule.upscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "layers.scalar_concat(x, layers.minibatch_mean_stddev(x))",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(x, num_filters_fn(block_id - 1), strides=strides, kernel_size=kernel_size, padding='SAME', name='conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(block_id))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, kernel_size, num_filters_fn(block_id - 1))",
                            "Call"
                        ],
                        [
                            "resolution_schedule.downscale(x, resolution_schedule.scale_base)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], -1])",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(x, num_filters_fn(0), name='last_conv', kernel_initializer=he_init)",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [tf.shape(x)[0], 1, 1, num_filters_fn(0)])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "_conv2d('conv0', x, kernel_size, num_filters_fn(1))",
                            "Call"
                        ],
                        [
                            "_conv2d('conv1', x, resolution_schedule.start_resolutions, num_filters_fn(0), 'VALID')",
                            "Call"
                        ],
                        [
                            "alpha * lod + (1.0 - alpha) * x",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/lib/specgrams_helper.py": {
        "tensorflow": {
            "pad_85": {
                "variable": {
                    "value": "waves_padded",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, 0], [self._pad_l, self._pad_r], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_111": {
                "variable": {
                    "value": "stfts",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stfts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.signal.stft(waves_padded[:, :, 0], frame_length=self._nfft, frame_step=self._nhop, fft_length=self._nfft, pad_end=False)[:, :, :, tf.newaxis]",
                            "Subscript"
                        ],
                        [
                            "stfts[:, :, 1:] if self._discard_dc else stfts[:, :, :-1]",
                            "IfExp"
                        ],
                        [
                            "tf.pad(stfts, [[0, 0], [0, 0], [dc, nyq], [0, 0]])",
                            "Call"
                        ],
                        [
                            "stfts[:, :, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [dc, nyq], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "angle_139": {
                "variable": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stfts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.signal.stft(waves_padded[:, :, 0], frame_length=self._nfft, frame_step=self._nhop, fft_length=self._nfft, pad_end=False)[:, :, :, tf.newaxis]",
                            "Subscript"
                        ],
                        [
                            "stfts[:, :, 1:] if self._discard_dc else stfts[:, :, :-1]",
                            "IfExp"
                        ],
                        [
                            "tf.pad(stfts, [[0, 0], [0, 0], [dc, nyq], [0, 0]])",
                            "Call"
                        ],
                        [
                            "stfts[:, :, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "exp_161": {
                "variable": {
                    "value": "mag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logmag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._safe_log(tf.abs(stfts))",
                            "Call"
                        ],
                        [
                            "specgrams[:, :, :, 0]",
                            "Subscript"
                        ],
                        [
                            "specgrams[:, :, :, 0]",
                            "Subscript"
                        ],
                        [
                            "0.5 * self._safe_log(mag2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exp_205": {
                "variable": {
                    "value": "mag2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "2.0 * logmag",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cumsum_206": {
                "variable": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "p * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_float_208": {
                "variable": {
                    "value": "l2mel",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._linear_to_mel_matrix()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_210": {
                "variable": {
                    "value": "mel_phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.angle(stfts)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(p * np.pi, axis=-2)",
                            "Call"
                        ],
                        [
                            "p * np.pi",
                            "BinOp"
                        ],
                        [
                            "tf.cumsum(p * np.pi, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(mel_phase_angle, mel2l, 1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "l2mel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self._linear_to_mel_matrix())",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_233": {
                "variable": {
                    "value": "mel2l",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._mel_to_linear_matrix()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_234": {
                "variable": {
                    "value": "mag2",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.exp(logmelmag2)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "mel2l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self._mel_to_linear_matrix())",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_236": {
                "variable": {
                    "value": "mel_phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mel_p * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tensordot_237": {
                "variable": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "mel_phase_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(phase_angle, l2mel, 1)",
                            "Call"
                        ],
                        [
                            "tf.cumsum(mel_p * np.pi, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "mel2l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self._mel_to_linear_matrix())",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_49": {
                "x": {
                    "value": "x + self._eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_145": {
                "values": {
                    "value": "[logmag[:, :, :, tf.newaxis], p[:, :, :, tf.newaxis]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cumsum_164": {
                "variable": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "p * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_213": {
                "values": {
                    "value": "[logmelmag2[:, :, :, tf.newaxis], mel_p[:, :, :, tf.newaxis]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_240": {
                "values": {
                    "value": "[logmag[:, :, :, tf.newaxis], p[:, :, :, tf.newaxis]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stft_86": {
                "signals": {
                    "value": "waves_padded[:, :, 0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "frame_length": {
                    "value": "self._nfft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "frame_step": {
                    "value": "self._nhop",
                    "type": "Attribute",
                    "possible_values": []
                },
                "fft_length": {
                    "value": "self._nfft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "pad_end": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "inverse_stft_112": {
                "stfts": {
                    "value": "stfts[:, :, :, 0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.signal.stft(waves_padded[:, :, 0], frame_length=self._nfft, frame_step=self._nhop, fft_length=self._nfft, pad_end=False)[:, :, :, tf.newaxis]",
                            "Subscript"
                        ],
                        [
                            "stfts[:, :, 1:] if self._discard_dc else stfts[:, :, :-1]",
                            "IfExp"
                        ],
                        [
                            "tf.pad(stfts, [[0, 0], [0, 0], [dc, nyq], [0, 0]])",
                            "Call"
                        ],
                        [
                            "stfts[:, :, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "frame_length": {
                    "value": "self._nfft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "frame_step": {
                    "value": "self._nhop",
                    "type": "Attribute",
                    "possible_values": []
                },
                "fft_length": {
                    "value": "self._nfft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "window_fn": {
                    "value": "tf.signal.inverse_stft_window_fn(frame_step=self._nhop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_137": {
                "x": {
                    "value": "stfts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.signal.stft(waves_padded[:, :, 0], frame_length=self._nfft, frame_step=self._nhop, fft_length=self._nfft, pad_end=False)[:, :, :, tf.newaxis]",
                            "Subscript"
                        ],
                        [
                            "stfts[:, :, 1:] if self._discard_dc else stfts[:, :, :-1]",
                            "IfExp"
                        ],
                        [
                            "tf.pad(stfts, [[0, 0], [0, 0], [dc, nyq], [0, 0]])",
                            "Call"
                        ],
                        [
                            "stfts[:, :, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tensordot_209": {
                "a": {
                    "value": "mag2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(2.0 * logmag)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(tf.exp(logmelmag2), mel2l, 1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "l2mel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self._linear_to_mel_matrix())",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_234": {
                "x": {
                    "value": "logmelmag2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._safe_log(tf.tensordot(mag2, l2mel, 1))",
                            "Call"
                        ],
                        [
                            "melspecgrams[:, :, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "inverse_stft_window_fn_117": {
                "frame_step": {
                    "value": "self._nhop",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/specgrams_helper_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "convert_to_tensor_42": {
                "variable": {
                    "value": "self.audio",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.audio_np",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "main_94": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_data_files_path_34": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "convert_to_tensor_79": {
                "value": {
                    "value": "spectra_np",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sess.run(transform(self.audio))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/gansynth/lib/spectral_ops.py": {
        "tensorflow": {
            "slice_166": {
                "variable": {
                    "value": "slice_front",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "begin_front",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0 for unused_s in range(len(shape))]",
                            "ListComp"
                        ]
                    ]
                },
                "size": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.as_list()",
                            "Call"
                        ],
                        [
                            "phase_angle.get_shape().as_list()",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_167": {
                "variable": {
                    "value": "slice_back",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "begin_back",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0 for unused_s in range(len(shape))]",
                            "ListComp"
                        ]
                    ]
                },
                "size": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.as_list()",
                            "Call"
                        ],
                        [
                            "phase_angle.get_shape().as_list()",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_185": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(ddmod, -np.pi)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.greater(dd, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_186": {
                "variable": {
                    "value": "ddmod",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.equal(ddmod, -np.pi), tf.greater(dd, 0))",
                            "Call"
                        ],
                        [
                            "tf.less(tf.abs(dd), discont)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(ddmod) * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "ddmod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.mod(dd + np.pi, 2.0 * np.pi) - np.pi",
                            "BinOp"
                        ],
                        [
                            "tf.where(idx, tf.ones_like(ddmod) * np.pi, ddmod)",
                            "Call"
                        ],
                        [
                            "tf.where(idx, tf.zeros_like(ddmod), dd)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_188": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.abs(dd)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "discont",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.pi",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "where_189": {
                "variable": {
                    "value": "ddmod",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.equal(ddmod, -np.pi), tf.greater(dd, 0))",
                            "Call"
                        ],
                        [
                            "tf.less(tf.abs(dd), discont)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.zeros_like(ddmod)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "dd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff(p, axis=axis)",
                            "Call"
                        ]
                    ]
                }
            },
            "cumsum_190": {
                "variable": {
                    "value": "ph_cumsum",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ph_correct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ddmod - dd",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "Method Argument"
                        ],
                        [
                            "-1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_194": {
                "variable": {
                    "value": "ph_cumsum",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros(shape, dtype=p.dtype), ph_cumsum]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "Method Argument"
                        ],
                        [
                            "-1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "slice_227": {
                "variable": {
                    "value": "phase_slice",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "begin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0 for unused_s in size]",
                            "ListComp"
                        ]
                    ]
                },
                "size": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.as_list()",
                            "Call"
                        ],
                        [
                            "phase_angle.get_shape().as_list()",
                            "Call"
                        ]
                    ]
                }
            },
            "complex_234": {
                "variable": {
                    "value": "mag",
                    "type": "variable",
                    "possible_values": []
                },
                "real": {
                    "value": "mag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.complex(mag, tf.convert_to_tensor(0.0, dtype=mag.dtype))",
                            "Call"
                        ]
                    ]
                },
                "imag": {
                    "value": "tf.convert_to_tensor(0.0, dtype=mag.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "complex_235": {
                "variable": {
                    "value": "phase",
                    "type": "variable",
                    "possible_values": []
                },
                "real": {
                    "value": "tf.cos(phase_angle)",
                    "type": "Call",
                    "possible_values": []
                },
                "imag": {
                    "value": "tf.sin(phase_angle)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_254": {
                "variable": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(waves)",
                            "Call"
                        ],
                        [
                            "tf.pad(waves, [[0, 0], [left_pad, right_pad], [0, 0]])",
                            "Call"
                        ],
                        [
                            "waves[:, :length, :]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(waves, [1, 1, num_repeats])[:, :, :channels]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_256": {
                "variable": {
                    "value": "waves_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(waves)",
                            "Call"
                        ],
                        [
                            "tf.pad(waves, [[0, 0], [left_pad, right_pad], [0, 0]])",
                            "Call"
                        ],
                        [
                            "waves[:, :length, :]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(waves, [1, 1, num_repeats])[:, :, :channels]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "maximum_259": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "length - waves_shape[1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_int32_260": {
                "variable": {
                    "value": "right_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.to_float(pad) / 2.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pad_262": {
                "variable": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(waves)",
                            "Call"
                        ],
                        [
                            "tf.pad(waves, [[0, 0], [left_pad, right_pad], [0, 0]])",
                            "Call"
                        ],
                        [
                            "waves[:, :length, :]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(waves, [1, 1, num_repeats])[:, :, :channels]",
                            "Subscript"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [left_pad, right_pad], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_266": {
                "variable": {
                    "value": "num_repeats",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ceil(tf.to_float(channels) / tf.to_float(waves_shape[2]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_220": {
                "variable": {
                    "value": "dphase",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "dphase > np.pi",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "dphase - 2 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "dphase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff(phase_unwrapped, axis=time_axis)",
                            "Call"
                        ],
                        [
                            "diff(phase_angle, axis=time_axis)",
                            "Call"
                        ],
                        [
                            "tf.where(dphase > np.pi, dphase - 2 * np.pi, dphase)",
                            "Call"
                        ],
                        [
                            "tf.where(dphase < -np.pi, dphase + 2 * np.pi, dphase)",
                            "Call"
                        ],
                        [
                            "tf.concat([phase_slice, dphase], axis=time_axis) / np.pi",
                            "BinOp"
                        ]
                    ]
                }
            },
            "where_221": {
                "variable": {
                    "value": "dphase",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "dphase < -np.pi",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "dphase + 2 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "dphase",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff(phase_unwrapped, axis=time_axis)",
                            "Call"
                        ],
                        [
                            "diff(phase_angle, axis=time_axis)",
                            "Call"
                        ],
                        [
                            "tf.where(dphase > np.pi, dphase - 2 * np.pi, dphase)",
                            "Call"
                        ],
                        [
                            "tf.where(dphase < -np.pi, dphase + 2 * np.pi, dphase)",
                            "Call"
                        ],
                        [
                            "tf.concat([phase_slice, dphase], axis=time_axis) / np.pi",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mod_184": {
                "x1": {
                    "value": "dd + np.pi",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "2.0 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_185": {
                "x": {
                    "value": "ddmod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.mod(dd + np.pi, 2.0 * np.pi) - np.pi",
                            "BinOp"
                        ],
                        [
                            "tf.where(idx, tf.ones_like(ddmod) * np.pi, ddmod)",
                            "Call"
                        ],
                        [
                            "tf.where(idx, tf.zeros_like(ddmod), dd)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-np.pi",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_185": {
                "x": {
                    "value": "dd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff(p, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "abs_188": {
                "x": {
                    "value": "dd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "diff(p, axis=axis)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_189": {
                "input": {
                    "value": "ddmod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.mod(dd + np.pi, 2.0 * np.pi) - np.pi",
                            "BinOp"
                        ],
                        [
                            "tf.where(idx, tf.ones_like(ddmod) * np.pi, ddmod)",
                            "Call"
                        ],
                        [
                            "tf.where(idx, tf.zeros_like(ddmod), dd)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_228": {
                "values": {
                    "value": "[phase_slice, dphase]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "time_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-2",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_234": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "mag.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cos_235": {
                "x": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sin_235": {
                "x": {
                    "value": "phase_angle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ceil_267": {
                "x": {
                    "value": "tf.to_float(channels) / tf.to_float(waves_shape[2])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_268": {
                "input": {
                    "value": "waves",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(waves)",
                            "Call"
                        ],
                        [
                            "tf.pad(waves, [[0, 0], [left_pad, right_pad], [0, 0]])",
                            "Call"
                        ],
                        [
                            "waves[:, :length, :]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(waves, [1, 1, num_repeats])[:, :, :channels]",
                            "Subscript"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_repeats]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_186": {
                "input": {
                    "value": "ddmod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.mod(dd + np.pi, 2.0 * np.pi) - np.pi",
                            "BinOp"
                        ],
                        [
                            "tf.where(idx, tf.ones_like(ddmod) * np.pi, ddmod)",
                            "Call"
                        ],
                        [
                            "tf.where(idx, tf.zeros_like(ddmod), dd)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_194": {
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.get_shape()",
                            "Call"
                        ],
                        [
                            "p.get_shape().as_list()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "p.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_260": {
                "x": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(0, length - waves_shape[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_267": {
                "x": {
                    "value": "waves_shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/spectral_ops_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "convert_to_tensor_58": {
                "variable": {
                    "value": "x_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x_np",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.randn(*shape)",
                            "Call"
                        ],
                        [
                            "5 * np.random.randn(*shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "convert_to_tensor_72": {
                "variable": {
                    "value": "x_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x_np",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.randn(*shape)",
                            "Call"
                        ],
                        [
                            "5 * np.random.randn(*shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "convert_to_tensor_86": {
                "variable": {
                    "value": "mag_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mag_np",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10 * np.random.rand(*shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "convert_to_tensor_87": {
                "variable": {
                    "value": "phase_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "phase_np",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.pi * (2 * np.random.rand(*shape) - 1)",
                            "BinOp"
                        ],
                        [
                            "np.pi * (2 * np.random.rand(*shape) - 1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "convert_to_tensor_108": {
                "variable": {
                    "value": "phase_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "phase_np",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.pi * (2 * np.random.rand(*shape) - 1)",
                            "BinOp"
                        ],
                        [
                            "np.pi * (2 * np.random.rand(*shape) - 1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "main_115": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/train_util.py": {
        "tensorflow": {
            "reduce_mean_206": {
                "variable": {
                    "value": "real_score_penalty",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(gan_model.discriminator_real_outputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "latest_checkpoint_367": {
                "variable": {
                    "value": "curr_ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "make_train_sub_dir(stage_id, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_394": {
                "variable": {
                    "value": "saver_for_restore",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "restore_var_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[var for var in tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES) if var not in set(optimizer_var_list + new_block_var_list)]",
                            "ListComp"
                        ]
                    ]
                },
                "allow_empty": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "global_variables_initializer_397": {
                "variable": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reshape_171": {
                "variable": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.to_float(tf.range(num_columns)) / (num_columns - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_175": {
                "values": {
                    "value": "ans",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scalar_208": {
                "name": {
                    "value": "real_score_penalty",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "real_score_penalty",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.square(gan_model.discriminator_real_outputs))",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_234": {
                "variable": {
                    "value": "gen_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "kwargs['generator_learning_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "beta1": {
                    "value": "beta1",
                    "type": "variable",
                    "possible_values": []
                },
                "beta2": {
                    "value": "beta2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "AdamOptimizer_236": {
                "variable": {
                    "value": "dis_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "kwargs['discriminator_learning_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "beta1": {
                    "value": "beta1",
                    "type": "variable",
                    "possible_values": []
                },
                "beta2": {
                    "value": "beta2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "image_311": {
                "name": {
                    "value": "fake_images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tfgan.eval.eval_utils.image_grid(fake_images, grid_shape=[fake_grid_size] * 2, image_shape=image_shape, num_channels=colors)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_320": {
                "name": {
                    "value": "interp_images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tfgan.eval.eval_utils.image_grid(interp_images, grid_shape=[interp_grid_size] * 2, image_shape=image_shape, num_channels=colors)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_330": {
                "name": {
                    "value": "real_images_blend",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tfgan.eval.eval_utils.image_grid(model.gan_model.real_data[:real_grid_size ** 2], grid_shape=(real_grid_size, real_grid_size), image_shape=image_shape, num_channels=colors)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "latest_checkpoint_369": {
                "variable": {
                    "value": "prev_ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "make_train_sub_dir(stage_id - 1, **kwargs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Scaffold_408": {
                "init_op": {
                    "value": "tf.constant([])",
                    "type": "Call",
                    "possible_values": []
                },
                "init_fn": {
                    "value": "_init_fn",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "placeholder_452": {
                "variable": {
                    "value": "self._increment_amount",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "assign_add_453": {
                "variable": {
                    "value": "self._increment_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ref": {
                    "value": "train_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "vals.results[0]",
                            "Subscript"
                        ]
                    ]
                },
                "value": {
                    "value": "self._increment_amount",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_207": {
                "x": {
                    "value": "gan_model.discriminator_real_outputs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_232": {
                "name_or_scope": {
                    "value": "progressive_gan_train_ops",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_239": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "var_scope.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_245": {
                "control_inputs": {
                    "value": "[gan_train_ops.generator_train_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_298": {
                "name_or_scope": {
                    "value": "model.gan_model.generator_scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "custom_getter": {
                    "value": "make_var_scope_custom_getter_for_ema(model.generator_ema)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "SessionRunArgs_431": {
                "fetches": {
                    "value": "self._fetches",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LoggingTensorHook_498": {
                "tensors": {
                    "value": "[make_status_message(model)]",
                    "type": "List",
                    "possible_values": []
                },
                "every_n_iter": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ListDirectory_56": {
                "dirname": {
                    "value": "kwargs['train_root_dir']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_408": {
                "value": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "as_string_416": {
                "input": {
                    "value": "model.current_image_id",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_string_417": {
                "input": {
                    "value": "model.progress",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_428": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "SessionRunArgs_459": {
                "fetches": {
                    "value": "[self._train_time, self._increment_op]",
                    "type": "List",
                    "possible_values": []
                },
                "feed_dict": {
                    "value": "{self._increment_amount: self._last_run_duration}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "SessionRunArgs_463": {
                "fetches": {
                    "value": "[self._train_time]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "StopAtStepHook_497": {
                "last_step": {
                    "value": "model.num_images",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_172": {
                "x": {
                    "value": "tf.range(num_columns)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_381": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "'.*/{}/'.format(networks.block_name(block_id))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_388": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_174": {
                "values": {
                    "value": "[dz] * num_columns",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/gansynth/lib/util.py": {
        "tensorflow": {
            "argmax_33": {
                "variable": {
                    "value": "label_id",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "one_hot",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_36": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "one_hot_embedding",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_tokens, embedding_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_44": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(num_tokens)] * num_repeats",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "embedding_lookup_38": {
                "params": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('one_hot_embedding', [num_tokens, embedding_size], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "label_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(one_hot, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "token_to_embedding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_46": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(num_tokens)] * num_repeats)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(indices), [-1])[0:num]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_tokens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(one_hot.shape[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_51": {
                "indices": {
                    "value": "tf.random_uniform(shape=(num,), maxval=num_tokens, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_tokens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(one_hot.shape[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "Exists_58": {
                "filename": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_45": {
                "tensor": {
                    "value": "tf.transpose(indices)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_45": {
                "a": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.range(num_tokens)] * num_repeats)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.transpose(indices), [-1])[0:num]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "global_variables_initializer_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_initializer_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "tables_initializer_80": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/image_stylization_convert_tflite.py": {
        "tensorflow": {
            "Saver_41": {
                "variable": {
                    "value": "model_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "IsDirectory_43": {
                "dirname": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(checkpoint)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_44": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(checkpoint)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_55": {
                "variable": {
                    "value": "input_image_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, None, None, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "input_image",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_57": {
                "variable": {
                    "value": "weights_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "num_styles",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "style_weights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "isdir_92": {
                "path": {
                    "value": "output_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_model, filename)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_115": {
                "msg": {
                    "value": "'Converted to TF Lite model: %s; Size: %d KB.' % (output_model, len(tflite_model) / 1024)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "set_verbosity_120": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_132": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_133": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_41": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_45": {
                "msg": {
                    "value": "'loading latest checkpoint file: {}'.format(checkpoint)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "simple_save_76": {
                "session": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "export_dir": {
                    "value": "saved_model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tempfile.mkdtemp()",
                            "Call"
                        ],
                        [
                            "_export_to_saved_model(os.path.expanduser(FLAGS.checkpoint), FLAGS.alpha, FLAGS.num_styles)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "{input_image_tensor.name: input_image_tensor, weights_tensor.name: weights_tensor}",
                    "type": "Dict",
                    "possible_values": []
                },
                "outputs": {
                    "value": "{'stylized_image': stylized_image_tensor}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "GFile_113": {
                "name": {
                    "value": "output_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_model, filename)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/image_stylization_create_dataset.py": {
        "tensorflow": {
            "Glob_40": {
                "variable": {
                    "value": "style_files",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "style_files",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gfile.Glob(style_files)",
                            "Call"
                        ],
                        [
                            "_parse_style_files(os.path.expanduser(FLAGS.style_files))",
                            "Call"
                        ]
                    ]
                }
            },
            "Feature_48": {
                "float_list": {
                    "value": "tf.train.FloatList(value=value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_53": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=[value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_58": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_62": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_91": {
                "msg": {
                    "value": "'Output TFRecord file is saved at %s' % os.path.expanduser(FLAGS.output_file)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_96": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_97": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TFRecordWriter_64": {
                "path": {
                    "value": "os.path.expanduser(FLAGS.output_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Example_89": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature=feature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FloatList_48": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Int64List_53": {
                "value": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_58": {
                "value": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "info_67": {
                "msg": {
                    "value": "'Processing style file %s: %s' % (style_label, style_file)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Graph_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Features_89": {
                "feature": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'label': _int64_feature(style_label)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "expand_dims_80": {
                "input": {
                    "value": "tf.to_float(style_image)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_80": {
                "x": {
                    "value": "style_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image_utils.load_np_image(style_file)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/image_stylization/image_stylization_evaluate.py": {
        "tensorflow": {
            "unstack_84": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unstack(labels)",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_194": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_195": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_62": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_102": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_116": {
                "variable": {
                    "value": "style_row",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones([1, FLAGS.image_size, FLAGS.image_size, 3]), style_images]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_113": {
                "values": {
                    "value": "[inputs] + stylized_inputs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_127": {
                "variable": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[style_row, stylized_training_example, stylized_noise] + stylized_evaluation_images + stylized_style_images",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_132": {
                "variable": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[style_row, stylized_training_example, stylized_noise] + stylized_evaluation_images",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_145": {
                "name": {
                    "value": "Style Grid",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.cast(image_utils.form_image_grid(grid, grid_shape, [FLAGS.image_size, FLAGS.image_size], 3) * 255.0, tf.uint8)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_175": {
                "variable": {
                    "value": "summary_op",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Print_176": {
                "variable": {
                    "value": "print_op",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "summary_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.summary.scalar(name, value, [])",
                            "Call"
                        ]
                    ]
                },
                "data": {
                    "value": "[value]",
                    "type": "List",
                    "possible_values": []
                },
                "message": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_88": {
                "input": {
                    "value": "style_label",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_147": {
                "x": {
                    "value": "image_utils.form_image_grid(grid, grid_shape, [FLAGS.image_size, FLAGS.image_size], 3) * 255.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_to_collection_177": {
                "name": {
                    "value": "tf.GraphKeys.SUMMARIES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "print_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Print(summary_op, [value], name)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_117": {
                "shape": {
                    "value": "[1, FLAGS.image_size, FLAGS.image_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "unstack_121": {
                "value": {
                    "value": "evaluation_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image_utils.load_evaluation_images(FLAGS.image_size)",
                            "Call"
                        ]
                    ]
                }
            },
            "unstack_125": {
                "value": {
                    "value": "style_images",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/image_stylization_finetune.py": {
        "tensorflow": {
            "disable_v2_behavior_156": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_157": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "gather_97": {
                "variable": {
                    "value": "style_coefficient",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.constant(style_coefficients)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "style_labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "AdamOptimizer_138": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "FLAGS.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_72": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks, worker_device=device)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_83": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "replica_device_setter_72": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "worker_device": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/cpu:0' if not FLAGS.ps_tasks else '/job:worker/cpu:0'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "replica_device_setter_83": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_98": {
                "value": {
                    "value": "style_coefficients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1.0 for _ in range(num_styles)]",
                            "ListComp"
                        ],
                        [
                            "ast.literal_eval(FLAGS.style_coefficients)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_118": {
                "name": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/image_stylization_train.py": {
        "tensorflow": {
            "disable_v2_behavior_145": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_146": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_62": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "gather_94": {
                "variable": {
                    "value": "style_coefficient",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.constant(style_coefficients)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "style_labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "AdamOptimizer_123": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "FLAGS.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_66": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks, worker_device=device)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_80": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(FLAGS.ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_118": {
                "name": {
                    "value": "image/0_inputs",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_119": {
                "name": {
                    "value": "image/1_styles",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "style_images",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_120": {
                "name": {
                    "value": "image/2_styled_inputs",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "stylized_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.transform(inputs, alpha=FLAGS.alpha, normalizer_params={'labels': style_labels, 'num_categories': num_styles, 'center': True, 'scale': True})",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "replica_device_setter_66": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "worker_device": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/cpu:0' if not FLAGS.ps_tasks else '/job:worker/cpu:0'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "replica_device_setter_80": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_95": {
                "value": {
                    "value": "style_coefficients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1.0 for _ in range(num_styles)]",
                            "ListComp"
                        ],
                        [
                            "ast.literal_eval(FLAGS.style_coefficients)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_115": {
                "name": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/image_stylization_transform.py": {
        "tensorflow": {
            "Saver_46": {
                "variable": {
                    "value": "model_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "IsDirectory_48": {
                "dirname": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(checkpoint)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_49": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(checkpoint)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint)",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_142": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_143": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_46": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_50": {
                "msg": {
                    "value": "'loading latest checkpoint file: {}'.format(checkpoint)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_80": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_80": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_82": {
                "values": {
                    "value": "[input_image for _ in range(len(which_styles))]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_85": {
                "value": {
                    "value": "which_styles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ast.literal_eval(FLAGS.which_styles)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_108": {
                "value": {
                    "value": "mixture",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([num_styles], dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "_style_mixture(which_styles, FLAGS.num_styles)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/image_stylization/image_utils.py": {
        "tensorflow": {
            "GFile_417": {
                "variable": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_434": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.uint8(load_np_image(image_file) * 255.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Glob_460": {
                "variable": {
                    "value": "evaluation_images",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "glob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), _EVALUATION_IMAGES_GLOB)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_504": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "grid_shape + image_shape + [num_channels]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_506": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_507": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[grid_shape[0], width, image_shape[0], num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_509": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_510": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, height, width, num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_538": {
                "variable": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Assert_540": {
                "variable": {
                    "value": "rank_assertion",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(tf.rank(image), 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "['Rank of image must be equal to 3.']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Assert_546": {
                "variable": {
                    "value": "size_assertion",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.logical_and(tf.greater_equal(original_shape[0], crop_height), tf.greater_equal(original_shape[1], crop_width))",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "['Crop size greater than the image size.']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_552": {
                "variable": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.stack([offset_height, offset_width, 0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_603": {
                "variable": {
                    "value": "smallest_side",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "smallest_side",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(smallest_side, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.to_float(smallest_side)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(smallest_side, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_605": {
                "variable": {
                    "value": "height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(height)",
                            "Call"
                        ],
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_float_606": {
                "variable": {
                    "value": "width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(width)",
                            "Call"
                        ],
                        [
                            "shape[2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_float_607": {
                "variable": {
                    "value": "smallest_side",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "smallest_side",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(smallest_side, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.to_float(smallest_side)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(smallest_side, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_609": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.greater(height, width)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : smallest_side / width",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : smallest_side / height",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "to_int32_612": {
                "variable": {
                    "value": "new_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "height * scale",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_int32_613": {
                "variable": {
                    "value": "new_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "width * scale",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_628": {
                "variable": {
                    "value": "smallest_side",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "smallest_side",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(smallest_side, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.to_float(smallest_side)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(smallest_side, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_634": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "resize_bilinear_638": {
                "variable": {
                    "value": "resized_image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "size": {
                    "value": "[new_height, new_width]",
                    "type": "List",
                    "possible_values": []
                },
                "align_corners": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "VarLenFeature_692": {
                "variable": {
                    "value": "sparse_float32",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "parse_single_example_700": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_serialized",
                    "type": "variable",
                    "possible_values": [
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ],
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ],
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ]
                    ]
                },
                "features": {
                    "value": "feature_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'image/encoded': tf.FixedLenFeature([], dtype=tf.string, default_value=''), 'image/class/label': tf.FixedLenFeature([1], dtype=tf.int64, default_value=-1), 'image/class/text': tf.FixedLenFeature([], dtype=tf.string, default_value='')}",
                            "Dict"
                        ]
                    ]
                }
            },
            "cast_701": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "features['image/class/label']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_703": {
                "variable": {
                    "value": "xmin",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features['image/object/bbox/xmin'].values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_704": {
                "variable": {
                    "value": "ymin",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features['image/object/bbox/ymin'].values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_705": {
                "variable": {
                    "value": "xmax",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features['image/object/bbox/xmax'].values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_706": {
                "variable": {
                    "value": "ymax",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features['image/object/bbox/ymax'].values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_709": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ymin, xmin, ymax, xmax]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_713": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([ymin, xmin, ymax, xmax], 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bbox, 0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(bbox, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_714": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([ymin, xmin, ymax, xmax], 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bbox, 0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(bbox, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_731": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "minimum_732": {
                "variable": {
                    "value": "small_side",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "string_input_producer_62": {
                "variable": {
                    "value": "filename_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "string_tensor": {
                    "value": "data_files",
                    "type": "variable",
                    "possible_values": [
                        [
                            "imagenet.data_files()",
                            "Call"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "capacity": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                }
            },
            "RandomShuffleQueue_82": {
                "variable": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "min_queue_examples + 3 * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "min_queue_examples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "examples_per_shard * input_queue_memory_factor",
                            "BinOp"
                        ]
                    ]
                },
                "dtypes": {
                    "value": "[tf.string]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_join_114": {
                "variable": {
                    "value": "(images, label_index_batch)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors_list": {
                    "value": "images_and_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "capacity": {
                    "value": "2 * num_preprocess_threads * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_119": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(images, shape=[batch_size, image_size, image_size, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, image_size, image_size, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "string_input_producer_166": {
                "variable": {
                    "value": "filename_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "string_tensor": {
                    "value": "[style_dataset_file]",
                    "type": "List",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "capacity": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "filename_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TFRecordReader_178": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parse_single_example_184": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_serialized",
                    "type": "variable",
                    "possible_values": [
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ],
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ],
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ]
                    ]
                },
                "features": {
                    "value": "{'label': tf.FixedLenFeature([], tf.int64), 'image_raw': tf.FixedLenFeature([], tf.string), 'vgg_16/conv1': tf.FixedLenFeature([64, 64], tf.float32), 'vgg_16/pool1': tf.FixedLenFeature([64, 64], tf.float32), 'vgg_16/conv2': tf.FixedLenFeature([128, 128], tf.float32), 'vgg_16/pool2': tf.FixedLenFeature([128, 128], tf.float32), 'vgg_16/conv3': tf.FixedLenFeature([256, 256], tf.float32), 'vgg_16/pool3': tf.FixedLenFeature([256, 256], tf.float32), 'vgg_16/conv4': tf.FixedLenFeature([512, 512], tf.float32), 'vgg_16/pool4': tf.FixedLenFeature([512, 512], tf.float32), 'vgg_16/conv5': tf.FixedLenFeature([512, 512], tf.float32), 'vgg_16/pool5': tf.FixedLenFeature([512, 512], tf.float32)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "decode_jpeg_198": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "features['image_raw']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_443": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_463": {
                "values": {
                    "value": "[load_image(path, image_size) for path in evaluation_images]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_544": {
                "variable": {
                    "value": "cropped_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[crop_height, crop_width, original_shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "strided_slice_557": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "begin": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.stack([offset_height, offset_width, 0]))",
                            "Call"
                        ]
                    ]
                },
                "end": {
                    "value": "offsets + cropped_shape",
                    "type": "BinOp",
                    "possible_values": []
                },
                "strides": {
                    "value": "tf.ones_like(offsets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_559": {
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "cropped_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([crop_height, crop_width, original_shape[2]])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_632": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_641": {
                "variable": {
                    "value": "resized_image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "resized_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.resize_bilinear(image, [new_height, new_width], align_corners=False)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(resized_image)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_738": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_755": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_56": {
                "name": {
                    "value": "batch_processing",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_queue_runner_94": {
                "qr": {
                    "value": "tf.train.queue_runner.QueueRunner(examples_queue, enqueue_ops)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "decode_jpeg_103": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_buffer",
                    "type": "variable",
                    "possible_values": []
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_122": {
                "name": {
                    "value": "images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(images, shape=[batch_size, image_size, image_size, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_165": {
                "name": {
                    "value": "style_image_processing",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RandomShuffleQueue_170": {
                "variable": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "[tf.string]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "random_examples_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FIFOQueue_175": {
                "variable": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "[tf.string]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "fifo_examples_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_queue_runner_181": {
                "qr": {
                    "value": "tf.train.queue_runner.QueueRunner(examples_queue, enqueue_ops)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_214": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_216": {
                "variable": {
                    "value": "image_label_gram_matrices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[image, label] + gram_matrices",
                    "type": "BinOp",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "name_scope_284": {
                "name": {
                    "value": "style_image_processing",
                    "type": "str",
                    "possible_values": []
                }
            },
            "string_input_producer_288": {
                "variable": {
                    "value": "filename_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "string_tensor": {
                    "value": "[style_dataset_file]",
                    "type": "List",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "capacity": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "filename_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TFRecordReader_302": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parse_single_example_308": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_serialized",
                    "type": "variable",
                    "possible_values": [
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ],
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ],
                        [
                            "examples_queue.dequeue()",
                            "Call"
                        ]
                    ]
                },
                "features": {
                    "value": "{'label': tf.FixedLenFeature([], tf.int64), 'image_raw': tf.FixedLenFeature([], tf.string)}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "decode_jpeg_314": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "features['image_raw']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_float_441": {
                "x": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_data_files_path_458": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "equal_541": {
                "x": {
                    "value": "tf.rank(image)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_543": {
                "control_inputs": {
                    "value": "[rank_assertion]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "logical_and_547": {
                "x": {
                    "value": "tf.greater_equal(original_shape[0], crop_height)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.greater_equal(original_shape[1], crop_width)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_552": {
                "values": {
                    "value": "[offset_height, offset_width, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_556": {
                "control_inputs": {
                    "value": "[size_assertion]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_609": {
                "x": {
                    "value": "height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(height)",
                            "Call"
                        ],
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(width)",
                            "Call"
                        ],
                        [
                            "shape[2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "FixedLenFeature_685": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FixedLenFeature_687": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "FixedLenFeature_689": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_float_734": {
                "x": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_736": {
                "value": {
                    "value": "[image_size, image_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_753": {
                "x": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "QueueRunner_95": {
                "queue": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.RandomShuffleQueue(capacity=min_queue_examples + 3 * batch_size, min_after_dequeue=min_queue_examples, dtypes=[tf.string])",
                            "Call"
                        ],
                        [
                            "tf.RandomShuffleQueue(capacity=64, min_after_dequeue=32, dtypes=[tf.string], name='random_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.FIFOQueue(capacity=64, dtypes=[tf.string], name='fifo_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.RandomShuffleQueue(capacity=64, min_after_dequeue=32, dtypes=[tf.string], name='random_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.FIFOQueue(capacity=64, dtypes=[tf.string], name='fifo_examples_queue')",
                            "Call"
                        ]
                    ]
                },
                "enqueue_ops": {
                    "value": "enqueue_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[examples_queue.enqueue([value])]",
                            "List"
                        ],
                        [
                            "[examples_queue.enqueue([value])]",
                            "List"
                        ]
                    ]
                }
            },
            "reshape_124": {
                "tensor": {
                    "value": "label_index_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "QueueRunner_182": {
                "queue": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.RandomShuffleQueue(capacity=min_queue_examples + 3 * batch_size, min_after_dequeue=min_queue_examples, dtypes=[tf.string])",
                            "Call"
                        ],
                        [
                            "tf.RandomShuffleQueue(capacity=64, min_after_dequeue=32, dtypes=[tf.string], name='random_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.FIFOQueue(capacity=64, dtypes=[tf.string], name='fifo_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.RandomShuffleQueue(capacity=64, min_after_dequeue=32, dtypes=[tf.string], name='random_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.FIFOQueue(capacity=64, dtypes=[tf.string], name='fifo_examples_queue')",
                            "Call"
                        ]
                    ]
                },
                "enqueue_ops": {
                    "value": "enqueue_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[examples_queue.enqueue([value])]",
                            "List"
                        ],
                        [
                            "[examples_queue.enqueue([value])]",
                            "List"
                        ]
                    ]
                }
            },
            "to_float_211": {
                "x": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "device_287": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RandomShuffleQueue_294": {
                "variable": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "[tf.string]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "random_examples_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FIFOQueue_300": {
                "variable": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "[tf.string]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "fifo_examples_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_queue_runner_305": {
                "qr": {
                    "value": "tf.train.queue_runner.QueueRunner(examples_queue, enqueue_ops)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_353": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "batch_355": {
                "variable": {
                    "value": "[image, image_orig, label]",
                    "type": "List",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[image, image_orig, label]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GFile_395": {
                "name": {
                    "value": "image_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "rank_541": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "greater_equal_548": {
                "x": {
                    "value": "original_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "greater_equal_549": {
                "x": {
                    "value": "original_shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_576": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_577": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_float_110": {
                "x": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "QueueRunner_306": {
                "queue": {
                    "value": "examples_queue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.RandomShuffleQueue(capacity=min_queue_examples + 3 * batch_size, min_after_dequeue=min_queue_examples, dtypes=[tf.string])",
                            "Call"
                        ],
                        [
                            "tf.RandomShuffleQueue(capacity=64, min_after_dequeue=32, dtypes=[tf.string], name='random_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.FIFOQueue(capacity=64, dtypes=[tf.string], name='fifo_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.RandomShuffleQueue(capacity=64, min_after_dequeue=32, dtypes=[tf.string], name='random_examples_queue')",
                            "Call"
                        ],
                        [
                            "tf.FIFOQueue(capacity=64, dtypes=[tf.string], name='fifo_examples_queue')",
                            "Call"
                        ]
                    ]
                },
                "enqueue_ops": {
                    "value": "enqueue_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[examples_queue.enqueue([value])]",
                            "List"
                        ],
                        [
                            "[examples_queue.enqueue([value])]",
                            "List"
                        ]
                    ]
                }
            },
            "random_brightness_322": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_saturation_323": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "lower": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "upper": {
                    "value": "1.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_hue_324": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_flip_left_right_325": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "random_flip_up_down_326": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "random_crop_333": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                },
                "size": {
                    "value": "[image_size, image_size, image_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_349": {
                "x": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_jpeg(image_buffer, channels=3)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(features['image_raw'])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.random_brightness(image, max_delta=0.8)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(image, lower=0.5, upper=1.5)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(image, max_delta=0.2)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_up_down(image)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, random_larger_image_size)",
                            "Call"
                        ],
                        [
                            "tf.random_crop(image, size=[image_size, image_size, image_channels])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, tf.random_uniform([], minval=min_rand_image_size, maxval=max_rand_image_size, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "skimage.io.imread(f.name)",
                            "Call"
                        ],
                        [
                            "np.tile(image[:, :, None], (1, 1, 3))",
                            "Call"
                        ],
                        [
                            "np.uint8(image * 255.0)",
                            "Call"
                        ],
                        [
                            "tf.constant(np.uint8(load_np_image(image_file) * 255.0))",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_images(image, [image_size, image_size])",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.strided_slice(image, offsets, offsets + cropped_shape, strides=tf.ones_like(offsets))",
                            "Call"
                        ],
                        [
                            "image_list",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(image, 0)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_image_with_crop_or_pad(image, small_side, small_side)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.image.resize_images(image, tf.constant([image_size, image_size]))",
                            "Call"
                        ],
                        [
                            "_aspect_preserving_resize(image, image_size)",
                            "Call"
                        ],
                        [
                            "tf.to_float(image) / 255.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "to_float_350": {
                "x": {
                    "value": "image_orig",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(image_orig) / 255.0",
                            "BinOp"
                        ],
                        [
                            "image",
                            "variable"
                        ],
                        [
                            "_aspect_preserving_resize(image_orig, image_size + 2)",
                            "Call"
                        ],
                        [
                            "_central_crop([image_orig], image_size, image_size)[0]",
                            "Subscript"
                        ],
                        [
                            "image",
                            "variable"
                        ],
                        [
                            "image",
                            "variable"
                        ]
                    ]
                }
            },
            "ones_like_558": {
                "input": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int32(tf.stack([offset_height, offset_width, 0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "FixedLenFeature_186": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_187": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_188": {
                "shape": {
                    "value": "[64, 64]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_189": {
                "shape": {
                    "value": "[64, 64]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_190": {
                "shape": {
                    "value": "[128, 128]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_191": {
                "shape": {
                    "value": "[128, 128]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_192": {
                "shape": {
                    "value": "[256, 256]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_193": {
                "shape": {
                    "value": "[256, 256]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_194": {
                "shape": {
                    "value": "[512, 512]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_195": {
                "shape": {
                    "value": "[512, 512]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_196": {
                "shape": {
                    "value": "[512, 512]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_197": {
                "shape": {
                    "value": "[512, 512]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_311": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_312": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/imagenet_data.py": {
        "tensorflow": {
            "DEFINE_string_39": {
                "name": {
                    "value": "imagenet_data_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/imagenet-2012-tfrecord",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the ImageNet data, i.e. TFRecord of Example protos.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_102": {
                "variable": {
                    "value": "data_files",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "tf_record_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(imagenet_data_dir, '%s-*' % self.subset)",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordReader_120": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Exists_97": {
                "filename": {
                    "value": "imagenet_data_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.imagenet_data_dir)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/image_stylization/learning.py": {
        "tensorflow": {
            "shape_171": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stylized_inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_176": {
                "variable": {
                    "value": "y_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "(height - 1) * width * channels",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_177": {
                "variable": {
                    "value": "x_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "height * (width - 1) * channels",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "unstack_192": {
                "variable": {
                    "value": "(batch_size, height, width, channels)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.shape(feature_maps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_193": {
                "variable": {
                    "value": "denominator",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "height * width",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_194": {
                "variable": {
                    "value": "feature_maps",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "feature_maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(feature_maps, tf.stack([batch_size, height * width, channels]))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([batch_size, height * width, channels])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_196": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "feature_maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(feature_maps, tf.stack([batch_size, height * width, channels]))",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "feature_maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(feature_maps, tf.stack([batch_size, height * width, channels]))",
                            "Call"
                        ]
                    ]
                },
                "adjoint_a": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_107": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(end_points[name] - stylized_end_points[name]) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_110": {
                "variable": {
                    "value": "weighted_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "content_weights[name] * loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_111": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "total_content_loss + total_style_loss",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean((end_points[name] - stylized_end_points[name]) ** 2, [1, 2, 3])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean((gram_matrix(end_points[name]) - style_gram_matrices[name]) ** 2, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "(y_loss + x_loss) / tf.to_float(batch_size)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_143": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(gram_matrix(end_points[name]) - style_gram_matrices[name]) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_145": {
                "variable": {
                    "value": "weighted_style_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "style_weights[name] * loss",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_146": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "total_content_loss + total_style_loss",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean((end_points[name] - stylized_end_points[name]) ** 2, [1, 2, 3])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean((gram_matrix(end_points[name]) - style_gram_matrices[name]) ** 2, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "(y_loss + x_loss) / tf.to_float(batch_size)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Session_33": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_35": {
                "var_list": {
                    "value": "slim.get_variables('vgg_16')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "l2_loss_178": {
                "t": {
                    "value": "stylized_inputs[:, 1:, :, :] - stylized_inputs[:, :-1, :, :]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "l2_loss_180": {
                "t": {
                    "value": "stylized_inputs[:, :, 1:, :] - stylized_inputs[:, :, :-1, :]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_182": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_192": {
                "input": {
                    "value": "feature_maps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(feature_maps, tf.stack([batch_size, height * width, channels]))",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_195": {
                "values": {
                    "value": "[batch_size, height * width, channels]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/model.py": {
        "tensorflow": {
            "pad_95": {
                "variable": {
                    "value": "padded_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, 0], [padding, padding], [padding, padding], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "REFLECT",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_138": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "resize_nearest_neighbor_141": {
                "variable": {
                    "value": "upsampled_input",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "[stride * height, stride * width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_44": {
                "name_or_scope": {
                    "value": "transformer",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_137": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_171": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_52": {
                "name_or_scope": {
                    "value": "contract",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_56": {
                "name_or_scope": {
                    "value": "residual",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_62": {
                "name_or_scope": {
                    "value": "expand",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_normal_initializer_50": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_51": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/ops.py": {
        "tensorflow": {
            "convert_to_tensor_67": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "moments_105": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_108": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "variance": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_label_conditioned_variable('beta', tf.zeros_initializer(), labels, num_categories)",
                            "Call"
                        ],
                        [
                            "_weighted_variable('beta', tf.zeros_initializer(), weights, num_categories)",
                            "Call"
                        ],
                        [
                            "_style_parameters('beta')",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_label_conditioned_variable('gamma', tf.ones_initializer(), labels, num_categories)",
                            "Call"
                        ],
                        [
                            "_weighted_variable('gamma', tf.ones_initializer(), weights, num_categories)",
                            "Call"
                        ],
                        [
                            "_style_parameters('gamma')",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "variance_epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "float"
                        ],
                        [
                            "1e-05",
                            "float"
                        ],
                        [
                            "1e-05",
                            "float"
                        ]
                    ]
                }
            },
            "convert_to_tensor_161": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "moments_203": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_206": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "variance": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_label_conditioned_variable('beta', tf.zeros_initializer(), labels, num_categories)",
                            "Call"
                        ],
                        [
                            "_weighted_variable('beta', tf.zeros_initializer(), weights, num_categories)",
                            "Call"
                        ],
                        [
                            "_style_parameters('beta')",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_label_conditioned_variable('gamma', tf.ones_initializer(), labels, num_categories)",
                            "Call"
                        ],
                        [
                            "_weighted_variable('gamma', tf.ones_initializer(), weights, num_categories)",
                            "Call"
                        ],
                        [
                            "_style_parameters('gamma')",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "variance_epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "float"
                        ],
                        [
                            "1e-05",
                            "float"
                        ],
                        [
                            "1e-05",
                            "float"
                        ]
                    ]
                }
            },
            "convert_to_tensor_255": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "moments_285": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_289": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "variance": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "offset": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_label_conditioned_variable('beta', tf.zeros_initializer(), labels, num_categories)",
                            "Call"
                        ],
                        [
                            "_weighted_variable('beta', tf.zeros_initializer(), weights, num_categories)",
                            "Call"
                        ],
                        [
                            "_style_parameters('beta')",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_label_conditioned_variable('gamma', tf.ones_initializer(), labels, num_categories)",
                            "Call"
                        ],
                        [
                            "_weighted_variable('gamma', tf.ones_initializer(), weights, num_categories)",
                            "Call"
                        ],
                        [
                            "_style_parameters('gamma')",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "variance_epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "float"
                        ],
                        [
                            "1e-05",
                            "float"
                        ],
                        [
                            "1e-05",
                            "float"
                        ]
                    ]
                }
            },
            "variable_scope_65": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "InstanceNorm",
                    "type": "str",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TensorShape_83": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "[num_categories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concatenate_83": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "arys": {
                    "value": "params_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs_shape[-1:]",
                            "Subscript"
                        ],
                        [
                            "inputs_shape[-1:]",
                            "Subscript"
                        ],
                        [
                            "inputs_shape[-1:]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_92": {
                "variable": {
                    "value": "conditioned_var",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "style_params['{}/{}'.format(sc.name, name)]",
                            "Subscript"
                        ],
                        [
                            "tf.check_numerics(var, 'NaN/Inf in {}'.format(var.name))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(var, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_93": {
                "input": {
                    "value": "conditioned_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(var, labels)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(conditioned_var, 1), 1)",
                            "Call"
                        ],
                        [
                            "weights * var",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(conditioned_var, 0, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(conditioned_var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_159": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "InstanceNorm",
                    "type": "str",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TensorShape_177": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "[num_categories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concatenate_177": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "arys": {
                    "value": "params_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs_shape[-1:]",
                            "Subscript"
                        ],
                        [
                            "inputs_shape[-1:]",
                            "Subscript"
                        ],
                        [
                            "inputs_shape[-1:]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_186": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(weights, weights.get_shape().concatenate([1] * params_shape.ndims))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "weights.get_shape().concatenate([1] * params_shape.ndims)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_190": {
                "variable": {
                    "value": "conditioned_var",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "conditioned_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(var, labels)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(conditioned_var, 1), 1)",
                            "Call"
                        ],
                        [
                            "weights * var",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(conditioned_var, 0, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(conditioned_var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "expand_dims_191": {
                "input": {
                    "value": "conditioned_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(var, labels)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(conditioned_var, 1), 1)",
                            "Call"
                        ],
                        [
                            "weights * var",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(conditioned_var, 0, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(conditioned_var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_254": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "default_name": {
                    "value": "StyleNorm",
                    "type": "str",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_276": {
                "input": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "style_params['{}/{}'.format(sc.name, name)]",
                            "Subscript"
                        ],
                        [
                            "tf.check_numerics(var, 'NaN/Inf in {}'.format(var.name))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(var, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "check_numerics_273": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "style_params['{}/{}'.format(sc.name, name)]",
                            "Subscript"
                        ],
                        [
                            "tf.check_numerics(var, 'NaN/Inf in {}'.format(var.name))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(var, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "message": {
                    "value": "'NaN/Inf in {}'.format(var.name)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_275": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "slim.model_variable(name, shape=shape, dtype=dtype, initializer=initializer, collections=var_collections, trainable=trainable)",
                            "Call"
                        ],
                        [
                            "style_params['{}/{}'.format(sc.name, name)]",
                            "Subscript"
                        ],
                        [
                            "tf.check_numerics(var, 'NaN/Inf in {}'.format(var.name))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(var, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(var, 1), 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_100": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_103": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_198": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_201": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/image_stylization/vgg.py": {
        "tensorflow": {
            "constant_66": {
                "value": {
                    "value": "[123.68, 116.779, 103.939]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_71": {
                "name_or_scope": {
                    "value": "vgg_16",
                    "type": "str",
                    "possible_values": []
                },
                "default_name": {
                    "value": "[inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/improv_rnn/improv_rnn_config_flags.py": {
        "tensorflow": {
            "DEFINE_string_21": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "\"Which config to use. Must be one of 'basic_improv', 'attention_improv', or 'chord_pitches_improv'.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_26": {
                "name": {
                    "value": "generator_id",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A unique ID for the generator, overriding the default.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_30": {
                "name": {
                    "value": "generator_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A description of the generator, overriding the default.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_34": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/improv_rnn/improv_rnn_create_dataset.py": {
        "tensorflow": {
            "set_verbosity_48": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_64": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/improv_rnn/improv_rnn_create_dataset_test.py": {
        "tensorflow": {
            "disable_v2_behavior_28": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_96": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/improv_rnn/improv_rnn_generate.py": {
        "tensorflow": {
            "DEFINE_string_41": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where the latest checkpoint will be loaded from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_44": {
                "name": {
                    "value": "bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the bundle file. If specified, this will take priority over run_dir, unless save_generator_bundle is True, in which case both this flag and run_dir are required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_53": {
                "name": {
                    "value": "bundle_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A short, human-readable text description of the bundle (e.g., training data, hyper parameters, etc.).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_57": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/improv_rnn/generated",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory where MIDI files will be saved to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_60": {
                "name": {
                    "value": "num_outputs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of lead sheets to generate. One MIDI file will be created for each.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_64": {
                "name": {
                    "value": "steps_per_chord",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of melody steps to take per backing chord. Each step is a 16th of a bar, so if backing_chords = \"C G Am F\" and steps_per_chord = 16, four bars will be generated.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_69": {
                "name": {
                    "value": "primer_melody",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of note_seq.Melody event values. For example: \"[60, -2, 60, -2, 67, -2, 67, -2]\". If specified, this melody will be used as the priming melody. If a priming melody is not specified, melodies will be generated from scratch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_75": {
                "name": {
                    "value": "backing_chords",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "C G Am F C G F C",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a chord progression, with chord symbols separated by spaces. For example: \"C Dm7 G13 Cmaj7\". The duration of each chord, in steps, is specified by the steps_per_chord flag.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_80": {
                "name": {
                    "value": "primer_midi",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to a MIDI file containing a melody that will be used as a priming melody. If a primer melody is not specified, melodies will be generated from scratch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_89": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to play generated output at. If a primer MIDI is given, the qpm from that will override this flag. If qpm is None, qpm will default to 120.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_94": {
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "The randomness of the generated melodies. 1.0 uses the unaltered softmax probabilities, greater than 1.0 makes melodies more random, less than 1.0 makes melodies less random.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_99": {
                "name": {
                    "value": "beam_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The beam size to use for beam search when generating melodies.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_102": {
                "name": {
                    "value": "branch_factor",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The branch factor to use for beam search when generating melodies.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_105": {
                "name": {
                    "value": "steps_per_iteration",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of melody steps to take per beam search iteration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_108": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_229": {
                "msg": {
                    "value": "input_sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "primer_sequence",
                            "variable"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_230": {
                "msg": {
                    "value": "generator_options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_247": {
                "msg": {
                    "value": "Wrote %d MIDI files to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.num_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_verbosity_253": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_285": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_286": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_150": {
                "msg": {
                    "value": "--output_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_158": {
                "filename": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_159": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_278": {
                "msg": {
                    "value": "Saving generator bundle to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "bundle_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.bundle_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_171": {
                "msg": {
                    "value": "No priming sequence specified. Defaulting to a single middle C.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_203": {
                "msg": {
                    "value": "Priming sequence is longer than the total number of steps requested: Priming sequence length: %s, Generation length requested: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generate_section.start_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "total_seconds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(backing_chords) * seconds_per_step",
                            "BinOp"
                        ]
                    ]
                }
            },
            "warning_277": {
                "msg": {
                    "value": "No bundle description provided.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/improv_rnn/improv_rnn_pipeline.py": {
        "tensorflow": {
            "warning_58": {
                "msg": {
                    "value": "Skipped lead sheet: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_62": {
                "msg": {
                    "value": "Skipped lead sheet: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/improv_rnn/improv_rnn_train.py": {
        "tensorflow": {
            "DEFINE_string_26": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/improv_rnn/logdir/run1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where checkpoints and summary events will be saved during training and evaluation. Separate subdirectories for training events and eval events will be created within `run_dir`. Multiple runs can be stored within the parent directory of `run_dir`. Point TensorBoard to the parent directory of `run_dir` to see all your runs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "sequence_example_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to TFRecord file containing tf.SequenceExample records for training or evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_39": {
                "name": {
                    "value": "num_training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The the number of global training steps your model should take before exiting training. Leave as 0 to run until terminated manually.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_43": {
                "name": {
                    "value": "num_eval_examples",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of evaluation examples your model should process for each evaluation step.Leave as 0 to use the entire evaluation set.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_47": {
                "name": {
                    "value": "summary_frequency",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "A summary statement will be logged every `summary_frequency` steps during training or every `summary_frequency` seconds during evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_52": {
                "name": {
                    "value": "num_checkpoints",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of most recent checkpoints to keep in the training directory. Keeps all if 0.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_58": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_73": {
                "variable": {
                    "value": "sequence_example_file_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "os.path.expanduser(FLAGS.sequence_example_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_64": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_84": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_85": {
                "msg": {
                    "value": "Train dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_106": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_67": {
                "msg": {
                    "value": "--run_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_70": {
                "msg": {
                    "value": "--sequence_example_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_89": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_90": {
                "msg": {
                    "value": "Eval dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/latent_transfer/common.py": {
        "tensorflow": {
            "DEFINE_string_47": {
                "name": {
                    "value": "default_scratch",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The default root directory for scratching. It can contain '~' which would be handled correctly.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_125": {
                "dirname": {
                    "value": "data_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'data')",
                            "Call"
                        ],
                        [
                            "os.path.join(basepath, 'data')",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_126": {
                "dirname": {
                    "value": "save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'ckpts')",
                            "Call"
                        ],
                        [
                            "os.path.join(basepath, 'ckpts')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/latent_transfer/common_joint.py": {
        "tensorflow": {
            "DEFINE_string_52": {
                "name": {
                    "value": "wavegan_gen_ckpt_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The directory to WaveGAN generator's ckpt. If WaveGAN is involved, this argument must be set.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_55": {
                "name": {
                    "value": "wavegan_inception_ckpt_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The directory to WaveGAN inception (classifier)'s ckpt. If WaveGAN is involved, this argument must be set.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_59": {
                "name": {
                    "value": "wavegan_latent_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The directory to WaveGAN's latent space.If WaveGAN is involved, this argument must be set.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_350": {
                "variable": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "key + '_ph'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_351": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, shape=(), name=key + '_ph')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_394": {
                "msg": {
                    "value": "index_grouped_by_label size: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "[len(_) for _ in index_grouped_by_label]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "info_397": {
                "msg": {
                    "value": "train loaded from %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "path_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dataset.basepath, 'encoded', model_uid, 'encoded_train_data.npz')",
                            "Call"
                        ],
                        [
                            "os.path.join(latent_dir, 'data_train.npz')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_398": {
                "msg": {
                    "value": "train shapes: mu = %s, sigma = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_mu.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "train_sigma.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_493": {
                "dirname": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(local_base_path, 'ckpts', model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_495": {
                "dirname": {
                    "value": "sample_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(local_base_path, 'sample', model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_534": {
                "variable": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_632": {
                "variable": {
                    "value": "graph_sc09_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_641": {
                "variable": {
                    "value": "graph_sc09_class",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_536": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_636": {
                "variable": {
                    "value": "sess_sc09_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph_sc09_gan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ],
                        [
                            "self.graph_sc09_gan",
                            "Attribute"
                        ]
                    ]
                }
            },
            "import_meta_graph_637": {
                "variable": {
                    "value": "saver_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(gen_ckpt_dir, 'infer', 'infer.meta')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_644": {
                "variable": {
                    "value": "sess_sc09_class",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph_sc09_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ],
                        [
                            "self.graph_sc09_class",
                            "Attribute"
                        ]
                    ]
                }
            },
            "import_meta_graph_645": {
                "variable": {
                    "value": "saver_class",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(inception_ckpt_dir, 'infer.meta')",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/configs/joint_exp_2fashion_parameterized.py": {
        "tensorflow": {}
    },
    "magenta/models/latent_transfer/configs/joint_exp_2mnist_parameterized.py": {
        "tensorflow": {}
    },
    "magenta/models/latent_transfer/configs/joint_exp_mnist100_2wavegan_parameterized.py": {
        "tensorflow": {}
    },
    "magenta/models/latent_transfer/configs/joint_exp_mnist2fashion_parameterized.py": {
        "tensorflow": {}
    },
    "magenta/models/latent_transfer/configs/joint_exp_mnist2wavegan_parameterized.py": {
        "tensorflow": {}
    },
    "magenta/models/latent_transfer/encode_dataspace.py": {
        "tensorflow": {
            "DEFINE_string_32": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "mnist_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the model config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_34": {
                "name": {
                    "value": "exp_uid",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "String to append to config for filenames/directories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_64": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_58": {
                "dirname": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_59": {
                "dirname": {
                    "value": "best_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_dir, 'best')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_60": {
                "msg": {
                    "value": "Save Dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_104": {
                "msg": {
                    "value": "encode train_data: mu.shape = %s sigma.shape = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "encoded_train_data.mu.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "encoded_train_data.sigma.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_111": {
                "msg": {
                    "value": "encode eval_data: mu.shape = %s sigma.shape = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "encoded_eval_data.mu.shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "encoded_eval_data.sigma.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_119": {
                "dirname": {
                    "value": "encoded_save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'encoded', model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_120": {
                "msg": {
                    "value": "encoded train_data saved to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "os.path.join(encoded_save_path, 'encoded_train_data.npz')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_127": {
                "msg": {
                    "value": "encoded eval_data saved to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "os.path.join(encoded_save_path, 'encoded_eval_data.npz')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_137": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_138": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_initializer_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/interpolate_joint.py": {
        "tensorflow": {
            "DEFINE_string_37": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "transfer_A_unconditional_mnist_to_mnist",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the model config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_39": {
                "name": {
                    "value": "exp_uid_A",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "exp_uid for data_A",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_40": {
                "name": {
                    "value": "exp_uid_B",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "exp_uid for data_B",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_41": {
                "name": {
                    "value": "exp_uid",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "String to append to config for filenames/directories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_43": {
                "name": {
                    "value": "n_iters",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "100000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of iterations.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_44": {
                "name": {
                    "value": "n_iters_per_save",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "5000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per a save.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_45": {
                "name": {
                    "value": "n_iters_per_eval",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "5000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per a evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_47": {
                "name": {
                    "value": "random_seed",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "19260817",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Random seed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_48": {
                "name": {
                    "value": "exp_uid_classifier",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "exp_uid for classifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_51": {
                "name": {
                    "value": "n_latent",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_52": {
                "name": {
                    "value": "n_latent_shared",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_53": {
                "name": {
                    "value": "prior_loss_beta_A",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_54": {
                "name": {
                    "value": "prior_loss_beta_B",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_55": {
                "name": {
                    "value": "prior_loss_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_56": {
                "name": {
                    "value": "mean_recons_A_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_57": {
                "name": {
                    "value": "mean_recons_B_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_58": {
                "name": {
                    "value": "mean_recons_A_to_B_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_59": {
                "name": {
                    "value": "mean_recons_B_to_A_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_60": {
                "name": {
                    "value": "pairing_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_63": {
                "name": {
                    "value": "load_ckpt_iter",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_64": {
                "name": {
                    "value": "interpolate_labels",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "a `,` separated list of 0-indexed labels.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_66": {
                "name": {
                    "value": "nb_images_between_labels",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_115": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_random_seed_111": {
                "seed": {
                    "value": "FLAGS.random_seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reset_default_graph_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_142": {
                "dirname": {
                    "value": "intepolate_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(sample_dir, 'interpolate_sample', '%010d' % FLAGS.load_ckpt_iter)",
                            "Call"
                        ]
                    ]
                }
            },
            "run_217": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_initializer_127": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/local_mnist.py": {
        "tensorflow": {
            "info_50": {
                "msg": {
                    "value": "Extracting",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "f.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_88": {
                "msg": {
                    "value": "Extracting",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "f.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/model_dataspace.py": {
        "tensorflow": {
            "placeholder_86": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, n_labels)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_88": {
                "variable": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "D_label",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_90": {
                "variable": {
                    "value": "z0",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, n_latent)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "z0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_138": {
                "variable": {
                    "value": "mean_recons",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "recons",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(p_x.log_prob(x), axis=[1, 2, 3])",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(p_x.log_prob(x), axis=[-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_156": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "config['beta']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_163": {
                "variable": {
                    "value": "vae_lr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0003",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_164": {
                "variable": {
                    "value": "classifier_lr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0003",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdamOptimizer_169": {
                "variable": {
                    "value": "train_vae",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "vae_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0.0003)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_173": {
                "variable": {
                    "value": "train_classifier",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "classifier_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0.0003)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_178": {
                "variable": {
                    "value": "vae_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "vae_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(encoder.get_variables())",
                            "Call"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Saver_179": {
                "variable": {
                    "value": "classifier_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "classifier_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "classifier.get_variables()",
                            "Call"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_64": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, img_width * img_width)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_68": {
                "variable": {
                    "value": "attr_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones([1]).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_70": {
                "variable": {
                    "value": "x_sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "config['x_sigma']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_134": {
                "variable": {
                    "value": "recons",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "p_x.log_prob(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_136": {
                "variable": {
                    "value": "recons",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "p_x.log_prob(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_148": {
                "variable": {
                    "value": "mean_KL",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_sum_151": {
                "variable": {
                    "value": "KL",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "KL_qp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ds.kl_divergence(q_z, p_z)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_152": {
                "variable": {
                    "value": "mean_KL",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "KL",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(KL_qp, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_76": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, img_width, img_width, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_80": {
                "variable": {
                    "value": "attr_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones([1, n_labels]).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_81": {
                "variable": {
                    "value": "x_sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "config['x_sigma']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sigmoid_71": {
                "x": {
                    "value": "logs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sigmoid_82": {
                "x": {
                    "value": "logs",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/model_joint.py": {
        "tensorflow": {
            "sigmoid_52": {
                "variable": {
                    "value": "gates",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x[:, output_size:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softplus_58": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1 - gates) * z + gates * dz",
                            "BinOp"
                        ],
                        [
                            "snt.Linear(output_size)(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.softplus(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_138": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, n_latent)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_mean_168": {
                "variable": {
                    "value": "recons",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x_prime - x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_169": {
                "variable": {
                    "value": "mean_recons",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "recons",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.square(x_prime - x))",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_194": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "config['prior_loss_beta']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_202": {
                "variable": {
                    "value": "vae_lr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0003",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_275": {
                "variable": {
                    "value": "vae_lr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.get('lr', 0.0003)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_278": {
                "variable": {
                    "value": "train_vae",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "vae_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0.0003)",
                            "Call"
                        ],
                        [
                            "tf.constant(lr)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_280": {
                "variable": {
                    "value": "vae_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "vae_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(encoder.get_variables())",
                            "Call"
                        ],
                        [
                            "vae_A.vae_vars + vae_B.vae_vars",
                            "BinOp"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_301": {
                "variable": {
                    "value": "z_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, n_latent_shared)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_308": {
                "variable": {
                    "value": "x_align_A",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, n_latent_A)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_309": {
                "variable": {
                    "value": "x_align_B",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, n_latent_B)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_sum_324": {
                "variable": {
                    "value": "KL_align",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "KL_qp_align",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ds.kl_divergence(q_z_align, p_z_align)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_325": {
                "variable": {
                    "value": "mean_KL_align",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "KL_align",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(KL_qp_align, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_335": {
                "variable": {
                    "value": "mean_recons_A_align",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x_prime_A_align - x_align_A)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_336": {
                "variable": {
                    "value": "mean_recons_B_align",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x_prime_B_align - x_align_B)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_349": {
                "variable": {
                    "value": "mean_recons_A_to_B_align",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x_A_to_B_align - x_align_B)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_351": {
                "variable": {
                    "value": "mean_recons_B_to_A_align",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x_B_to_A_align - x_align_A)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_369": {
                "variable": {
                    "value": "full_lr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.get('lr', 0.0003)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_370": {
                "variable": {
                    "value": "train_full",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "full_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(lr)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_81": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Linear(l)(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_107": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Linear(l)(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_182": {
                "variable": {
                    "value": "prior_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdamOptimizer_214": {
                "variable": {
                    "value": "train_vae",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "vae_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0.0003)",
                            "Call"
                        ],
                        [
                            "tf.constant(lr)",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_218": {
                "variable": {
                    "value": "vae_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "vae_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(encoder.get_variables())",
                            "Call"
                        ],
                        [
                            "vae_A.vae_vars + vae_B.vae_vars",
                            "BinOp"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_156": {
                "input_tensor": {
                    "value": "tf.abs(sigma)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_168": {
                "x": {
                    "value": "x_prime - x",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_186": {
                "variable": {
                    "value": "KL",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "KL_qp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ds.kl_divergence(ds.Normal(loc=mu, scale=sigma), p_z)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_187": {
                "variable": {
                    "value": "mean_KL",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "KL",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(KL_qp, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_335": {
                "x": {
                    "value": "x_prime_A_align - x_align_A",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_336": {
                "x": {
                    "value": "x_prime_B_align - x_align_B",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_350": {
                "x": {
                    "value": "x_A_to_B_align - x_align_B",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_352": {
                "x": {
                    "value": "x_B_to_A_align - x_align_A",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_156": {
                "x": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "affine(x, self.output_size, z, residual=self.residual, softplus=False)",
                            "Call"
                        ],
                        [
                            "affine(x, self.output_size, z, residual=self.residual, softplus=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_157": {
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "affine(x, self.output_size, z, residual=self.residual, softplus=True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/latent_transfer/nn.py": {
        "tensorflow": {
            "square_29": {
                "variable": {
                    "value": "sigma_1_square",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sigma_1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_30": {
                "variable": {
                    "value": "sigma_2_square",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sigma_2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_35": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sigma_square",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sigma_1_square * sigma_2_square / (sigma_1_square + sigma_2_square)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_45": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[b[:mb], tf.zeros([diff, b_shape[1], b_shape[2], b_shape[3]])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_47": {
                "variable": {
                    "value": "tmp",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([b[:mb], tf.zeros([diff, b_shape[1], b_shape[2], b_shape[3]])], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, cols * b_shape[1], b_shape[2], b_shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_48": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tmp[i:i + 1] for i in range(rows)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softplus_65": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "pre_z[:, self.n_latent:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_103": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2D(l[0], l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, h_shape[1] * h_shape[2] * h_shape[3]])",
                            "Call"
                        ],
                        [
                            "snt.Linear(l)(h)",
                            "Call"
                        ],
                        [
                            "snt.Linear(l[1] * l[2] * l[0])(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, l[1], l[2], l[0]])",
                            "Call"
                        ],
                        [
                            "snt.Conv2DTranspose(l[0], None, l[1], l[2])(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2DTranspose(l[0], None, l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2D(l[0], l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, h_shape[1] * h_shape[2] * h_shape[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, h_shape[1] * h_shape[2] * h_shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softplus_108": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "pre_z[:, self.n_latent:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_157": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2D(l[0], l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, h_shape[1] * h_shape[2] * h_shape[3]])",
                            "Call"
                        ],
                        [
                            "snt.Linear(l)(h)",
                            "Call"
                        ],
                        [
                            "snt.Linear(l[1] * l[2] * l[0])(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, l[1], l[2], l[0]])",
                            "Call"
                        ],
                        [
                            "snt.Conv2DTranspose(l[0], None, l[1], l[2])(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2DTranspose(l[0], None, l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2D(l[0], l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, h_shape[1] * h_shape[2] * h_shape[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, h_shape[1] * h_shape[2] * h_shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_176": {
                "variable": {
                    "value": "gates",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x[:, self.n_latent:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "relu_62": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Linear(size)(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_79": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Linear(size)(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_100": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Conv2D(l[0], l[1], l[2])(h)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_154": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Conv2D(l[0], l[1], l[2])(h)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_173": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Linear(l)(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_191": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Linear(l)(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_46": {
                "shape": {
                    "value": "[diff, b_shape[1], b_shape[2], b_shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_130": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2D(l[0], l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, h_shape[1] * h_shape[2] * h_shape[3]])",
                            "Call"
                        ],
                        [
                            "snt.Linear(l)(h)",
                            "Call"
                        ],
                        [
                            "snt.Linear(l[1] * l[2] * l[0])(x)",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, l[1], l[2], l[0]])",
                            "Call"
                        ],
                        [
                            "snt.Conv2DTranspose(l[0], None, l[1], l[2])(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2DTranspose(l[0], None, l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(snt.Conv2D(l[0], l[1], l[2])(h))",
                            "Call"
                        ],
                        [
                            "tf.reshape(h, [-1, h_shape[1] * h_shape[2] * h_shape[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, l[1], l[2], l[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_134": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "snt.Conv2DTranspose(l[0], None, l[1], l[2])(h)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/sample_dataspace.py": {
        "tensorflow": {
            "DEFINE_string_36": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "mnist_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the model config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "exp_uid",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "String to append to config for filenames/directories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "random_seed",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "19260817",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Random seed.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_72": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_62": {
                "dirname": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_63": {
                "dirname": {
                    "value": "best_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_dir, 'best')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_64": {
                "msg": {
                    "value": "Save Dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_random_seed_68": {
                "seed": {
                    "value": "FLAGS.random_seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reset_default_graph_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "disable_v2_behavior_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_125": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "device_73": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(ps_tasks=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "MakeDirs_88": {
                "dirname": {
                    "value": "image_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(basepath, 'sample', model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "replica_device_setter_73": {
                "ps_tasks": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/sample_wavegan.py": {
        "tensorflow": {
            "DEFINE_integer_32": {
                "name": {
                    "value": "total_per_label",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "7000",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Minimal # samples per label",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_34": {
                "name": {
                    "value": "top_per_label",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1700",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "# of top samples per label",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "gen_ckpt_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The directory to WaveGAN generator's ckpt.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "inception_ckpt_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The directory to WaveGAN inception (classifier)'s ckpt.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_40": {
                "name": {
                    "value": "latent_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"The directory to WaveGAN's latent space.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_62": {
                "variable": {
                    "value": "graph_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_74": {
                "variable": {
                    "value": "graph_class",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_60": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_64": {
                "variable": {
                    "value": "sess_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph_gan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_76": {
                "variable": {
                    "value": "sess_class",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph_class",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "import_meta_graph_77": {
                "variable": {
                    "value": "saver_class",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(inception_ckpt_dir, 'infer.meta')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "MakeDirs_94": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.latent_dir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "MakeDirs_141": {
                "dirname": {
                    "value": "image_output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, 'sample_iamge')",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_181": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_182": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "import_meta_graph_66": {
                "variable": {
                    "value": "saver_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(gen_ckpt_dir, '..', 'infer', 'infer.meta')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "import_meta_graph_70": {
                "variable": {
                    "value": "saver_gan",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "os.path.join(gen_ckpt_dir, 'infer.meta')",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/latent_transfer/train_dataspace.py": {
        "tensorflow": {
            "DEFINE_string_36": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "mnist_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the model config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_38": {
                "name": {
                    "value": "n_iters",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "200000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of iterations.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_39": {
                "name": {
                    "value": "n_iters_per_save",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per saving.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "n_iters_per_eval",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "50",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per evaluate.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_41": {
                "name": {
                    "value": "lr",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0003",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "learning_rate.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_42": {
                "name": {
                    "value": "exp_uid",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "String to append to config for filenames/directories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_44": {
                "name": {
                    "value": "random_seed",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10003",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Random seed.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_82": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_all_91": {
                "variable": {
                    "value": "scalar_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "image_98": {
                "variable": {
                    "value": "x_mean_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Reconstruction",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "nn.tf_batch_image(x_mean_)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_100": {
                "variable": {
                    "value": "x_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Original",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "nn.tf_batch_image(x_)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "image_101": {
                "variable": {
                    "value": "sample_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "Sample",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "nn.tf_batch_image(x_mean_)",
                    "type": "Call",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "FileWriter_104": {
                "variable": {
                    "value": "train_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "save_dir + '/vae_train'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_105": {
                "variable": {
                    "value": "eval_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "save_dir + '/vae_eval'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_71": {
                "dirname": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_72": {
                "dirname": {
                    "value": "best_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_dir, 'best')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_73": {
                "msg": {
                    "value": "Save Dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_81": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_88": {
                "name": {
                    "value": "Train_Loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "m.vae_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_89": {
                "name": {
                    "value": "Mean_Recon_LL",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "m.mean_recons",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_90": {
                "name": {
                    "value": "Mean_KL",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "m.mean_KL",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_95": {
                "variable": {
                    "value": "x_mean_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x_mean_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x_mean_, [-1, MNIST_SIZE, MNIST_SIZE, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, MNIST_SIZE, MNIST_SIZE, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_96": {
                "variable": {
                    "value": "x_",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x_, [-1, MNIST_SIZE, MNIST_SIZE, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, MNIST_SIZE, MNIST_SIZE, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_189": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_190": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_initializer_108": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_136": {
                "msg": {
                    "value": "Iter: %d, Loss: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(i_start, FLAGS.n_iters)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "res[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "info_181": {
                "msg": {
                    "value": "SAVING BEST! %s Iter: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "save_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(best_dir, 'vae_best_%s.ckpt' % model_uid)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(i_start, FLAGS.n_iters)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/latent_transfer/train_dataspace_classifier.py": {
        "tensorflow": {
            "DEFINE_string_35": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "mnist_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the model config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_bool_37": {
                "name": {
                    "value": "local",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "help": {
                    "value": "Run job locally.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_38": {
                "name": {
                    "value": "n_iters",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "200000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of iterations.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_39": {
                "name": {
                    "value": "n_iters_per_save",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per a save.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_40": {
                "name": {
                    "value": "lr",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0003",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "learning_rate.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_41": {
                "name": {
                    "value": "exp_uid",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "String to append to config for filenames/directories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_77": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_83": {
                "variable": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(m.pred_classifier, 0.5)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_84": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(y_true, y_pred), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "merge_all_88": {
                "variable": {
                    "value": "scalar_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_91": {
                "variable": {
                    "value": "train_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "save_dir + '/train'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_92": {
                "variable": {
                    "value": "eval_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "save_dir + '/eval'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_67": {
                "dirname": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_68": {
                "dirname": {
                    "value": "best_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_dir, 'best')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_69": {
                "msg": {
                    "value": "Save Dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(save_path, model_uid)",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_76": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_86": {
                "name": {
                    "value": "Loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "m.classifier_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_87": {
                "name": {
                    "value": "Accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.cast(tf.equal(y_true, y_pred), tf.float32))",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_159": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_160": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "greater_83": {
                "x": {
                    "value": "m.pred_classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_84": {
                "x": {
                    "value": "tf.equal(y_true, y_pred)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_95": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_123": {
                "msg": {
                    "value": "Iter: %d, Loss: %.2e",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(i_start, FLAGS.n_iters)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "res[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "equal_84": {
                "x": {
                    "value": "y_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m.labels",
                            "Attribute"
                        ]
                    ]
                },
                "y": {
                    "value": "y_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.greater(m.pred_classifier, 0.5), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_151": {
                "msg": {
                    "value": "SAVING BEST! %s Iter: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "save_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(best_dir, 'classifier_best_%s.ckpt' % model_uid)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(i_start, FLAGS.n_iters)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/latent_transfer/train_joint.py": {
        "tensorflow": {
            "DEFINE_string_42": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "transfer_A_unconditional_mnist_to_mnist",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the model config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_44": {
                "name": {
                    "value": "exp_uid_A",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "exp_uid for data_A",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_45": {
                "name": {
                    "value": "exp_uid_B",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "exp_uid for data_B",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_46": {
                "name": {
                    "value": "exp_uid",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "String to append to config for filenames/directories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_48": {
                "name": {
                    "value": "n_iters",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "100000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of iterations.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_49": {
                "name": {
                    "value": "n_iters_per_save",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "5000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per a save.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_50": {
                "name": {
                    "value": "n_iters_per_eval",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "5000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Iterations per a evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_52": {
                "name": {
                    "value": "random_seed",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "19260817",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Random seed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_53": {
                "name": {
                    "value": "exp_uid_classifier",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "_exp_0",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "exp_uid for classifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_56": {
                "name": {
                    "value": "n_latent",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_57": {
                "name": {
                    "value": "n_latent_shared",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_58": {
                "name": {
                    "value": "prior_loss_beta_A",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_59": {
                "name": {
                    "value": "prior_loss_beta_B",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_60": {
                "name": {
                    "value": "prior_loss_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_61": {
                "name": {
                    "value": "mean_recons_A_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_62": {
                "name": {
                    "value": "mean_recons_B_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_63": {
                "name": {
                    "value": "mean_recons_A_to_B_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_64": {
                "name": {
                    "value": "mean_recons_B_to_A_align_beta",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_65": {
                "name": {
                    "value": "pairing_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_114": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_126": {
                "variable": {
                    "value": "train_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "save_dir + '/transfer_train'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_127": {
                "variable": {
                    "value": "scalar_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar(key, value) for (key, value) in m.get_summary_kv_dict().items()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "set_random_seed_110": {
                "seed": {
                    "value": "FLAGS.random_seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reset_default_graph_113": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "disable_v2_behavior_334": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_335": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_variables_initializer_134": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_128": {
                "name": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "MakeDirs_308": {
                "dirname": {
                    "value": "this_iter_sample_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(sample_dir, 'transfer_train_sample', '%010d' % i)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/melody_rnn/melody_rnn_config_flags.py": {
        "tensorflow": {
            "DEFINE_string_23": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "\"Which config to use. Must be one of 'basic', 'lookback', or 'attention'. Mutually exclusive with `--melody_encoder_decoder`.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_28": {
                "name": {
                    "value": "melody_encoder_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "\"Which encoder/decoder to use. Must be one of 'onehot', 'lookback', or 'key'. Mutually exclusive with `--config`.\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_33": {
                "name": {
                    "value": "generator_id",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A unique ID for the generator. Overrides the default if `--config` is also supplied.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "generator_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A description of the generator. Overrides the default if `--config` is also supplied.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_43": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/melody_rnn/melody_rnn_create_dataset.py": {
        "tensorflow": {
            "set_verbosity_48": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_64": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/melody_rnn/melody_rnn_create_dataset_test.py": {
        "tensorflow": {
            "disable_v2_behavior_28": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_86": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/melody_rnn/melody_rnn_generate.py": {
        "tensorflow": {
            "DEFINE_string_31": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where the latest checkpoint will be loaded from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_34": {
                "name": {
                    "value": "checkpoint_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the checkpoint file. run_dir will take priority over this flag.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the bundle file. If specified, this will take priority over run_dir and checkpoint_file, unless save_generator_bundle is True, in which case both this flag and either run_dir or checkpoint_file are required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_47": {
                "name": {
                    "value": "bundle_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A short, human-readable text description of the bundle (e.g., training data, hyper parameters, etc.).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/melody_rnn/generated",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory where MIDI files will be saved to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_54": {
                "name": {
                    "value": "num_outputs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of melodies to generate. One MIDI file will be created for each.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_58": {
                "name": {
                    "value": "num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The total number of steps the generated melodies should be, priming melody length + generated steps. Each step is a 16th of a bar.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_62": {
                "name": {
                    "value": "primer_melody",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of note_seq.Melody event values. For example: \"[60, -2, 60, -2, 67, -2, 67, -2]\". If specified, this melody will be used as the priming melody. If a priming melody is not specified, melodies will be generated from scratch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_68": {
                "name": {
                    "value": "primer_midi",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to a MIDI file containing a melody that will be used as a priming melody. If a primer melody is not specified, melodies will be generated from scratch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_73": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to play generated output at. If a primer MIDI is given, the qpm from that will override this flag. If qpm is None, qpm will default to 120.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_78": {
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "The randomness of the generated melodies. 1.0 uses the unaltered softmax probabilities, greater than 1.0 makes melodies more random, less than 1.0 makes melodies less random.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_83": {
                "name": {
                    "value": "beam_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The beam size to use for beam search when generating melodies.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_86": {
                "name": {
                    "value": "branch_factor",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The branch factor to use for beam search when generating melodies.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_89": {
                "name": {
                    "value": "steps_per_iteration",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of melody steps to take per beam search iteration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_92": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_201": {
                "msg": {
                    "value": "input_sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "primer_sequence",
                            "variable"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_202": {
                "msg": {
                    "value": "generator_options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_215": {
                "msg": {
                    "value": "Wrote %d MIDI files to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.num_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_verbosity_221": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_251": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_137": {
                "msg": {
                    "value": "--output_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_145": {
                "filename": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_146": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_243": {
                "msg": {
                    "value": "Saving generator bundle to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "bundle_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.bundle_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_158": {
                "msg": {
                    "value": "No priming sequence specified. Defaulting to a single middle C.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_184": {
                "msg": {
                    "value": "Priming sequence is longer than the total number of steps requested: Priming sequence length: %s, Generation length requested: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generate_section.start_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "total_seconds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.num_steps * seconds_per_step",
                            "BinOp"
                        ]
                    ]
                }
            },
            "warning_242": {
                "msg": {
                    "value": "No bundle description provided.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/melody_rnn/melody_rnn_pipeline.py": {
        "tensorflow": {}
    },
    "magenta/models/melody_rnn/melody_rnn_train.py": {
        "tensorflow": {
            "DEFINE_string_26": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/melody_rnn/logdir/run1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where checkpoints and summary events will be saved during training and evaluation. Separate subdirectories for training events and eval events will be created within `run_dir`. Multiple runs can be stored within the parent directory of `run_dir`. Point TensorBoard to the parent directory of `run_dir` to see all your runs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "sequence_example_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to TFRecord file containing tf.SequenceExample records for training or evaluation. A filepattern may also be provided, which will be expanded to all matching files.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "num_training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The the number of global training steps your model should take before exiting training. Leave as 0 to run until terminated manually.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_44": {
                "name": {
                    "value": "num_eval_examples",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of evaluation examples your model should process for each evaluation step.Leave as 0 to use the entire evaluation set.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_48": {
                "name": {
                    "value": "summary_frequency",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "A summary statement will be logged every `summary_frequency` steps during training or every `summary_frequency` seconds during evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_53": {
                "name": {
                    "value": "num_checkpoints",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of most recent checkpoints to keep in the training directory. Keeps all if 0.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_59": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_74": {
                "variable": {
                    "value": "sequence_example_file_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "os.path.expanduser(FLAGS.sequence_example_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_65": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_87": {
                "msg": {
                    "value": "Train dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_108": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_109": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_68": {
                "msg": {
                    "value": "--run_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_71": {
                "msg": {
                    "value": "--sequence_example_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_86": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_93": {
                "msg": {
                    "value": "Eval dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_92": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/music_vae/base_model.py": {
        "tensorflow": {
            "get_or_create_global_step_153": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_189": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(sequence)",
                            "Call"
                        ],
                        [
                            "tf.concat([sequence, control_sequence], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_195": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "encoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder.encode(sequence, sequence_length)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "z_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hparams.z_size",
                            "Attribute"
                        ]
                    ]
                },
                "name": {
                    "value": "encoder/mu",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.001)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dense_200": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "encoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder.encode(sequence, sequence_length)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "z_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hparams.z_size",
                            "Attribute"
                        ]
                    ]
                },
                "activation": {
                    "value": "tf.nn.softplus",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "encoder/sigma",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.001)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_215": {
                "variable": {
                    "value": "input_sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(input_sequence)",
                            "Call"
                        ],
                        [
                            "input_sequence[:, :max_seq_len]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "to_float_216": {
                "variable": {
                    "value": "output_sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(output_sequence)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_218": {
                "variable": {
                    "value": "max_seq_len",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(output_sequence)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "hparams.max_seq_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pad_233": {
                "variable": {
                    "value": "x_input",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output_sequence[:, :max_seq_len - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[(0, 0), (1, 0), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "minimum_235": {
                "variable": {
                    "value": "x_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "max_seq_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(tf.shape(output_sequence)[1], hparams.max_seq_len)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_258": {
                "variable": {
                    "value": "kl_cost",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kl_div - free_nats",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_298": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(hparams.learning_rate - hparams.min_learning_rate) * tf.pow(hparams.decay_rate, tf.to_float(self.global_step)) + hparams.min_learning_rate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_150": {
                "msg": {
                    "value": "Building MusicVAE model with %s, %s, and hparams:\\n%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.encoder.__class__.__name__",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.decoder.__class__.__name__",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_191": {
                "variable": {
                    "value": "control_sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "control_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(control_sequence)",
                            "Call"
                        ],
                        [
                            "tf.to_float(control_sequence)",
                            "Call"
                        ],
                        [
                            "control_sequence[:, :max_seq_len]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_192": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sequence, control_sequence]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_float_224": {
                "variable": {
                    "value": "control_sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "control_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(control_sequence)",
                            "Call"
                        ],
                        [
                            "tf.to_float(control_sequence)",
                            "Call"
                        ],
                        [
                            "control_sequence[:, :max_seq_len]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_251": {
                "variable": {
                    "value": "kl_div",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_300": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(hparams.learning_rate - hparams.min_learning_rate) * tf.pow(hparams.decay_rate, tf.to_float(self.global_step)) + hparams.min_learning_rate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mean_324": {
                "variable": {
                    "value": "metric_map[n]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "a": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "log_257": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_mean_262": {
                "input_tensor": {
                    "value": "kl_cost",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(kl_div - free_nats, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_302": {
                "name": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(t)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_330": {
                "name": {
                    "value": "metric_name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "metric_value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_342": {
                "msg": {
                    "value": "Sampling from conditional model without `z`. Using random `z`.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_normal_initializer_199": {
                "stddev": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_205": {
                "stddev": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "shape_218": {
                "input": {
                    "value": "output_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(output_sequence)",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_260": {
                "x": {
                    "value": "hparams.beta_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(self.global_step)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_268": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "pow_295": {
                "x": {
                    "value": "hparams.decay_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.to_float(self.global_step)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_302": {
                "input_tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_260": {
                "x": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_295": {
                "x": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_346": {
                "shape": {
                    "value": "normal_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[n, self.hparams.z_size]",
                            "List"
                        ]
                    ]
                }
            },
            "ones_346": {
                "shape": {
                    "value": "normal_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[n, self.hparams.z_size]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/music_vae/data.py": {
        "tensorflow": {
            "py_function_1772": {
                "variable": {
                    "value": "(inputs, outputs, controls, lengths)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "_convert_and_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[item_scalar]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[converter.input_dtype, converter.output_dtype, converter.control_dtype, tf.int32]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "convert_and_pad",
                    "type": "str",
                    "possible_values": []
                }
            },
            "py_function_180": {
                "variable": {
                    "value": "augmented_note_sequence_scalar",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_augment_str",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[note_sequence_scalar]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "augment",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_1685": {
                "variable": {
                    "value": "filenames",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "examples_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.train_examples_path if is_training else config.eval_examples_path",
                            "IfExp"
                        ]
                    ]
                }
            },
            "info_1705": {
                "msg": {
                    "value": "Total examples: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "num_examples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "num_examples + len(tensors.inputs)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Options_1828": {
                "variable": {
                    "value": "options",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_1817": {
                "msg": {
                    "value": "Reading examples from file: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "examples_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.train_examples_path if is_training else config.eval_examples_path",
                            "IfExp"
                        ]
                    ]
                }
            },
            "do_not_convert_1866": {
                "func": {
                    "value": "functools.partial(convert_to_tensors_op, converter=data_converter)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_1687": {
                "msg": {
                    "value": "Counting examples in %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filenames",
                            "variable"
                        ]
                    ]
                }
            },
            "Glob_1818": {
                "filename": {
                    "value": "examples_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.train_examples_path if is_training else config.eval_examples_path",
                            "IfExp"
                        ]
                    ]
                }
            },
            "info_1832": {
                "msg": {
                    "value": "Reading examples from TFDS: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "config.tfds_name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warning_1079": {
                "msg": {
                    "value": "Skipping invalid instrument number: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(self._slice_steps, len(l) + 1, self._steps_per_bar)",
                            "Call"
                        ],
                        [
                            "range(self._slice_steps, len(l) + 1, self._steps_per_bar)",
                            "Call"
                        ],
                        [
                            "note.instrument",
                            "Attribute"
                        ],
                        [
                            "instruments_by_type[self.InstrumentType.MEL] + instruments_by_type[self.InstrumentType.BASS]",
                            "BinOp"
                        ],
                        [
                            "instruments_by_type[self.InstrumentType.DRUMS]",
                            "Subscript"
                        ],
                        [
                            "range(n_timesteps)",
                            "Call"
                        ]
                    ]
                }
            },
            "py_function_1839": {
                "func": {
                    "value": "lambda x: [note_seq.midi_to_note_sequence(x.numpy()).SerializeToString()]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "inp": {
                    "value": "[ex['midi']]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "midi_to_note_sequence",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_output_shapes_1879": {
                "dataset_or_iterator": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "files.interleave(tf_file_reader, cycle_length=tf.data.experimental.AUTOTUNE, num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.with_options(options)",
                            "Call"
                        ],
                        [
                            "tfds.load(config.tfds_name, split=tfds.Split.TRAIN if is_training else tfds.Split.VALIDATION, shuffle_files=is_training, try_gcs=True)",
                            "Call"
                        ],
                        [
                            "dataset.map(_tf_midi_to_note_sequence, num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.map(note_sequence_augmenter.tf_augment, num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.map(tf.autograph.experimental.do_not_convert(functools.partial(convert_to_tensors_op, converter=data_converter)), num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.unbatch()",
                            "Call"
                        ],
                        [
                            "dataset.map(_remove_pad_fn, num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.cache()",
                            "Call"
                        ],
                        [
                            "dataset.shuffle(buffer_size=10 * batch_size).repeat()",
                            "Call"
                        ],
                        [
                            "dataset.padded_batch(batch_size, tf.data.get_output_shapes(dataset), drop_remainder=True).prefetch(tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_1123": {
                "msg": {
                    "value": "Trio controls disagreement between instruments.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/music_vae/data_hierarchical.py": {
        "tensorflow": {
            "flatten_208": {
                "variable": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "pad_with_element(input_, max_lengths[:-1], data.np_onehot([end_token], input_depth))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_211": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "pad_with_element(output, max_lengths[:-1], data.np_onehot([end_token], output_depth))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "flatten_223": {
                "variable": {
                    "value": "control",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "pad_with_element(control, max_lengths[:-1], data.np_onehot([control_pad_token], control_depth))",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/music_vae/data_hierarchical_test.py": {
        "tensorflow": {
            "disable_v2_behavior_28": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_171": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/music_vae/data_test.py": {
        "tensorflow": {
            "disable_v2_behavior_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "make_one_shot_iterator_1801": {
                "variable": {
                    "value": "it",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "ds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data.get_dataset(config, is_training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "main_1811": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_106": {
                "variable": {
                    "value": "sequence_str",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_170": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_223": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_263": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_308": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_347": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_388": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_435": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_492": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_1383": {
                "msg": {
                    "value": "(n1.pitch, n1.start_time, n1.velocity)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "info_1384": {
                "msg": {
                    "value": "(n2.pitch, n2.start_time, n2.velocity)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/music_vae/lstm_models.py": {
        "tensorflow": {
            "transpose_56": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sequence, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.stack(embeddings, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dynamic_rnn_57": {
                "variable": {
                    "value": "(outputs, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "self._cell",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sequence, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.stack(embeddings, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_utils.maybe_split_sequence_lengths(sequence_length, np.prod(self._level_lengths[1:]), self._total_length)",
                            "Call"
                        ],
                        [
                            "tf.fill([batch_size, num_splits], split_seqs[0].shape[1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scope": {
                    "value": "self._name_or_scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_229": {
                "variable": {
                    "value": "self._output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "output_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_projection",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_329": {
                "variable": {
                    "value": "repeated_z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(z, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(x_input)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_static_value_336": {
                "variable": {
                    "value": "sampling_probability_static",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self._sampling_probability",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_368": {
                "variable": {
                    "value": "cum_x_len",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[(0,), tf.cumsum(x_length)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_373": {
                "variable": {
                    "value": "r_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "r_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "concat_417": {
                "variable": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[start_inputs, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_504": {
                "variable": {
                    "value": "preprocessed_c_input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self._preprocess_controls(tf.expand_dims(c_input, axis=0), tf.reshape(max_length, [1]))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_517": {
                "variable": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_518": {
                "variable": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flat_logits >= 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_519": {
                "variable": {
                    "value": "r_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "flat_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_rnn_output",
                            "variable"
                        ],
                        [
                            "flat_rnn_output",
                            "variable"
                        ]
                    ]
                }
            },
            "argmax_539": {
                "variable": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_540": {
                "variable": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flat_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_rnn_output",
                            "variable"
                        ],
                        [
                            "flat_rnn_output",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_541": {
                "variable": {
                    "value": "r_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "flat_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_rnn_output",
                            "variable"
                        ],
                        [
                            "flat_rnn_output",
                            "variable"
                        ]
                    ]
                }
            },
            "split_613": {
                "variable": {
                    "value": "split_x_target",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._output_depths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_614": {
                "variable": {
                    "value": "split_rnn_output",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "flat_rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(decode_results.rnn_output, x_length)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._output_depths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_630": {
                "variable": {
                    "value": "split_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.concat(zipped_results.rnn_output, axis=time_axis)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._output_depths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_712": {
                "variable": {
                    "value": "split_x_input",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x_input, repeated_z, c_input], axis=2)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._output_depths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_713": {
                "variable": {
                    "value": "split_x_target",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x_target",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "self._output_depths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Dense_785": {
                "variable": {
                    "value": "self._output_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._nade.num_hidden + output_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "output_projection",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_789": {
                "variable": {
                    "value": "(b_enc, b_dec)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "flat_rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(decode_results.rnn_output, x_length)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[self._nade.num_hidden, self._output_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_795": {
                "variable": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_equal_796": {
                "variable": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "cond_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "split_812": {
                "variable": {
                    "value": "(b_enc, b_dec)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.concat(zipped_results.rnn_output, axis=time_axis)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[self._nade.num_hidden, self._output_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_1005": {
                "variable": {
                    "value": "hier_t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "hier_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size] + level_lengths",
                            "BinOp"
                        ],
                        [
                            "hier_shape + ([-1] + t_shape[2:])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_1187": {
                "variable": {
                    "value": "all_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.pad(s, [(0, 0), (0, core_max_length - tf.shape(s)[1]), (0, 0)]) for s in all_samples]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_1225": {
                "variable": {
                    "value": "(output_hits, output_velocities, output_offsets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "flat_rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(decode_results.rnn_output, x_length)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_1228": {
                "variable": {
                    "value": "output_hits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_hits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(output_hits)",
                            "Call"
                        ],
                        [
                            "hits_sampler.sample()",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_1229": {
                "variable": {
                    "value": "output_velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(output_velocities)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output_velocities)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_1230": {
                "variable": {
                    "value": "output_offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.tanh(output_offsets)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(output_offsets)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_1237": {
                "variable": {
                    "value": "(target_hits, target_velocities, target_offsets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "flat_x_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(x_target, x_length)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1243": {
                "variable": {
                    "value": "hits_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.log_loss(labels=target_hits, predictions=output_hits, reduction=tf.losses.Reduction.NONE)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1247": {
                "variable": {
                    "value": "velocities_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.mean_squared_error(target_velocities, output_velocities, reduction=tf.losses.Reduction.NONE)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_1251": {
                "variable": {
                    "value": "offsets_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.losses.mean_squared_error(target_offsets, output_offsets, reduction=tf.losses.Reduction.NONE)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_1269": {
                "variable": {
                    "value": "(output_hits, output_velocities, output_offsets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "rnn_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.concat(zipped_results.rnn_output, axis=time_axis)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_1272": {
                "variable": {
                    "value": "output_velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(output_velocities)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output_velocities)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_1273": {
                "variable": {
                    "value": "output_offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output_offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.tanh(output_offsets)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(output_offsets)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_47": {
                "msg": {
                    "value": "\\nEncoder Cells (unidirectional):\\n  units: %s\\n",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.enc_rnn_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_76": {
                "msg": {
                    "value": "\\nEncoder Cells (bidirectional):\\n  units: %s\\n",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.enc_rnn_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_102": {
                "values": {
                    "value": "[last_h_fw, last_h_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "info_146": {
                "msg": {
                    "value": "\\nHierarchical Encoder:\\n  input length: %d\\n  level lengths: %s\\n",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self._total_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self._level_lengths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_190": {
                "variable": {
                    "value": "split_seqs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sequence, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.stack(embeddings, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(np.prod(self._level_lengths))",
                            "Call"
                        ],
                        [
                            "num_splits // l",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_196": {
                "variable": {
                    "value": "split_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_utils.maybe_split_sequence_lengths(sequence_length, np.prod(self._level_lengths[1:]), self._total_length)",
                            "Call"
                        ],
                        [
                            "tf.fill([batch_size, num_splits], split_seqs[0].shape[1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_199": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[h_encoder.encode(s, l) for (s, l) in zip(split_seqs, split_lengths)]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "info_222": {
                "msg": {
                    "value": "\\nDecoder Cells:\\n  units: %s\\n",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.dec_rnn_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_334": {
                "variable": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, tf.shape(x_input)[1], 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_340": {
                "variable": {
                    "value": "x_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x_input, repeated_z, c_input]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_411": {
                "variable": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(c_input, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, n, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_415": {
                "variable": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n, self._output_depth]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_419": {
                "variable": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[start_inputs, c_input[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_428": {
                "variable": {
                    "value": "next_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sample_ids, z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "info_467": {
                "msg": {
                    "value": "\\nControl Preprocessing Cells (bidirectional):\\n  units: %s\\n",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.control_preprocessing_rnn_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_637": {
                "values": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "decode_results.rnn_input[:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(samples, [(0, 0), (0, split_size - tf.shape(samples)[1]), (0, 0)])",
                            "Call"
                        ],
                        [
                            "lstm_utils.set_final(samples, split_length, lstm_utils.get_final(split_target, split_length, time_major=False), time_major=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_structure_670": {
                "func": {
                    "value": "lambda *x: sum(x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "*(cd.state_size for cd in self._core_decoders)",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "split_757": {
                "variable": {
                    "value": "split_start_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "start_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([n, self._output_depth], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([start_inputs, z], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([start_inputs, c_input[0]], axis=-1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._output_depths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "info_894": {
                "msg": {
                    "value": "\\nHierarchical Decoder:\\n  input length: %d\\n  level output lengths: %s\\n",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self._total_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self._level_lengths",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_924": {
                "variable": {
                    "value": "rnn_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "zipped_results.rnn_output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "time_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "concat_925": {
                "variable": {
                    "value": "rnn_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "zipped_results.rnn_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "time_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "VariableScope_952": {
                "variable": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "'decoder/hierarchical_level_%d' % level",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_1010": {
                "a": {
                    "value": "hier_t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(t, hier_shape)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(range(len(hier_shape)))",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_1158": {
                "variable": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self._reshape_to_hierarchy(tf.expand_dims(c_input, 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "len(self._level_lengths) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_1279": {
                "values": {
                    "value": "[output_hits, output_velocities, output_offsets]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "warning_42": {
                "msg": {
                    "value": "cuDNN LSTM no longer supported. Using regular LSTM.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_74": {
                "msg": {
                    "value": "cuDNN LSTM no longer supported. Using regular LSTM.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_155": {
                "msg": {
                    "value": "Level %d splits: %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "range(len(self._output_depths))",
                            "Call"
                        ],
                        [
                            "range(num_steps)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "num_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(np.prod(self._level_lengths))",
                            "Call"
                        ],
                        [
                            "num_splits // l",
                            "BinOp"
                        ]
                    ]
                }
            },
            "fill_194": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "[batch_size, num_splits]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "split_seqs[0].shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "control_dependencies_201": {
                "control_inputs": {
                    "value": "[tf.assert_equal(tf.shape(sequence)[1], 1)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "warning_218": {
                "msg": {
                    "value": "cuDNN LSTM no longer supported. Using regular LSTM.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_328": {
                "shape": {
                    "value": "[batch_size, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_330": {
                "input": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, 0]) if z is None else z",
                            "IfExp"
                        ],
                        [
                            "tf.zeros((n, 0), tf.float32) if z is None else z",
                            "IfExp"
                        ],
                        [
                            "tf.zeros([batch_size, 0]) if z is None else z",
                            "IfExp"
                        ],
                        [
                            "tf.zeros([n, 0]) if z is None else z",
                            "IfExp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_345": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, tf.shape(x_input)[1], 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_407": {
                "shape": {
                    "value": "(n, 0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_431": {
                "variable": {
                    "value": "finished",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(time, tf.shape(c_input)[0] - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : finished",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : True",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_434": {
                "variable": {
                    "value": "next_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[next_inputs, tf.cond(tf.less(time, tf.shape(c_input)[0] - 1), lambda : c_input[time + 1], lambda : tf.zeros_like(c_input[0]))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "warning_465": {
                "msg": {
                    "value": "cuDNN LSTM no longer supported. Using regular LSTM.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "accuracy_524": {
                "labels": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(flat_x_target, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_logits >= 0, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.greater_equal(cond_probs, 0.5)",
                            "Call"
                        ]
                    ]
                }
            },
            "accuracy_546": {
                "labels": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(flat_x_target, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_logits >= 0, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.greater_equal(cond_probs, 0.5)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_per_class_accuracy_548": {
                "labels": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(flat_x_target, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_logits >= 0, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.greater_equal(cond_probs, 0.5)",
                            "Call"
                        ]
                    ]
                },
                "num_classes": {
                    "value": "int(flat_x_target.shape[-1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_627": {
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_690": {
                "control_inputs": {
                    "value": "[tf.assert_equal(zipped_results.final_sequence_lengths, self.hparams.max_seq_len, message='Variable length not supported by MultiOutCategoricalLstmDecoder.')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_structure_698": {
                "variable": {
                    "value": "final_state",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: tf.concat(x, axis=output_axis)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "zipped_results.final_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_737": {
                "input_tensor": {
                    "value": "r_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_772": {
                "values": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mean_800": {
                "a": {
                    "value": "tf.reduce_all(tf.equal(flat_truth, flat_predictions), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "recall_803": {
                "labels": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(flat_x_target, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_logits >= 0, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.greater_equal(cond_probs, 0.5)",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_805": {
                "labels": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(flat_x_target, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_logits >= 0, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.greater_equal(cond_probs, 0.5)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_908": {
                "name_or_scope": {
                    "value": "core_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_968": {
                "variable": {
                    "value": "next_input",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, input_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_1076": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "decode_results.rnn_input[:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(samples, [(0, 0), (0, split_size - tf.shape(samples)[1]), (0, 0)])",
                            "Call"
                        ],
                        [
                            "lstm_utils.set_final(samples, split_length, lstm_utils.get_final(split_target, split_length, time_major=False), time_major=False)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, 0), (0, split_size - tf.shape(samples)[1]), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_1096": {
                "shape": {
                    "value": "[batch_size, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_1113": {
                "input_tensor": {
                    "value": "r_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_1142": {
                "shape": {
                    "value": "[n, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_1154": {
                "variable": {
                    "value": "max_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "max_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(max_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_loss_1243": {
                "labels": {
                    "value": "target_hits",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "output_hits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(output_hits)",
                            "Call"
                        ],
                        [
                            "hits_sampler.sample()",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "tf.losses.Reduction.NONE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_squared_error_1247": {
                "y_true": {
                    "value": "target_velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "output_velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sigmoid(output_velocities)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output_velocities)",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "tf.losses.Reduction.NONE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_squared_error_1251": {
                "y_true": {
                    "value": "target_offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "output_offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.tanh(output_offsets)",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(output_offsets)",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "tf.losses.Reduction.NONE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mean_1259": {
                "a": {
                    "value": "hits_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.losses.log_loss(labels=target_hits, predictions=output_hits, reduction=tf.losses.Reduction.NONE), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_1261": {
                "a": {
                    "value": "velocities_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.losses.mean_squared_error(target_velocities, output_velocities, reduction=tf.losses.Reduction.NONE), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_1263": {
                "a": {
                    "value": "offsets_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.losses.mean_squared_error(target_offsets, output_offsets, reduction=tf.losses.Reduction.NONE), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_347": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[auxiliary_inputs, repeated_z]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_349": {
                "variable": {
                    "value": "auxiliary_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[auxiliary_inputs, c_input]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cumsum_368": {
                "x": {
                    "value": "x_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_utils.maybe_split_sequence_lengths(x_length, np.prod(self._level_lengths[:-1]), self._total_length)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_372": {
                "input_tensor": {
                    "value": "r_loss[b:e]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_411": {
                "input": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, tf.shape(x_input)[1], 0])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(c_input, 1), [1, n, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(self._reshape_to_hierarchy(tf.expand_dims(c_input, 0)), axis=len(self._level_lengths) - 1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_420": {
                "shape": {
                    "value": "[n]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_505": {
                "input": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, tf.shape(x_input)[1], 0])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(c_input, 1), [1, n, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(self._reshape_to_hierarchy(tf.expand_dims(c_input, 0)), axis=len(self._level_lengths) - 1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_506": {
                "tensor": {
                    "value": "max_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(max_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_583": {
                "x": {
                    "value": "tf.argmax(x, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "end_token",
                    "type": "variable",
                    "possible_values": [
                        [
                            "end_fn",
                            "variable"
                        ]
                    ]
                }
            },
            "one_hot_636": {
                "indices": {
                    "value": "sample_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sampler.sample()",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "output_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_682": {
                "name_or_scope": {
                    "value": "'core_decoder_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_718": {
                "name_or_scope": {
                    "value": "'core_decoder_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_735": {
                "input_tensor": {
                    "value": "metric_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "no_op_735": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_761": {
                "name_or_scope": {
                    "value": "'core_decoder_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_all_801": {
                "input_tensor": {
                    "value": "tf.equal(flat_truth, flat_predictions)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_929": {
                "values": {
                    "value": "zipped_results.samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "time_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "stack_931": {
                "values": {
                    "value": "zipped_results.final_sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "time_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "variable_scope_955": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.VariableScope(tf.AUTO_REUSE, 'decoder/hierarchical_level_%d' % level)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_972": {
                "variable": {
                    "value": "next_input",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_974": {
                "variable": {
                    "value": "next_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[next_input, initial_input]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_988": {
                "values": {
                    "value": "tf.nest.flatten(state)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_1111": {
                "input_tensor": {
                    "value": "metric_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "no_op_1111": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_1149": {
                "control_inputs": {
                    "value": "[tf.assert_equal(max_length, self._total_length, message='`max_length` must equal `hparams.max_seq_len` if given.')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_1182": {
                "values": {
                    "value": "tf.nest.flatten(decode_results.final_state)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pad_1188": {
                "tensor": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[(0, 0), (0, core_max_length - tf.shape(s)[1]), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "VariableScope_159": {
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "'encoder/hierarchical_level_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assert_equal_201": {
                "x": {
                    "value": "tf.shape(sequence)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_330": {
                "input": {
                    "value": "x_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x_input, repeated_z, c_input], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_431": {
                "x": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.shape(c_input)[0] - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_583": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "assert_equal_691": {
                "x": {
                    "value": "zipped_results.final_sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.hparams.max_seq_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "message": {
                    "value": "Variable length not supported by MultiOutCategoricalLstmDecoder.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_703": {
                "values": {
                    "value": "zipped_results.rnn_output",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "output_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "concat_704": {
                "values": {
                    "value": "zipped_results.rnn_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "output_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "concat_705": {
                "values": {
                    "value": "zipped_results.samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "output_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "equal_801": {
                "x": {
                    "value": "flat_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_x_target, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.cast(flat_x_target, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "flat_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(flat_logits >= 0, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(flat_logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.greater_equal(cond_probs, 0.5)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_949": {
                "name_or_scope": {
                    "value": "core_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_975": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.VariableScope(tf.AUTO_REUSE, 'decoder/hierarchical_level_%d' % level)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_988": {
                "structure": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_utils.initial_cell_state_from_embedding(self._hier_cells[level], initial_input, name='initial_state')",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1094": {
                "values": {
                    "value": "tf.nest.flatten(decode_results.final_state)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_1159": {
                "input": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, tf.shape(x_input)[1], 0])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(c_input, 1), [1, n, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(self._reshape_to_hierarchy(tf.expand_dims(c_input, 0)), axis=len(self._level_lengths) - 1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_1182": {
                "structure": {
                    "value": "decode_results.final_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_334": {
                "input": {
                    "value": "x_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x_input, repeated_z, c_input], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_436": {
                "pred": {
                    "value": "tf.less(time, tf.shape(c_input)[0] - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : c_input[time + 1]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.zeros_like(c_input[0])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_699": {
                "values": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "output_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "stack_984": {
                "values": {
                    "value": "lower_level_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "fill_985": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._level_lengths[level]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "flatten_1094": {
                "structure": {
                    "value": "decode_results.final_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assert_equal_1150": {
                "x": {
                    "value": "max_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(max_length)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "self._total_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "message": {
                    "value": "`max_length` must equal `hparams.max_seq_len` if given.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_201": {
                "input": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sequence, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.stack(embeddings, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_345": {
                "input": {
                    "value": "x_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x_input, repeated_z, c_input], axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_436": {
                "x": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.shape(c_input)[0] - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "flatten_964": {
                "structure": {
                    "value": "self._core_decoder.state_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_967": {
                "structure": {
                    "value": "self._hier_cells[level + 1].state_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_431": {
                "input": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, tf.shape(x_input)[1], 0])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(c_input, 1), [1, n, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(self._reshape_to_hierarchy(tf.expand_dims(c_input, 0)), axis=len(self._level_lengths) - 1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_like_438": {
                "input": {
                    "value": "c_input[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_1078": {
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "decode_results.rnn_input[:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(samples, [(0, 0), (0, split_size - tf.shape(samples)[1]), (0, 0)])",
                            "Call"
                        ],
                        [
                            "lstm_utils.set_final(samples, split_length, lstm_utils.get_final(split_target, split_length, time_major=False), time_major=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_1188": {
                "input": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_436": {
                "input": {
                    "value": "c_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([batch_size, tf.shape(x_input)[1], 0])",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(c_input, 1), [1, n, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(self._reshape_to_hierarchy(tf.expand_dims(c_input, 0)), axis=len(self._level_lengths) - 1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/music_vae/lstm_utils.py": {
        "tensorflow": {
            "sequence_mask_76": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "tf.maximum(0, sequence_length - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "sequence_batch_major.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_90": {
                "variable": {
                    "value": "flat_state_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "cell.state_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_145": {
                "variable": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_62": {
                "values": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.maximum(0, sequence_length - 1), tf.range(sequence_length.shape[0])]",
                            "List"
                        ],
                        [
                            "indices[-1::-1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_nd_68": {
                "params": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "final_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_get_final_index(sequence_length, time_major)",
                            "Call"
                        ],
                        [
                            "_get_final_index(sequence_length, time_major=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "pack_sequence_as_91": {
                "structure": {
                    "value": "cell.zero_state(batch_size=z.shape[0], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "tf.split(tf.layers.dense(z, sum(flat_state_sizes), activation=tf.tanh, kernel_initializer=tf.random_normal_initializer(stddev=0.001), name=name), flat_state_sizes, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_152": {
                "variable": {
                    "value": "sampling_probability",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hparams.sampling_rate",
                            "Attribute"
                        ]
                    ]
                }
            },
            "scalar_168": {
                "name": {
                    "value": "sampling_probability",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "sampling_probability",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(rate)",
                            "Call"
                        ],
                        [
                            "1.0 - k / (k + tf.exp(step / k))",
                            "BinOp"
                        ],
                        [
                            "1.0 - tf.pow(k, step)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "maximum_58": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "sequence_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_74": {
                "a": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "maximum_77": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "y": {
                    "value": "sequence_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scatter_nd_82": {
                "indices": {
                    "value": "final_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_get_final_index(sequence_length, time_major)",
                            "Call"
                        ],
                        [
                            "_get_final_index(sequence_length, time_major=False)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(sequence_batch_major)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_84": {
                "a": {
                    "value": "sequence_batch_major",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence if not time_major else tf.transpose(sequence, [1, 0, 2])",
                            "IfExp"
                        ],
                        [
                            "tf.expand_dims(mask, axis=-1) * sequence_batch_major + tf.scatter_nd(final_index, values, tf.shape(sequence_batch_major))",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_93": {
                "value": {
                    "value": "tf.layers.dense(z, sum(flat_state_sizes), activation=tf.tanh, kernel_initializer=tf.random_normal_initializer(stddev=0.001), name=name)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "flat_state_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(cell.state_size)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_132": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "warning_137": {
                "msg": {
                    "value": "Setting non-training sampling schedule from %s:%f to constant:1.0.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.sampling_schedule",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "hparams.sampling_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_global_step_145": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_157": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hparams.sampling_rate",
                            "Attribute"
                        ]
                    ]
                }
            },
            "expand_dims_81": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.maximum(0, sequence_length - 1), maxlen=sequence_batch_major.shape[1], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_82": {
                "input": {
                    "value": "sequence_batch_major",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sequence if not time_major else tf.transpose(sequence, [1, 0, 2])",
                            "IfExp"
                        ],
                        [
                            "tf.expand_dims(mask, axis=-1) * sequence_batch_major + tf.scatter_nd(final_index, values, tf.shape(sequence_batch_major))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "dense_94": {
                "inputs": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "sum(flat_state_sizes)",
                    "type": "Call",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.001)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_164": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hparams.sampling_rate",
                            "Attribute"
                        ]
                    ]
                }
            },
            "map_structure_206": {
                "func": {
                    "value": "lambda _: dtype",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "self._rnn_output_size()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_244": {
                "control_inputs": {
                    "value": "[tf.Assert(tf.reduce_all(tf.logical_or(tf.equal(sequence_length, 0), tf.equal(sequence_length, total_length))), data=[sequence_length])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_260": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sequence_length, axis=1), [1, num_splits]) // num_splits",
                            "BinOp"
                        ],
                        [
                            "tf.identity(sequence_length)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_203": {
                "structure": {
                    "value": "self._initial_state",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_251": {
                "input": {
                    "value": "tf.expand_dims(sequence_length, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, num_splits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_254": {
                "control_inputs": {
                    "value": "[tf.assert_less_equal(sequence_length, tf.constant(total_length // num_splits, tf.int32), message='Segment length cannot be more than `total_length / num_splits`.')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_normal_initializer_98": {
                "stddev": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "pow_165": {
                "x": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(rate)",
                            "Call"
                        ],
                        [
                            "tf.to_float(rate)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.train.get_global_step())",
                            "Call"
                        ]
                    ]
                }
            },
            "Assert_245": {
                "condition": {
                    "value": "tf.reduce_all(tf.logical_or(tf.equal(sequence_length, 0), tf.equal(sequence_length, total_length)))",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "[sequence_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_251": {
                "input": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sequence_length, axis=1), [1, num_splits]) // num_splits",
                            "BinOp"
                        ],
                        [
                            "tf.identity(sequence_length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_158": {
                "x": {
                    "value": "step / k",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_all_246": {
                "input_tensor": {
                    "value": "tf.logical_or(tf.equal(sequence_length, 0), tf.equal(sequence_length, total_length))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assert_less_equal_255": {
                "x": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sequence_length, axis=1), [1, num_splits]) // num_splits",
                            "BinOp"
                        ],
                        [
                            "tf.identity(sequence_length)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.constant(total_length // num_splits, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "message": {
                    "value": "Segment length cannot be more than `total_length / num_splits`.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "logical_or_247": {
                "x": {
                    "value": "tf.equal(sequence_length, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(sequence_length, total_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_257": {
                "value": {
                    "value": "total_length // num_splits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_247": {
                "x": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sequence_length, axis=1), [1, num_splits]) // num_splits",
                            "BinOp"
                        ],
                        [
                            "tf.identity(sequence_length)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_248": {
                "x": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(sequence_length, axis=1), [1, num_splits]) // num_splits",
                            "BinOp"
                        ],
                        [
                            "tf.identity(sequence_length)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "total_length",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/music_vae/lstm_utils_test.py": {
        "tensorflow": {
            "disable_v2_behavior_20": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_104": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_71": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[8, 0, 8]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_91": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[8, 0, 7]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_86": {
                "value": {
                    "value": "presplit_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([[0, 2, 1, 2], [0, 0, 0, 0], [1, 1, 1, 1]], np.int32)",
                            "Call"
                        ],
                        [
                            "np.array([[0, 2, 3, 1], [0, 0, 0, 0], [1, 1, 1, 1]], np.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_101": {
                "value": {
                    "value": "presplit_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([[0, 2, 1, 2], [0, 0, 0, 0], [1, 1, 1, 1]], np.int32)",
                            "Call"
                        ],
                        [
                            "np.array([[0, 2, 3, 1], [0, 0, 0, 0], [1, 1, 1, 1]], np.int32)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/music_vae/music_vae_generate.py": {
        "tensorflow": {
            "MakeDirs_99": {
                "dirname": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_192": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_193": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/music_vae/music_vae_train.py": {
        "tensorflow": {
            "text_89": {
                "variable": {
                    "value": "examples_path_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "examples_path",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.constant(examples_path, name='examples_path')",
                    "type": "Call",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "text_101": {
                "variable": {
                    "value": "hparam_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.constant(hparams_table, name='hparams')",
                    "type": "Call",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "make_one_shot_iterator_114": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "FileWriter_105": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_147": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_220": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval' + FLAGS.eval_dir_suffix)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_329": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_334": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_335": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_90": {
                "value": {
                    "value": "examples_path",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "examples_path",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_102": {
                "value": {
                    "value": "hparams_table",
                    "type": "variable",
                    "possible_values": [
                        [
                            "header + '\\n'.join(lines) + '\\n'",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_104": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_153": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_norm_172": {
                "variable": {
                    "value": "global_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Scaffold_199": {
                "variable": {
                    "value": "scaffold",
                    "type": "variable",
                    "possible_values": []
                },
                "saver": {
                    "value": "tf.train.Saver(max_to_keep=checkpoints_to_keep, keep_checkpoint_every_n_hours=keep_checkpoint_every_n_hours)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_224": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_154": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(num_ps_tasks, merge_devices=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "SyncReplicasOptimizer_166": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.train(**_get_input_tensors(dataset_fn(), config))",
                            "Call"
                        ],
                        [
                            "tf.train.SyncReplicasOptimizer(optimizer, num_sync_workers)",
                            "Call"
                        ]
                    ]
                },
                "replicas_to_aggregate": {
                    "value": "num_sync_workers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_173": {
                "name": {
                    "value": "global_norm",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "global_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.global_norm(grads)",
                            "Call"
                        ]
                    ]
                }
            },
            "replica_device_setter_154": {
                "ps_tasks": {
                    "value": "num_ps_tasks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                },
                "merge_devices": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cond_179": {
                "variable": {
                    "value": "clipped_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "global_norm < config.hparams.grad_norm_clip_to_zero",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.clip_by_global_norm(grads, config.hparams.grad_clip, use_norm=global_norm)[0]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : [tf.zeros(tf.shape(g)) for g in grads]",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "LoggingTensorHook_195": {
                "tensors": {
                    "value": "logging_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'global_step': model.global_step, 'loss': model.loss}",
                            "Dict"
                        ]
                    ]
                },
                "every_n_iter": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_177": {
                "t": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-g",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.hparams.grad_clip",
                            "Attribute"
                        ]
                    ]
                }
            },
            "StopAtStepHook_197": {
                "last_step": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Saver_200": {
                "max_to_keep": {
                    "value": "checkpoints_to_keep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "5",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "keep_checkpoint_every_n_hours",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "clip_by_global_norm_181": {
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "config.hparams.grad_clip",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_norm": {
                    "value": "global_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.global_norm(grads)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_183": {
                "shape": {
                    "value": "tf.shape(g)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_183": {
                "input": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.hparams.grad_clip",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/music_vae/trained_model.py": {
        "tensorflow": {
            "IsDirectory_54": {
                "dirname": {
                    "value": "checkpoint_dir_or_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "latest_checkpoint_55": {
                "variable": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir_or_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_68": {
                "variable": {
                    "value": "self._temperature",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_82": {
                "variable": {
                    "value": "self._inputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, None, self._config.data_converter.input_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "self._controls",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, None, self._config.data_converter.control_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_88": {
                "variable": {
                    "value": "self._inputs_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size] + list(self._config.data_converter.length_shape)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_91": {
                "variable": {
                    "value": "self._max_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Session_118": {
                "variable": {
                    "value": "self._sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "target": {
                    "value": "session_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "''",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Saver_119": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "var_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                }
            },
            "Graph_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_71": {
                "variable": {
                    "value": "self._z_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, self._config.hparams.z_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_77": {
                "variable": {
                    "value": "self._c_input",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, self._config.data_converter.control_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "global_variables_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_122": {
                "msg": {
                    "value": "Unbundling checkpoint.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_114": {
                "msg": {
                    "value": "Renaming `%s` to `%s`.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "v.name[:-2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "v.name[:-2]",
                            "Subscript"
                        ],
                        [
                            "re.sub(pattern, substitution, var_name)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/nsynth/baseline/models/ae.py": {
        "tensorflow": {
            "expand_dims_124": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ],
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_134": {
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ],
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "add_to_collection_135": {
                "name": {
                    "value": "pitch",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "batch['pitch']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_to_collection_136": {
                "name": {
                    "value": "z",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.encode(x, hparams)",
                            "Call"
                        ],
                        [
                            "config.encode(x, hparams, is_training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_137": {
                "name": {
                    "value": "xhat",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "xhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.decode(z, batch, hparams)",
                            "Call"
                        ],
                        [
                            "config.decode(z, batch, hparams, is_training=False)",
                            "Call"
                        ],
                        [
                            "config.decode(z, batch, hparams, reuse=True, is_training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_144": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "AdamOptimizer_149": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "hparams.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta1": {
                    "value": "hparams.adam_beta",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_174": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ],
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_184": {
                "name": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ],
                        [
                            "batch['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(x, 1), -1)",
                            "Call"
                        ],
                        [
                            "batch['spectrogram']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "add_to_collection_185": {
                "name": {
                    "value": "pitch",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "batch['pitch']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "add_to_collection_186": {
                "name": {
                    "value": "z",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.encode(x, hparams)",
                            "Call"
                        ],
                        [
                            "config.encode(x, hparams, is_training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_187": {
                "name": {
                    "value": "xhat",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "xhat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.decode(z, batch, hparams)",
                            "Call"
                        ],
                        [
                            "config.decode(z, batch, hparams, is_training=False)",
                            "Call"
                        ],
                        [
                            "config.decode(z, batch, hparams, reuse=True, is_training=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_205": {
                "variable": {
                    "value": "z_shift_one_example",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z[1:], z[:1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_212": {
                "variable": {
                    "value": "pitch_plus_2",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "batch['pitch'] + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "127",
                    "type": "int",
                    "possible_values": []
                }
            },
            "clip_by_value_213": {
                "variable": {
                    "value": "pitch_minus_2",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "batch['pitch'] - 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "127",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_78": {
                "name": {
                    "value": "Losses",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_80": {
                "variable": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(x - xhat) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_88": {
                "variable": {
                    "value": "mag_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "fm * (x[:, :, :, 0] - xhat[:, :, :, 0]) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_104": {
                "name": {
                    "value": "Loss/Total",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "total_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean((x - xhat) ** 2)",
                            "Call"
                        ],
                        [
                            "mag_loss",
                            "variable"
                        ],
                        [
                            "mag_loss + hparams.phase_loss_coeff * phase_loss",
                            "BinOp"
                        ],
                        [
                            "compute_mse_loss(x, xhat, hparams)",
                            "Call"
                        ],
                        [
                            "compute_mse_loss(x, xhat, hparams)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_129": {
                "name": {
                    "value": "Model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_143": {
                "name": {
                    "value": "Optimizer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_179": {
                "name": {
                    "value": "Model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_201": {
                "name": {
                    "value": "Interpolation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_94": {
                "variable": {
                    "value": "phase_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "fm * m * (x[:, :, :, 1] - xhat[:, :, :, 1]) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "scalar_102": {
                "name": {
                    "value": "Loss/Mag",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "mag_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(fm * (x[:, :, :, 0] - xhat[:, :, :, 0]) ** 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_103": {
                "name": {
                    "value": "Loss/Phase",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "phase_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(fm * m * (x[:, :, :, 1] - xhat[:, :, :, 1]) ** 2)",
                            "Call"
                        ],
                        [
                            "1 - tf.reduce_mean(fm * m * tf.cos((x[:, :, :, 1] - xhat[:, :, :, 1]) * np.pi))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_147": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_99": {
                "input_tensor": {
                    "value": "fm * m * tf.cos((x[:, :, :, 1] - xhat[:, :, :, 1]) * np.pi)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cos_99": {
                "x": {
                    "value": "(x[:, :, :, 1] - xhat[:, :, :, 1]) * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/baseline/models/ae_configs/nfft_1024.py": {
        "tensorflow": {
            "concat_146": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z, z_pitch]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_46": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_144": {
                "name_or_scope": {
                    "value": "decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/nsynth/baseline/save_embeddings.py": {
        "tensorflow": {
            "DEFINE_string_27": {
                "name": {
                    "value": "master",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "BNS name of the TensorFlow master to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_29": {
                "name": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "ae",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Which model to use in models/",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_30": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "nfft_1024",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Which model to use in configs/",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_32": {
                "name": {
                    "value": "expdir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The log directory for this experiment. Required if`checkpoint_path` is not given.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "checkpoint_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A path to the checkpoint. If not given, the latest checkpoint in `expdir` will be used.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "tfrecord_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to nsynth-{train, valid, test}.tfrecord.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_40": {
                "name": {
                    "value": "savedir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Where to save the embeddings.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_41": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged.DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_61": {
                "msg": {
                    "value": "'Z_Save:{}'.format(z_save_val.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_62": {
                "msg": {
                    "value": "'Successfully saved to {}'.format(save_name % '')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_66": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_144": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_145": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_72": {
                "msg": {
                    "value": "Will load latest checkpoint from %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.expdir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "latest_checkpoint_78": {
                "variable": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.expdir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "checkpoint_exists_83": {
                "checkpoint_prefix": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_path",
                            "Attribute"
                        ],
                        [
                            "tf.train.latest_checkpoint(expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_84": {
                "msg": {
                    "value": "Invalid checkpoint path: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_path",
                            "Attribute"
                        ],
                        [
                            "tf.train.latest_checkpoint(expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "Exists_88": {
                "filename": {
                    "value": "savedir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.savedir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "MakeDirs_89": {
                "dirname": {
                    "value": "savedir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.savedir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Graph_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "group_106": {
                "variable": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "tf.global_variables_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.local_variables_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_112": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Coordinator_117": {
                "variable": {
                    "value": "coord",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "start_queue_runners_118": {
                "variable": {
                    "value": "threads",
                    "type": "variable",
                    "possible_values": []
                },
                "sess": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "coord": {
                    "value": "coord",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Coordinator()",
                            "Call"
                        ]
                    ]
                }
            },
            "Exists_73": {
                "filename": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.expdir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "fatal_74": {
                "msg": {
                    "value": "\"\\tExperiment save dir '%s' does not exist!\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.expdir",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Session_93": {
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_114": {
                "msg": {
                    "value": "Model restored.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_80": {
                "msg": {
                    "value": "There was a problem determining the latest checkpoint.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_98": {
                "name": {
                    "value": "Reader",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_104": {
                "key": {
                    "value": "z",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_initializer_106": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_initializer_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_93": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_127": {
                "msg": {
                    "value": "'Iter: %d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_128": {
                "msg": {
                    "value": "'Z:{}'.format(res_val[0].shape)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/baseline/train.py": {
        "tensorflow": {
            "DEFINE_string_23": {
                "name": {
                    "value": "master",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "BNS name of the TensorFlow master to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_26": {
                "name": {
                    "value": "logdir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/baseline/train",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory where to write event logs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_28": {
                "name": {
                    "value": "train_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path the nsynth-train.tfrecord.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_31": {
                "name": {
                    "value": "model",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "ae",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Which model to use in models/",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_32": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "nfft_1024",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Which config to use in models/configs/",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_35": {
                "name": {
                    "value": "save_summaries_secs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Frequency at which summaries are saved, in seconds.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_39": {
                "name": {
                    "value": "save_interval_secs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Frequency at which the model is saved, in seconds.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_43": {
                "name": {
                    "value": "ps_tasks",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of parameter servers. If 0, parameters are handled locally by the worker.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_47": {
                "name": {
                    "value": "task",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Task ID. Used when training with multiple workers to identify each worker.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged.DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_57": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_96": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_97": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Exists_59": {
                "filename": {
                    "value": "FLAGS.logdir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_60": {
                "dirname": {
                    "value": "FLAGS.logdir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Graph_62": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_76": {
                "device_name": {
                    "value": "cpu_device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/job:worker/cpu:0'",
                            "str"
                        ],
                        [
                            "'/job:localhost/replica:0/task:0/cpu:0'",
                            "str"
                        ]
                    ]
                }
            },
            "device_81": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(ps_tasks=FLAGS.ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_77": {
                "name": {
                    "value": "Reader",
                    "type": "str",
                    "possible_values": []
                }
            },
            "replica_device_setter_81": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/reader.py": {
        "tensorflow": {
            "TFRecordReader_53": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "input_producer_56": {
                "variable": {
                    "value": "path_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[self.record_path]",
                    "type": "List",
                    "possible_values": []
                },
                "num_epochs": {
                    "value": "num_epochs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None if self.is_training else 1",
                            "IfExp"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "capacity",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_size",
                            "variable"
                        ]
                    ]
                }
            },
            "parse_single_example_71": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized_example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'note_str': tf.FixedLenFeature([], dtype=tf.string), 'pitch': tf.FixedLenFeature([1], dtype=tf.int64), 'velocity': tf.FixedLenFeature([1], dtype=tf.int64), 'audio': tf.FixedLenFeature([64000], dtype=tf.float32), 'qualities': tf.FixedLenFeature([10], dtype=tf.int64), 'instrument_source': tf.FixedLenFeature([1], dtype=tf.int64), 'instrument_family': tf.FixedLenFeature([1], dtype=tf.int64)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "slice_86": {
                "variable": {
                    "value": "wav",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "wav",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.slice(wav, [0], [64000])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[64000]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_87": {
                "variable": {
                    "value": "pitch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example['pitch']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_88": {
                "variable": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "example['note_str']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_112": {
                "variable": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(crop, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_113": {
                "variable": {
                    "value": "pitch",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pitch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(example['pitch'])",
                            "Call"
                        ],
                        [
                            "tf.cast(pitch, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.slice(example['pitch'], [0], [1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "slice_126": {
                "variable": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "example['audio']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[64000]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_127": {
                "variable": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(example['audio'], [0], [64000])",
                            "Call"
                        ],
                        [
                            "tf.reshape(audio, [1, 64000])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 64000]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_128": {
                "variable": {
                    "value": "pitch",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "example['pitch']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_129": {
                "variable": {
                    "value": "velocity",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "example['velocity']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_130": {
                "variable": {
                    "value": "instrument_source",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "example['instrument_source']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_131": {
                "variable": {
                    "value": "instrument_family",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "example['instrument_family']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_132": {
                "variable": {
                    "value": "qualities",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "example['qualities']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_133": {
                "variable": {
                    "value": "qualities",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "qualities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.slice(example['qualities'], [0], [10])",
                            "Call"
                        ],
                        [
                            "tf.reshape(qualities, [1, 10])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_92": {
                "variable": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "wav",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.slice(wav, [0], [64000])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_93": {
                "variable": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_crop(wav, [length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(crop, [1, length])",
                            "Call"
                        ],
                        [
                            "tf.slice(wav, [offset], [length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(crop, [1, length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.cast(crop, tf.float32), [batch_size, length])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shuffle_batch_94": {
                "variable": {
                    "value": "(key, crop, pitch)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[key, crop, pitch]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "capacity": {
                    "value": "500 * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "200 * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "slice_103": {
                "variable": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "wav",
                    "type": "variable",
                    "possible_values": [
                        [
                            "example['audio']",
                            "Subscript"
                        ],
                        [
                            "tf.slice(wav, [0], [64000])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[offset]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_104": {
                "variable": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_crop(wav, [length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(crop, [1, length])",
                            "Call"
                        ],
                        [
                            "tf.slice(wav, [offset], [length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(crop, [1, length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.cast(crop, tf.float32), [batch_size, length])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shuffle_batch_105": {
                "variable": {
                    "value": "(key, crop, pitch)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[key, crop, pitch]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "capacity": {
                    "value": "500 * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "200 * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_151": {
                "variable": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.tf_specgram(audio, n_fft=n_fft, hop_length=hop_length, mask=hparams.mask, log_mag=hparams.log_mag, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.pad(specgram, [[0, 0], [0, 0], [0, num_padding], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.slice(specgram, [0, 0, 0, 0], [-1, shape[1] - 1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] + SPECGRAM_REGISTRY[n_fft, hop_length]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shuffle_batch_167": {
                "variable": {
                    "value": "(audio, velocity, pitch, specgram, instrument_source, instrument_family, qualities)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[audio, velocity, pitch, specgram, instrument_source, instrument_family, qualities]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "hparams.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "20 * hparams.batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "10 * hparams.batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "FixedLenFeature_63": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_64": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_65": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_66": {
                "shape": {
                    "value": "[64000]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_67": {
                "shape": {
                    "value": "[10]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_68": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_69": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_112": {
                "x": {
                    "value": "crop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_crop(wav, [length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(crop, [1, length])",
                            "Call"
                        ],
                        [
                            "tf.slice(wav, [offset], [length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(crop, [1, length])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.cast(crop, tf.float32), [batch_size, length])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_152": {
                "msg": {
                    "value": "SPECGRAM BEFORE PADDING",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.tf_specgram(audio, n_fft=n_fft, hop_length=hop_length, mask=hparams.mask, log_mag=hparams.log_mag, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.pad(specgram, [[0, 0], [0, 0], [0, num_padding], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.slice(specgram, [0, 0, 0, 0], [-1, shape[1] - 1, -1, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_158": {
                "variable": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.tf_specgram(audio, n_fft=n_fft, hop_length=hop_length, mask=hparams.mask, log_mag=hparams.log_mag, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.pad(specgram, [[0, 0], [0, 0], [0, num_padding], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.slice(specgram, [0, 0, 0, 0], [-1, shape[1] - 1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] + SPECGRAM_REGISTRY[n_fft, hop_length]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "pad_159": {
                "variable": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.tf_specgram(audio, n_fft=n_fft, hop_length=hop_length, mask=hparams.mask, log_mag=hparams.log_mag, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.pad(specgram, [[0, 0], [0, 0], [0, num_padding], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.slice(specgram, [0, 0, 0, 0], [-1, shape[1] - 1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [0, num_padding], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_160": {
                "variable": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.tf_specgram(audio, n_fft=n_fft, hop_length=hop_length, mask=hparams.mask, log_mag=hparams.log_mag, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.pad(specgram, [[0, 0], [0, 0], [0, num_padding], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.slice(specgram, [0, 0, 0, 0], [-1, shape[1] - 1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, shape[1] - 1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "batch_178": {
                "variable": {
                    "value": "(audio, velocity, pitch, specgram, instrument_source, instrument_family, qualities)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[audio, velocity, pitch, specgram, instrument_source, instrument_family, qualities]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "hparams.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "10 * hparams.batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_157": {
                "msg": {
                    "value": "'num_pading: %d' % num_padding",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_161": {
                "msg": {
                    "value": "SPECGRAM AFTER PADDING",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "specgram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.tf_specgram(audio, n_fft=n_fft, hop_length=hop_length, mask=hparams.mask, log_mag=hparams.log_mag, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(specgram, shape)",
                            "Call"
                        ],
                        [
                            "tf.pad(specgram, [[0, 0], [0, 0], [0, num_padding], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.slice(specgram, [0, 0, 0, 0], [-1, shape[1] - 1, -1, -1])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/nsynth/utils.py": {
        "tensorflow": {
            "floor_75": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "out * 128",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_91": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "np.array(x).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([spec, tf.zeros([dims[0], 1, dims[2], dims[3]])], 1)",
                            "Call"
                        ],
                        [
                            "spec",
                            "variable"
                        ],
                        [
                            "tf.image.resize_images(x, size=[h * stride[0], w * stride[1]], method=0)",
                            "Call"
                        ],
                        [
                            "conv_fn(inputs=x, stride=stride_conv, kernel_size=kernel_size, num_outputs=num_outputs, normalizer_fn=normalizer_fn, biases_initializer=tf.zeros_initializer(), scope=scope)",
                            "Call"
                        ],
                        [
                            "activation_fn(x)",
                            "Call"
                        ],
                        [
                            "x1 * x2",
                            "BinOp"
                        ],
                        [
                            "x + x0",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_94": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(x, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "np.array(x).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([spec, tf.zeros([dims[0], 1, dims[2], dims[3]])], 1)",
                            "Call"
                        ],
                        [
                            "spec",
                            "variable"
                        ],
                        [
                            "tf.image.resize_images(x, size=[h * stride[0], w * stride[1]], method=0)",
                            "Call"
                        ],
                        [
                            "conv_fn(inputs=x, stride=stride_conv, kernel_size=kernel_size, num_outputs=num_outputs, normalizer_fn=normalizer_fn, biases_initializer=tf.zeros_initializer(), scope=scope)",
                            "Call"
                        ],
                        [
                            "activation_fn(x)",
                            "Call"
                        ],
                        [
                            "x1 * x2",
                            "BinOp"
                        ],
                        [
                            "x + x0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sign(x) * tf.log(1 + mu * tf.abs(x)) / np.log(1 + mu)",
                            "BinOp"
                        ],
                        [
                            "tf.floor(out * 128)",
                            "Call"
                        ],
                        [
                            "tf.cast(out, tf.int8)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "tf.sign(out) / mu * ((1 + mu) ** tf.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(x, 0), x, out)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "np.sign(out) / mu * ((1 + mu) ** np.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "np.where(np.equal(x, 0), x, out)",
                            "Call"
                        ]
                    ]
                }
            },
            "py_func_413": {
                "variable": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "batch_ispecgram",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[x, n_fft, hop_length, mask, log_mag, re_im, dphase, mag_only, num_iters]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_459": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "grid_shape + image_shape + [num_channels]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "transpose_461": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_462": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[grid_shape[0], width, image_shape[0], num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_464": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_465": {
                "variable": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensor, grid_shape + image_shape + [num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 1, 3, 2, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [grid_shape[0], width, image_shape[0], num_channels])",
                            "Call"
                        ],
                        [
                            "tf.transpose(input_tensor, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensor, [1, height, width, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, height, width, num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_545": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(tf.rank(one_hot_labels), 2), lambda : tf.to_int32(tf.argmax(one_hot_labels, 1)), lambda : tf.to_int32(one_hot_labels))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_547": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=one_hot_labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean((predicted_vectors - true_vectors) ** 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_565": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_567": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=one_hot_labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean((predicted_vectors - true_vectors) ** 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_584": {
                "variable": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.equal(tf.rank(one_hot_labels), 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.to_int32(tf.argmax(one_hot_labels, 1))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.to_int32(one_hot_labels)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "in_top_k_589": {
                "variable": {
                    "value": "in_top_1",
                    "type": "variable",
                    "possible_values": []
                },
                "targets": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(tf.rank(one_hot_labels), 2), lambda : tf.to_int32(tf.argmax(one_hot_labels, 1)), lambda : tf.to_int32(one_hot_labels))",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "in_top_k_592": {
                "variable": {
                    "value": "in_top_5",
                    "type": "variable",
                    "possible_values": []
                },
                "targets": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(tf.rank(one_hot_labels), 2), lambda : tf.to_int32(tf.argmax(one_hot_labels, 1)), lambda : tf.to_int32(one_hot_labels))",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_609": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(predicted_vectors - true_vectors) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "FIFOQueue_842": {
                "variable": {
                    "value": "q_1",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shapes": {
                    "value": "(batch_size, 1, n_inputs)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "FIFOQueue_843": {
                "variable": {
                    "value": "q_2",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shapes": {
                    "value": "(batch_size, 1, n_inputs)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_852": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '/W'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, filter_length, n_inputs, n_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_856": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '/biases'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "slice_858": {
                "variable": {
                    "value": "w_q_2",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='embedding_weights', shape=[n_pitches, dim_embedding], initializer=tf.random_normal_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, filter_length, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, 1, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, 1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_859": {
                "variable": {
                    "value": "w_q_1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='embedding_weights', shape=[n_pitches, dim_embedding], initializer=tf.random_normal_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, filter_length, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, 1, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 1, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, 1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_860": {
                "variable": {
                    "value": "w_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='embedding_weights', shape=[n_pitches, dim_embedding], initializer=tf.random_normal_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, filter_length, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, 1, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 2, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, 1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_863": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.matmul(state_2[:, 0, :], w_q_2[0][0]) + tf.matmul(state_1[:, 0, :], w_q_1[0][0]) + tf.matmul(x[:, 0, :], w_x[0][0])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "bias": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "min(batch_size, rows * columns)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_867": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.bias_add(tf.matmul(state_2[:, 0, :], w_q_2[0][0]) + tf.matmul(state_1[:, 0, :], w_q_1[0][0]) + tf.matmul(x[:, 0, :], w_x[0][0]), b)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(tf.matmul(x[:, 0, :], w[0][0]), b)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_883": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '/W'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, n_inputs, n_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_885": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name + '/biases'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_outputs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_887": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.matmul(x[:, 0, :], w[0][0])",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "min(batch_size, rows * columns)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_888": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.bias_add(tf.matmul(state_2[:, 0, :], w_q_2[0][0]) + tf.matmul(state_1[:, 0, :], w_q_1[0][0]) + tf.matmul(x[:, 0, :], w_x[0][0]), b)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(tf.matmul(x[:, 0, :], w[0][0]), b)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_77": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sign(x) * tf.log(1 + mu * tf.abs(x)) / np.log(1 + mu)",
                            "BinOp"
                        ],
                        [
                            "tf.floor(out * 128)",
                            "Call"
                        ],
                        [
                            "tf.cast(out, tf.int8)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "tf.sign(out) / mu * ((1 + mu) ** tf.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(x, 0), x, out)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "np.sign(out) / mu * ((1 + mu) ** np.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "np.where(np.equal(x, 0), x, out)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "py_func_391": {
                "func": {
                    "value": "batch_specgram",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[audio, n_fft, hop_length, mask, log_mag, re_im, dphase, mag_only]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_410": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[spec, tf.zeros([dims[0], 1, dims[2], dims[3]])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_497": {
                "variable": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "librosa.stft(audio, **fft_config)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(spec)",
                            "Call"
                        ],
                        [
                            "spec / tf.expand_dims(tf.reduce_max(spec, axis=1), axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "scalar_582": {
                "name": {
                    "value": "name + '_loss'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=one_hot_labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean((predicted_vectors - true_vectors) ** 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_590": {
                "name": {
                    "value": "name + '_precision@1'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(tf.to_float(in_top_1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_593": {
                "name": {
                    "value": "name + '_precision@5'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(tf.to_float(in_top_5))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_610": {
                "name": {
                    "value": "name + '_loss'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=one_hot_labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean((predicted_vectors - true_vectors) ** 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_611": {
                "name": {
                    "value": "name + '_prediction_mean_squared_norm'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(tf.nn.l2_loss(predicted_vectors))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_614": {
                "name": {
                    "value": "name + '_label_mean_squared_norm'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(tf.nn.l2_loss(true_vectors))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_637": {
                "value": {
                    "value": "mask[np.newaxis, :, np.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_662": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "embedding_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_pitches, dim_embedding]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_666": {
                "variable": {
                    "value": "one_hot_pitch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "batch['pitch']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_667": {
                "variable": {
                    "value": "one_hot_pitch",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "one_hot_pitch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(batch['pitch'], [batch_size])",
                            "Call"
                        ],
                        [
                            "tf.one_hot(one_hot_pitch, depth=n_pitches)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "n_pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "128",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_668": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "one_hot_pitch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(batch['pitch'], [batch_size])",
                            "Call"
                        ],
                        [
                            "tf.one_hot(one_hot_pitch, depth=n_pitches)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name='embedding_weights', shape=[n_pitches, dim_embedding], initializer=tf.random_normal_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, filter_length, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/W', shape=[1, 1, n_inputs, n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_669": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(one_hot_pitch, w)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embedding, [batch_size, 1, 1, dim_embedding])",
                            "Call"
                        ],
                        [
                            "tf.tile(embedding, [1, 1, timesteps, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1, 1, dim_embedding]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_94": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "np.array(x).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([spec, tf.zeros([dims[0], 1, dims[2], dims[3]])], 1)",
                            "Call"
                        ],
                        [
                            "spec",
                            "variable"
                        ],
                        [
                            "tf.image.resize_images(x, size=[h * stride[0], w * stride[1]], method=0)",
                            "Call"
                        ],
                        [
                            "conv_fn(inputs=x, stride=stride_conv, kernel_size=kernel_size, num_outputs=num_outputs, normalizer_fn=normalizer_fn, biases_initializer=tf.zeros_initializer(), scope=scope)",
                            "Call"
                        ],
                        [
                            "activation_fn(x)",
                            "Call"
                        ],
                        [
                            "x1 * x2",
                            "BinOp"
                        ],
                        [
                            "x + x0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_498": {
                "input": {
                    "value": "tf.reduce_max(spec, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "audio_499": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'softmax'",
                            "Method Argument"
                        ]
                    ]
                },
                "data": {
                    "value": "tf.squeeze(spec)",
                    "type": "Call",
                    "possible_values": []
                },
                "sample_rate": {
                    "value": "hparams.samples_per_second",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "min(batch_size, rows * columns)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_585": {
                "x": {
                    "value": "tf.rank(one_hot_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_591": {
                "input_tensor": {
                    "value": "tf.to_float(in_top_1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_594": {
                "input_tensor": {
                    "value": "tf.to_float(in_top_5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_613": {
                "input_tensor": {
                    "value": "tf.nn.l2_loss(predicted_vectors)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_616": {
                "input_tensor": {
                    "value": "tf.nn.l2_loss(true_vectors)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_661": {
                "name_or_scope": {
                    "value": "PitchEmbedding",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tile_671": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(one_hot_pitch, w)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embedding, [batch_size, 1, 1, dim_embedding])",
                            "Call"
                        ],
                        [
                            "tf.tile(embedding, [1, 1, timesteps, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, timesteps, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_749": {
                "name_or_scope": {
                    "value": "scope + '_Layer'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_816": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "np.array(x).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([spec, tf.zeros([dims[0], 1, dims[2], dims[3]])], 1)",
                            "Call"
                        ],
                        [
                            "spec",
                            "variable"
                        ],
                        [
                            "tf.image.resize_images(x, size=[h * stride[0], w * stride[1]], method=0)",
                            "Call"
                        ],
                        [
                            "conv_fn(inputs=x, stride=stride_conv, kernel_size=kernel_size, num_outputs=num_outputs, normalizer_fn=normalizer_fn, biases_initializer=tf.zeros_initializer(), scope=scope)",
                            "Call"
                        ],
                        [
                            "activation_fn(x)",
                            "Call"
                        ],
                        [
                            "x1 * x2",
                            "BinOp"
                        ],
                        [
                            "x + x0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "leak * x",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_844": {
                "shape": {
                    "value": "(rate, batch_size, 1, n_inputs)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_845": {
                "shape": {
                    "value": "(rate, batch_size, 1, n_inputs)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "matmul_887": {
                "a": {
                    "value": "x[:, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "w[0][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sign_74": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "np.array(x).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([spec, tf.zeros([dims[0], 1, dims[2], dims[3]])], 1)",
                            "Call"
                        ],
                        [
                            "spec",
                            "variable"
                        ],
                        [
                            "tf.image.resize_images(x, size=[h * stride[0], w * stride[1]], method=0)",
                            "Call"
                        ],
                        [
                            "conv_fn(inputs=x, stride=stride_conv, kernel_size=kernel_size, num_outputs=num_outputs, normalizer_fn=normalizer_fn, biases_initializer=tf.zeros_initializer(), scope=scope)",
                            "Call"
                        ],
                        [
                            "activation_fn(x)",
                            "Call"
                        ],
                        [
                            "x1 * x2",
                            "BinOp"
                        ],
                        [
                            "x + x0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_74": {
                "x": {
                    "value": "1 + mu * tf.abs(x)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sign_93": {
                "x": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sign(x) * tf.log(1 + mu * tf.abs(x)) / np.log(1 + mu)",
                            "BinOp"
                        ],
                        [
                            "tf.floor(out * 128)",
                            "Call"
                        ],
                        [
                            "tf.cast(out, tf.int8)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "tf.sign(out) / mu * ((1 + mu) ** tf.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(x, 0), x, out)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "np.sign(out) / mu * ((1 + mu) ** np.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "np.where(np.equal(x, 0), x, out)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_498": {
                "input_tensor": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "librosa.stft(audio, **fft_config)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(spec)",
                            "Call"
                        ],
                        [
                            "spec / tf.expand_dims(tf.reduce_max(spec, axis=1), axis=1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_500": {
                "input": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "librosa.stft(audio, **fft_config)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(spec)",
                            "Call"
                        ],
                        [
                            "spec / tf.expand_dims(tf.reduce_max(spec, axis=1), axis=1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "image_508": {
                "name": {
                    "value": "'Mag/%s' % name",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "form_image_grid(spec[:b, :, :, :1], [rows, columns], [n_freq, n_time], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "audio_516": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'softmax'",
                            "Method Argument"
                        ]
                    ]
                },
                "data": {
                    "value": "tf_ispecgram(spec, n_fft=hparams.n_fft, hop_length=hparams.hop_length, mask=hparams.mask, log_mag=hparams.log_mag, pad=hparams.pad, re_im=hparams.re_im, dphase=hparams.dphase, mag_only=hparams.mag_only)",
                    "type": "Call",
                    "possible_values": []
                },
                "sample_rate": {
                    "value": "hparams.samples_per_second",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_outputs": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "range(batch_size)",
                            "Call"
                        ],
                        [
                            "min(batch_size, rows * columns)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name=name + '/biases', shape=[n_outputs], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "rank_585": {
                "input": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(tf.rank(one_hot_labels), 2), lambda : tf.to_int32(tf.argmax(one_hot_labels, 1)), lambda : tf.to_int32(one_hot_labels))",
                            "Call"
                        ]
                    ]
                }
            },
            "to_int32_586": {
                "x": {
                    "value": "tf.argmax(one_hot_labels, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_int32_587": {
                "x": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(tf.rank(one_hot_labels), 2), lambda : tf.to_int32(tf.argmax(one_hot_labels, 1)), lambda : tf.to_int32(one_hot_labels))",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_591": {
                "x": {
                    "value": "in_top_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.in_top_k(logits, one_hot_labels, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_594": {
                "x": {
                    "value": "in_top_5",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.in_top_k(logits, one_hot_labels, 5)",
                            "Call"
                        ]
                    ]
                }
            },
            "l2_loss_613": {
                "t": {
                    "value": "predicted_vectors",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "l2_loss_616": {
                "t": {
                    "value": "true_vectors",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_865": {
                "a": {
                    "value": "x[:, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "w_x[0][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "abs_93": {
                "x": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sign(x) * tf.log(1 + mu * tf.abs(x)) / np.log(1 + mu)",
                            "BinOp"
                        ],
                        [
                            "tf.floor(out * 128)",
                            "Call"
                        ],
                        [
                            "tf.cast(out, tf.int8)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "tf.sign(out) / mu * ((1 + mu) ** tf.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "tf.where(tf.equal(x, 0), x, out)",
                            "Call"
                        ],
                        [
                            "(x + 0.5) * 2.0 / (mu + 1)",
                            "BinOp"
                        ],
                        [
                            "np.sign(out) / mu * ((1 + mu) ** np.abs(out) - 1)",
                            "BinOp"
                        ],
                        [
                            "np.where(np.equal(x, 0), x, out)",
                            "Call"
                        ]
                    ]
                }
            },
            "RMSPropOptimizer_167": {
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0.95",
                    "type": "float",
                    "possible_values": []
                },
                "momentum": {
                    "value": "hparams.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "0.0001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdamOptimizer_173": {
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "beta1": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                },
                "beta2": {
                    "value": "0.999",
                    "type": "float",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-08",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdagradOptimizer_175": {
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_accumulator_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_177": {
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "momentum": {
                    "value": "hparams.momentum",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientDescentOptimizer_179": {
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_410": {
                "shape": {
                    "value": "[dims[0], 1, dims[2], dims[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_512": {
                "name": {
                    "value": "'Phase/%s' % name",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "form_image_grid(spec[:b, :, :, 1:], [rows, columns], [n_freq, n_time], 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_586": {
                "input": {
                    "value": "one_hot_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.equal(tf.rank(one_hot_labels), 2), lambda : tf.to_int32(tf.argmax(one_hot_labels, 1)), lambda : tf.to_int32(one_hot_labels))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_normal_initializer_665": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "matmul_864": {
                "a": {
                    "value": "state_1[:, 0, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "w_q_1[0][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "abs_74": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x, tf.float32)",
                            "Call"
                        ],
                        [
                            "np.array(x).astype(np.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat([spec, tf.zeros([dims[0], 1, dims[2], dims[3]])], 1)",
                            "Call"
                        ],
                        [
                            "spec",
                            "variable"
                        ],
                        [
                            "tf.image.resize_images(x, size=[h * stride[0], w * stride[1]], method=0)",
                            "Call"
                        ],
                        [
                            "conv_fn(inputs=x, stride=stride_conv, kernel_size=kernel_size, num_outputs=num_outputs, normalizer_fn=normalizer_fn, biases_initializer=tf.zeros_initializer(), scope=scope)",
                            "Call"
                        ],
                        [
                            "activation_fn(x)",
                            "Call"
                        ],
                        [
                            "x1 * x2",
                            "BinOp"
                        ],
                        [
                            "x + x0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_initializer_769": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_773": {
                "name_or_scope": {
                    "value": "Gated",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_778": {
                "variable": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(x2)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_783": {
                "name_or_scope": {
                    "value": "Residual",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_776": {
                "x": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(x2)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/fastgen.py": {
        "tensorflow": {
            "ConfigProto_100": {
                "variable": {
                    "value": "session_config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ConfigProto_211": {
                "variable": {
                    "value": "session_config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_63": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, sample_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_79": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Saver_107": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_215": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_62": {
                "device_name": {
                    "value": "/gpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_78": {
                "device_name": {
                    "value": "/gpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_102": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_102": {
                "config": {
                    "value": "session_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_175": {
                "msg": {
                    "value": "'Saving: %s' % name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Graph_213": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_213": {
                "config": {
                    "value": "session_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ],
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_237": {
                "msg": {
                    "value": "'Sample: %d' % sample_i",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/fastgen_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_temp_dir_64": {
                "variable": {
                    "value": "test_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_temp_dir_86": {
                "variable": {
                    "value": "test_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_112": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_65": {
                "dirname": {
                    "value": "test_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.test.get_temp_dir()",
                            "Call"
                        ],
                        [
                            "tf.test.get_temp_dir()",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_87": {
                "dirname": {
                    "value": "test_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.test.get_temp_dir()",
                            "Call"
                        ],
                        [
                            "tf.test.get_temp_dir()",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_33": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_45": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/h512_bo16.py": {
        "tensorflow": {
            "expand_dims_52": {
                "variable": {
                    "value": "x_scaled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_scaled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x_quantized, tf.float32) / 128.0",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(x_scaled, 2)",
                            "Call"
                        ],
                        [
                            "tf.cast(x_quantized, tf.float32) / 128.0",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(x_scaled, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_54": {
                "variable": {
                    "value": "encoding",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "encoding",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, num_z]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_56": {
                "variable": {
                    "value": "en",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(name='encoding', shape=[batch_size, num_z], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoding, [mb, enc_length, 1, channels])",
                            "Call"
                        ],
                        [
                            "en",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_114": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(l, width, skip_width, name='skip_start')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "utils.linear(s, skip_width, skip_width, name='out1') + utils.linear(en, num_z, skip_width, name='cond_map_out1')",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "s + masked.conv1d(d, num_filters=skip_width, filter_length=1, name='skip_%d' % (i + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(l, num_filters=skip_width, filter_length=1, name='skip_start', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=skip_width, filter_length=1, name='out1', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "self._condition(s, masked.conv1d(en, num_filters=skip_width, filter_length=1, name='cond_map_out1', is_training=is_training))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_117": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(l, width, skip_width, name='skip_start')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "utils.linear(s, skip_width, skip_width, name='out1') + utils.linear(en, num_z, skip_width, name='cond_map_out1')",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "s + masked.conv1d(d, num_filters=skip_width, filter_length=1, name='skip_%d' % (i + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(l, num_filters=skip_width, filter_length=1, name='skip_start', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=skip_width, filter_length=1, name='out1', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "self._condition(s, masked.conv1d(en, num_filters=skip_width, filter_length=1, name='cond_map_out1', is_training=is_training))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_123": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(s, skip_width, 256, name='logits')",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=256, filter_length=1, name='logits', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_124": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(s, skip_width, 256, name='logits')",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=256, filter_length=1, name='logits', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_174": {
                "variable": {
                    "value": "encoding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(name='encoding', shape=[batch_size, num_z], dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(encoding, [mb, enc_length, 1, channels])",
                            "Call"
                        ],
                        [
                            "en",
                            "variable"
                        ]
                    ]
                },
                "shape": {
                    "value": "[mb, enc_length, 1, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_175": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs['wav']",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(x, [mb, enc_length, -1, channels])",
                            "Call"
                        ],
                        [
                            "x + encoding",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [mb, length, channels])",
                            "Call"
                        ],
                        [
                            "inputs['wav']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(x, 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[mb, enc_length, -1, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_177": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs['wav']",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(x, [mb, enc_length, -1, channels])",
                            "Call"
                        ],
                        [
                            "x + encoding",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [mb, length, channels])",
                            "Call"
                        ],
                        [
                            "inputs['wav']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(x, 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[mb, length, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_211": {
                "variable": {
                    "value": "x_scaled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_scaled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(x_quantized, tf.float32) / 128.0",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(x_scaled, 2)",
                            "Call"
                        ],
                        [
                            "tf.cast(x_quantized, tf.float32) / 128.0",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(x_scaled, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_212": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs['wav']",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(x, [mb, enc_length, -1, channels])",
                            "Call"
                        ],
                        [
                            "x + encoding",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(x, [mb, length, channels])",
                            "Call"
                        ],
                        [
                            "inputs['wav']",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(x, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_322": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(l, width, skip_width, name='skip_start')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "utils.linear(s, skip_width, skip_width, name='out1') + utils.linear(en, num_z, skip_width, name='cond_map_out1')",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "s + masked.conv1d(d, num_filters=skip_width, filter_length=1, name='skip_%d' % (i + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(l, num_filters=skip_width, filter_length=1, name='skip_start', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=skip_width, filter_length=1, name='out1', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "self._condition(s, masked.conv1d(en, num_filters=skip_width, filter_length=1, name='cond_map_out1', is_training=is_training))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_336": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(l, width, skip_width, name='skip_start')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "utils.linear(s, skip_width, skip_width, name='out1') + utils.linear(en, num_z, skip_width, name='cond_map_out1')",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "s + masked.conv1d(d, num_filters=skip_width, filter_length=1, name='skip_%d' % (i + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(l, num_filters=skip_width, filter_length=1, name='skip_start', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=skip_width, filter_length=1, name='out1', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "self._condition(s, masked.conv1d(en, num_filters=skip_width, filter_length=1, name='cond_map_out1', is_training=is_training))",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(s)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_347": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(s, skip_width, 256, name='logits')",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=256, filter_length=1, name='logits', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 256]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_348": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(s, skip_width, 256, name='logits')",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=256, filter_length=1, name='logits', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_350": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=x_indices, name='nll')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_227": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "en",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(encoding, 1)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(x_scaled if rescale_inputs else x, causal=False, num_filters=ae_width, filter_length=ae_filter_length, name='ae_startconv', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "en + masked.conv1d(d, num_filters=ae_width, filter_length=1, name='ae_res_%d' % (num_layer + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(en, num_filters=self.ae_bottleneck_width, filter_length=1, name='ae_bottleneck', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(en, [batch_size, -1, self.ae_hop_length, depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(en, axis=2)",
                            "Call"
                        ],
                        [
                            "masked.pool1d(en, self.ae_hop_length, name='ae_pool', mode='avg')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_236": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "d + utils.linear(en, num_z, width * 2, name='cond_map_%d' % (i + 1))",
                            "BinOp"
                        ],
                        [
                            "tf.sigmoid(d[:, :, :m]) * tf.tanh(d[:, :, m:])",
                            "BinOp"
                        ],
                        [
                            "tf.nn.relu(en)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(d, causal=False, num_filters=ae_width, filter_length=ae_filter_length, dilation=dilation, name='ae_dilatedconv_%d' % (num_layer + 1), is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(d)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(l, num_filters=2 * width, filter_length=filter_length, dilation=dilation, name='dilatedconv_%d' % (i + 1), is_training=is_training)",
                            "Call"
                        ],
                        [
                            "self._condition(d, masked.conv1d(en, num_filters=2 * width, filter_length=1, name='cond_map_%d' % (i + 1), is_training=is_training))",
                            "Call"
                        ],
                        [
                            "d_sigmoid * d_tanh",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_257": {
                "variable": {
                    "value": "en",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "en",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(encoding, 1)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(x_scaled if rescale_inputs else x, causal=False, num_filters=ae_width, filter_length=ae_filter_length, name='ae_startconv', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "en + masked.conv1d(d, num_filters=ae_width, filter_length=1, name='ae_res_%d' % (num_layer + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(en, num_filters=self.ae_bottleneck_width, filter_length=1, name='ae_bottleneck', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(en, [batch_size, -1, self.ae_hop_length, depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(en, axis=2)",
                            "Call"
                        ],
                        [
                            "masked.pool1d(en, self.ae_hop_length, name='ae_pool', mode='avg')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, self.ae_hop_length, depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_258": {
                "variable": {
                    "value": "en",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "en",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(encoding, 1)",
                            "Call"
                        ],
                        [
                            "masked.conv1d(x_scaled if rescale_inputs else x, causal=False, num_filters=ae_width, filter_length=ae_filter_length, name='ae_startconv', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "en + masked.conv1d(d, num_filters=ae_width, filter_length=1, name='ae_res_%d' % (num_layer + 1), is_training=is_training)",
                            "BinOp"
                        ],
                        [
                            "masked.conv1d(en, num_filters=self.ae_bottleneck_width, filter_length=1, name='ae_bottleneck', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(en, [batch_size, -1, self.ae_hop_length, depth])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(en, axis=2)",
                            "Call"
                        ],
                        [
                            "masked.pool1d(en, self.ae_hop_length, name='ae_pool', mode='avg')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_305": {
                "variable": {
                    "value": "d_sigmoid",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d[:, :, :m]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tanh_306": {
                "variable": {
                    "value": "d_tanh",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d[:, :, m:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_51": {
                "x": {
                    "value": "x_quantized",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.mu_law(x)",
                            "Call"
                        ],
                        [
                            "utils.mu_law(x)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_210": {
                "x": {
                    "value": "x_quantized",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.mu_law(x)",
                            "Call"
                        ],
                        [
                            "utils.mu_law(x)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_349": {
                "x": {
                    "value": "tf.reshape(x_quantized, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_351": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.linear(s, skip_width, 256, name='logits')",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ],
                        [
                            "masked.conv1d(s, num_filters=256, filter_length=1, name='logits', is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "x_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reshape(x_quantized, [-1]), tf.int32) + 128",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "nll",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_106": {
                "x": {
                    "value": "d[:, :, :m]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tanh_106": {
                "x": {
                    "value": "d[:, :, m:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_349": {
                "tensor": {
                    "value": "x_quantized",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.mu_law(x)",
                            "Call"
                        ],
                        [
                            "utils.mu_law(x)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/masked.py": {
        "tensorflow": {
            "pad_34": {
                "variable": {
                    "value": "x_padded",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, 0], [1, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_35": {
                "variable": {
                    "value": "x_sliced",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "x_padded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "tf.stack([-1, shape[1], -1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_75": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[shape[0], shape[1] // block_size, block_size, shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_78": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [shape[0], shape[1] // block_size, block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] * block_size, shape[1] // block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [shape[0] // block_size, block_size, shape[1], shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] // block_size, shape[1] * block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x_4d, weights, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(y, biases)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [y_shape[0], y_shape[2], num_filters])",
                            "Call"
                        ],
                        [
                            "batch_to_time(y, dilation)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_79": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [shape[0], shape[1] // block_size, block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] * block_size, shape[1] // block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [shape[0] // block_size, block_size, shape[1], shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] // block_size, shape[1] * block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x_4d, weights, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(y, biases)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [y_shape[0], y_shape[2], num_filters])",
                            "Call"
                        ],
                        [
                            "batch_to_time(y, dilation)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0] * block_size, shape[1] // block_size, shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_101": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[shape[0] // block_size, block_size, shape[1], shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_102": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [shape[0], shape[1] // block_size, block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] * block_size, shape[1] // block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [shape[0] // block_size, block_size, shape[1], shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] // block_size, shape[1] * block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x_4d, weights, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(y, biases)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [y_shape[0], y_shape[2], num_filters])",
                            "Call"
                        ],
                        [
                            "batch_to_time(y, dilation)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_103": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [shape[0], shape[1] // block_size, block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] * block_size, shape[1] // block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [shape[0] // block_size, block_size, shape[1], shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] // block_size, shape[1] * block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x_4d, weights, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(y, biases)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [y_shape[0], y_shape[2], num_filters])",
                            "Call"
                        ],
                        [
                            "batch_to_time(y, dilation)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0] // block_size, shape[1] * block_size, shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_156": {
                "variable": {
                    "value": "x_4d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x_ttb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "time_to_batch(x, dilation)",
                            "Call"
                        ],
                        [
                            "tf.pad(x_ttb, [[0, 0], [filter_length - 1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[x_ttb_shape[0], 1, x_ttb_shape[1], num_input_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_158": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_4d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x_ttb, [x_ttb_shape[0], 1, x_ttb_shape[1], num_input_channels])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [batch_size, 1, length, num_channels])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W', shape=kernel_shape, initializer=kernel_initializer, trainable=is_training)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, stride, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'VALID' if causal else 'SAME'",
                            "IfExp"
                        ]
                    ]
                }
            },
            "bias_add_159": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [shape[0], shape[1] // block_size, block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] * block_size, shape[1] // block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [shape[0] // block_size, block_size, shape[1], shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] // block_size, shape[1] * block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x_4d, weights, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(y, biases)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [y_shape[0], y_shape[2], num_filters])",
                            "Call"
                        ],
                        [
                            "batch_to_time(y, dilation)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('biases', shape=biases_shape, initializer=biases_initializer, trainable=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_161": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(x, [shape[0], shape[1] // block_size, block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] * block_size, shape[1] // block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x, [shape[0] // block_size, block_size, shape[1], shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(y, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [shape[0] // block_size, shape[1] * block_size, shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x_4d, weights, strides, padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(y, biases)",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, [y_shape[0], y_shape[2], num_filters])",
                            "Call"
                        ],
                        [
                            "batch_to_time(y, dilation)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[y_shape[0], y_shape[2], num_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_192": {
                "variable": {
                    "value": "x_4d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 1, length, num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "uniform_unit_scaling_initializer_116": {
                "factor": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_117": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "get_variable_144": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "kernel_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, filter_length, num_input_channels, num_filters]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "kernel_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.uniform_unit_scaling_initializer(1.0)",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_147": {
                "variable": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "biases_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[num_filters]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "biases_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant_initializer(0.0)",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pad_153": {
                "variable": {
                    "value": "x_ttb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x_ttb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "time_to_batch(x, dilation)",
                            "Call"
                        ],
                        [
                            "tf.pad(x_ttb, [[0, 0], [filter_length - 1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [filter_length - 1, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_194": {
                "tensor": {
                    "value": "pooled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pool_fn(x_4d, window_shape, strides, padding='SAME', name=name)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, length // stride, num_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_35": {
                "values": {
                    "value": "[-1, shape[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_143": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/nsynth_generate.py": {
        "tensorflow": {
            "DEFINE_string_25": {
                "name": {
                    "value": "source_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to directory with either .wav files or precomputed encodings in .npy files.If .wav files are present, use wav files. If no .wav files are present, use .npy files",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_30": {
                "name": {
                    "value": "save_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to output file dir.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_31": {
                "name": {
                    "value": "checkpoint_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "model.ckpt-200000",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to checkpoint.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_33": {
                "name": {
                    "value": "sample_length",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "64000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Max output file size in samples.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_35": {
                "name": {
                    "value": "batch_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of samples per a batch.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_36": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged.DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_39": {
                "name": {
                    "value": "gpu_number",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of the gpu to use for multigpu generation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_50": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "IsDirectory_53": {
                "dirname": {
                    "value": "source_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.source_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "ListDirectory_54": {
                "variable": {
                    "value": "files",
                    "type": "variable",
                    "possible_values": []
                },
                "dirname": {
                    "value": "source_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.source_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_110": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_111": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "device_100": {
                "device_name": {
                    "value": "'/device:GPU:%d' % FLAGS.gpu_number",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/nsynth_save_embeddings.py": {
        "tensorflow": {
            "DEFINE_string_27": {
                "name": {
                    "value": "source_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory of WAVs to yield embeddings from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_29": {
                "name": {
                    "value": "save_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory to save the embeddings.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_31": {
                "name": {
                    "value": "checkpoint_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A path to the checkpoint. If not given, the latest checkpoint in `expdir` will be used.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_34": {
                "name": {
                    "value": "expdir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The log directory for this experiment. Required if `checkpoint_path` is not given.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_37": {
                "name": {
                    "value": "sample_length",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "64000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Sample length.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_38": {
                "name": {
                    "value": "batch_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Sample length.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_39": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged.DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_45": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_66": {
                "msg": {
                    "value": "Will restore from checkpoint: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.checkpoint_path)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_69": {
                "msg": {
                    "value": "'Will load Wavs from %s.' % source_path",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_72": {
                "msg": {
                    "value": "'Will save embeddings to %s.' % save_path",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_125": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_51": {
                "msg": {
                    "value": "Will load latest checkpoint from %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_57": {
                "variable": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "checkpoint_exists_62": {
                "checkpoint_prefix": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.checkpoint_path)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_63": {
                "msg": {
                    "value": "Invalid checkpoint path: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.checkpoint_path)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "Exists_73": {
                "filename": {
                    "value": "save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.save_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_74": {
                "msg": {
                    "value": "Creating save directory...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_75": {
                "dirname": {
                    "value": "save_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.save_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_90": {
                "msg": {
                    "value": "On file number %s (batch %d).",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "start_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(0, len(wavfiles), batch_size)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "batch_number",
                    "type": "variable",
                    "possible_values": [
                        [
                            "start_file / batch_size + 1",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Exists_52": {
                "filename": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_53": {
                "msg": {
                    "value": "\"\\tExperiment save dir '%s' does not exist!\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "expdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.expdir)",
                            "Call"
                        ]
                    ]
                }
            },
            "reset_default_graph_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_107": {
                "msg": {
                    "value": "Encoding:",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_108": {
                "msg": {
                    "value": "encoding.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_109": {
                "msg": {
                    "value": "'Sample length: %d' % sample_length",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "fatal_59": {
                "msg": {
                    "value": "There was a problem determining the latest checkpoint.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ListDirectory_85": {
                "dirname": {
                    "value": "source_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.shell_path(FLAGS.source_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_119": {
                "msg": {
                    "value": "Unexpected error happened: %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/nsynth/wavenet/train.py": {
        "tensorflow": {
            "DEFINE_string_30": {
                "name": {
                    "value": "master",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "BNS name of the TensorFlow master to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_32": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "h512_bo16",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Model configuration name",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_33": {
                "name": {
                    "value": "task",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Task id of the replica running the training.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_35": {
                "name": {
                    "value": "worker_replicas",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of replicas. We train with 32.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_37": {
                "name": {
                    "value": "ps_tasks",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of tasks in the ps job. If 0 no ps job is used. We typically use 11.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "total_batch_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Batch size spread across all sync replicas.We use a size of 32.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_43": {
                "name": {
                    "value": "logdir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/nsynth",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The log directory for this experiment.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_45": {
                "name": {
                    "value": "train_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to the train tfrecord.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_46": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged.DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_52": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_61": {
                "msg": {
                    "value": "'Saving to %s' % logdir",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_134": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_135": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_79": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "constant_86": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "config.learning_rate_schedule[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_99": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0.9999",
                    "type": "float",
                    "possible_values": []
                },
                "num_updates": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('global_step', [], tf.int32, initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "SyncReplicasOptimizer_101": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "tf.train.AdamOptimizer(lr, epsilon=1e-08)",
                    "type": "Call",
                    "possible_values": []
                },
                "replicas_to_aggregate": {
                    "value": "worker_replicas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.worker_replicas",
                            "Attribute"
                        ]
                    ]
                },
                "total_num_replicas": {
                    "value": "worker_replicas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.worker_replicas",
                            "Attribute"
                        ]
                    ]
                },
                "variable_averages": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.ExponentialMovingAverage(decay=0.9999, num_updates=global_step)",
                            "Call"
                        ]
                    ]
                },
                "variables_to_average": {
                    "value": "tf.trainable_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_114": {
                "variable": {
                    "value": "session_config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_73": {
                "device_name": {
                    "value": "cpu_device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/job:localhost/replica:0/task:0/cpu:0'",
                            "str"
                        ],
                        [
                            "'/job:worker/cpu:0'",
                            "str"
                        ]
                    ]
                }
            },
            "device_76": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(ps_tasks=FLAGS.ps_tasks, merge_devices=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_88": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(global_step, key)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : lr",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.constant(value)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "scalar_91": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(config.learning_rate_schedule[0])",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(global_step, key), lambda : lr, lambda : tf.constant(value))",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_96": {
                "name": {
                    "value": "train_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "outputs_dict['loss']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "replica_device_setter_77": {
                "ps_tasks": {
                    "value": "FLAGS.ps_tasks",
                    "type": "Attribute",
                    "possible_values": []
                },
                "merge_devices": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "AdamOptimizer_102": {
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(config.learning_rate_schedule[0])",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(global_step, key), lambda : lr, lambda : tf.constant(value))",
                            "Call"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "1e-08",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_82": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_89": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('global_step', [], tf.int32, initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "key",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "trainable_variables_106": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_89": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/audio_label_data_utils.py": {
        "tensorflow": {
            "Example_224": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={'id': tf.train.Feature(bytes_list=tf.train.BytesList(value=[example_id.encode('utf-8')])), 'sequence': tf.train.Feature(bytes_list=tf.train.BytesList(value=[sus_ns.SerializeToString()])), 'audio': tf.train.Feature(bytes_list=tf.train.BytesList(value=[wav_data])), 'velocity_range': tf.train.Feature(bytes_list=tf.train.BytesList(value=[velocity_range.SerializeToString()]))})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Features_225": {
                "feature": {
                    "value": "{'id': tf.train.Feature(bytes_list=tf.train.BytesList(value=[example_id.encode('utf-8')])), 'sequence': tf.train.Feature(bytes_list=tf.train.BytesList(value=[sus_ns.SerializeToString()])), 'audio': tf.train.Feature(bytes_list=tf.train.BytesList(value=[wav_data])), 'velocity_range': tf.train.Feature(bytes_list=tf.train.BytesList(value=[velocity_range.SerializeToString()]))}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "warning_313": {
                "msg": {
                    "value": "skipping empty sequence",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Feature_228": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[example_id.encode('utf-8')])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_232": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[sus_ns.SerializeToString()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_236": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[wav_data])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_239": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[velocity_range.SerializeToString()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_229": {
                "value": {
                    "value": "[example_id.encode('utf-8')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_233": {
                "value": {
                    "value": "[sus_ns.SerializeToString()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_237": {
                "value": {
                    "value": "[wav_data]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_240": {
                "value": {
                    "value": "[velocity_range.SerializeToString()]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/audio_label_data_utils_test.py": {
        "tensorflow": {
            "main_298": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/audio_transform.py": {
        "tensorflow": {
            "info_211": {
                "msg": {
                    "value": "Executing: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": [
                        [
                            "' '.join(args)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/create_dataset.py": {
        "tensorflow": {
            "DEFINE_string_33": {
                "name": {
                    "value": "output_directory",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to output_directory",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_34": {
                "name": {
                    "value": "min_length",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "minimum length for a segment",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_35": {
                "name": {
                    "value": "max_length",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "maximum length for a segment",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_36": {
                "name": {
                    "value": "sample_rate",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "16000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "sample_rate of the output files",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "preprocess_train_example_multiplier",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "How many times to run data preprocessing on each training example. Useful if preprocessing involves a stochastic process that is useful to sample multiple times.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_45": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "onsets_frames",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_47": {
                "name": {
                    "value": "dataset_config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "maestro",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the dataset config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_49": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A comma-separated list of `name=value` hyperparameter values.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_52": {
                "name": {
                    "value": "pipeline_options",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "--runner=DirectRunner",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Command line flags to use in constructing the Beam pipeline options.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_63": {
                "msg": {
                    "value": "Splitting %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_example.features.feature['id'].bytes_list.value[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_121": {
                "variable": {
                    "value": "example_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_example.SerializeToString()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mark_flags_as_required_181": {
                "flag_names": {
                    "value": "['output_directory']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Exists_192": {
                "filename": {
                    "value": "FLAGS.output_directory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_195": {
                "dirname": {
                    "value": "FLAGS.output_directory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Graph_120": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_127": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "error_105": {
                "msg": {
                    "value": "Exception processing %s. Writing file to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "ns.id",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "output_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(debug_output_directory, output_file)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/create_dataset_lib_test.py": {
        "tensorflow": {
            "disable_v2_behavior_23": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/data.py": {
        "tensorflow": {
            "decode_wav_145": {
                "variable": {
                    "value": "(samples, decoded_sample_rate)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "contents": {
                    "value": "wav_audio",
                    "type": "variable",
                    "possible_values": []
                },
                "desired_channels": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_147": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(samples, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "py_func_180": {
                "variable": {
                    "value": "spectrogram_hash",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "get_spectrogram_hash",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[spectrogram]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "get_spectrogram_hash",
                    "type": "str",
                    "possible_values": []
                }
            },
            "py_func_194": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "functools.partial(wav_to_num_frames, frames_per_second=frames_per_second)",
                    "type": "Call",
                    "possible_values": []
                },
                "inp": {
                    "value": "[wav_audio]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "wav_to_num_frames_op",
                    "type": "str",
                    "possible_values": []
                }
            },
            "py_func_244": {
                "variable": {
                    "value": "(res, weighted_res, onsets, velocities, offsets)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "sequence_to_pianoroll_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[sequence_tensor, velocity_range_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.float32, tf.float32, tf.float32, tf.float32]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "sequence_to_pianoroll_op",
                    "type": "str",
                    "possible_values": []
                }
            },
            "py_func_299": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "truncate",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[sequence_tensor, truncated_length_frames]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "parse_single_example_320": {
                "variable": {
                    "value": "record",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "melspec_input.build_mel_calculation_graph(samples, hparams.sample_rate, window_length_seconds=2048 / hparams.sample_rate, hop_length_seconds=hparams.spec_hop_length / hparams.sample_rate, num_mel_bins=hparams.spec_n_bins, lower_edge_hz=hparams.spec_fmin, upper_edge_hz=hparams.sample_rate / 2.0, frame_width=1, frame_hop=1, tflite_compatible=False)",
                            "Call"
                        ],
                        [
                            "{'id': tf.FixedLenFeature(shape=(), dtype=tf.string), 'sequence': tf.FixedLenFeature(shape=(), dtype=tf.string), 'audio': tf.FixedLenFeature(shape=(), dtype=tf.string), 'velocity_range': tf.FixedLenFeature(shape=(), dtype=tf.string)}",
                            "Dict"
                        ],
                        [
                            "FeatureTensors(spec=tf.reshape(spec, (final_length, hparams_frame_size(hparams), 1)), length=truncated_length, sequence_id=tf.constant(0) if is_training else input_tensors.sequence_id)",
                            "Call"
                        ],
                        [
                            "{'spec': tf.VarLenFeature(dtype=tf.float32), 'spectrogram_hash': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'labels': tf.VarLenFeature(dtype=tf.float32), 'label_weights': tf.VarLenFeature(dtype=tf.float32), 'length': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'onsets': tf.VarLenFeature(dtype=tf.float32), 'offsets': tf.VarLenFeature(dtype=tf.float32), 'velocities': tf.VarLenFeature(dtype=tf.float32), 'sequence_id': tf.FixedLenFeature(shape=(), dtype=tf.string), 'note_sequence': tf.FixedLenFeature(shape=(), dtype=tf.string)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "cast_431": {
                "variable": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_tensors.length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_432": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensors.labels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_433": {
                "variable": {
                    "value": "label_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensors.label_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_434": {
                "variable": {
                    "value": "onsets",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensors.onsets",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_435": {
                "variable": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensors.offsets",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_436": {
                "variable": {
                    "value": "velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensors.velocities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_437": {
                "variable": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_tensors.spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(-1, hparams_frame_size(hparams))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cast_440": {
                "variable": {
                    "value": "hparams_truncated_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hparams.truncated_length_secs * hparams_frames_per_second(hparams)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "case_470": {
                "variable": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(spec_delta < 0, lambda : tf.pad(spec, tf.stack([(0, -spec_delta), (0, 0)]))), (spec_delta > 0, lambda : spec[0:-spec_delta])]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : spec",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "case_476": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(labels_delta < 0, lambda : tf.pad(labels, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : labels[0:-labels_delta])]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : labels",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "case_481": {
                "variable": {
                    "value": "label_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(labels_delta < 0, lambda : tf.pad(label_weights, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : label_weights[0:-labels_delta])]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : label_weights",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "case_486": {
                "variable": {
                    "value": "onsets",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(labels_delta < 0, lambda : tf.pad(onsets, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : onsets[0:-labels_delta])]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : onsets",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "case_491": {
                "variable": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(labels_delta < 0, lambda : tf.pad(offsets, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : offsets[0:-labels_delta])]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : offsets",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "case_496": {
                "variable": {
                    "value": "velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "[(labels_delta < 0, lambda : tf.pad(velocities, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : velocities[0:-labels_delta])]",
                    "type": "List",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : velocities",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "parse_single_example_632": {
                "variable": {
                    "value": "record",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "example_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "melspec_input.build_mel_calculation_graph(samples, hparams.sample_rate, window_length_seconds=2048 / hparams.sample_rate, hop_length_seconds=hparams.spec_hop_length / hparams.sample_rate, num_mel_bins=hparams.spec_n_bins, lower_edge_hz=hparams.spec_fmin, upper_edge_hz=hparams.sample_rate / 2.0, frame_width=1, frame_hop=1, tflite_compatible=False)",
                            "Call"
                        ],
                        [
                            "{'id': tf.FixedLenFeature(shape=(), dtype=tf.string), 'sequence': tf.FixedLenFeature(shape=(), dtype=tf.string), 'audio': tf.FixedLenFeature(shape=(), dtype=tf.string), 'velocity_range': tf.FixedLenFeature(shape=(), dtype=tf.string)}",
                            "Dict"
                        ],
                        [
                            "FeatureTensors(spec=tf.reshape(spec, (final_length, hparams_frame_size(hparams), 1)), length=truncated_length, sequence_id=tf.constant(0) if is_training else input_tensors.sequence_id)",
                            "Call"
                        ],
                        [
                            "{'spec': tf.VarLenFeature(dtype=tf.float32), 'spectrogram_hash': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'labels': tf.VarLenFeature(dtype=tf.float32), 'label_weights': tf.VarLenFeature(dtype=tf.float32), 'length': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'onsets': tf.VarLenFeature(dtype=tf.float32), 'offsets': tf.VarLenFeature(dtype=tf.float32), 'velocities': tf.VarLenFeature(dtype=tf.float32), 'sequence_id': tf.FixedLenFeature(shape=(), dtype=tf.string), 'note_sequence': tf.FixedLenFeature(shape=(), dtype=tf.string)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "concat_663": {
                "variable": {
                    "value": "combined",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tensor[i, :lengths[i]] for i in range(batch_size)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_666": {
                "variable": {
                    "value": "combined_padded",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "combined",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tensor[i, :lengths[i]] for i in range(batch_size)], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[(0, final_length - tf.shape(combined)[0])] + [(0, 0)] * (combined.shape.rank - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "py_func_134": {
                "variable": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "functools.partial(wav_to_spec, hparams=hparams)",
                    "type": "Call",
                    "possible_values": []
                },
                "inp": {
                    "value": "[wav_audio]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "wav_to_spec",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_167": {
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "melspec_input.build_mel_calculation_graph(samples, hparams.sample_rate, window_length_seconds=2048 / hparams.sample_rate, hop_length_seconds=hparams.spec_hop_length / hparams.sample_rate, num_mel_bins=hparams.spec_n_bins, lower_edge_hz=hparams.spec_fmin, upper_edge_hz=hparams.sample_rate / 2.0, frame_width=1, frame_hop=1, tflite_compatible=False)",
                            "Call"
                        ],
                        [
                            "{'id': tf.FixedLenFeature(shape=(), dtype=tf.string), 'sequence': tf.FixedLenFeature(shape=(), dtype=tf.string), 'audio': tf.FixedLenFeature(shape=(), dtype=tf.string), 'velocity_range': tf.FixedLenFeature(shape=(), dtype=tf.string)}",
                            "Dict"
                        ],
                        [
                            "FeatureTensors(spec=tf.reshape(spec, (final_length, hparams_frame_size(hparams), 1)), length=truncated_length, sequence_id=tf.constant(0) if is_training else input_tensors.sequence_id)",
                            "Call"
                        ],
                        [
                            "{'spec': tf.VarLenFeature(dtype=tf.float32), 'spectrogram_hash': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'labels': tf.VarLenFeature(dtype=tf.float32), 'label_weights': tf.VarLenFeature(dtype=tf.float32), 'length': tf.FixedLenFeature(shape=(), dtype=tf.int64), 'onsets': tf.VarLenFeature(dtype=tf.float32), 'offsets': tf.VarLenFeature(dtype=tf.float32), 'velocities': tf.VarLenFeature(dtype=tf.float32), 'sequence_id': tf.FixedLenFeature(shape=(), dtype=tf.string), 'note_sequence': tf.FixedLenFeature(shape=(), dtype=tf.string)}",
                            "Dict"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "py_func_215": {
                "func": {
                    "value": "transform_wav_data",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[wav_data_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "transform_wav_data_op",
                    "type": "str",
                    "possible_values": []
                }
            },
            "py_func_264": {
                "func": {
                    "value": "jitter_label",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[sequence_tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Example_418": {
                "features": {
                    "value": "tf.train.Features(feature=feature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_min_444": {
                "variable": {
                    "value": "truncated_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[hparams_truncated_length, length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_449": {
                "variable": {
                    "value": "truncated_note_sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_149": {
                "control_inputs": {
                    "value": "[tf.assert_equal(decoded_sample_rate, hparams.sample_rate)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "FixedLenFeature_315": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_316": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_317": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_318": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_377": {
                "control_inputs": {
                    "value": "asserts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "Feature_396": {
                "float_list": {
                    "value": "tf.train.FloatList(value=inputs.spec.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_398": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=[inputs.spectrogram_hash])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_400": {
                "float_list": {
                    "value": "tf.train.FloatList(value=inputs.labels.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_402": {
                "float_list": {
                    "value": "tf.train.FloatList(value=inputs.label_weights.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_404": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=[inputs.length])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_406": {
                "float_list": {
                    "value": "tf.train.FloatList(value=inputs.onsets.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_408": {
                "float_list": {
                    "value": "tf.train.FloatList(value=inputs.offsets.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_410": {
                "float_list": {
                    "value": "tf.train.FloatList(value=inputs.velocities.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_412": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[inputs.sequence_id])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_414": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[inputs.note_sequence])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assert_equal_459": {
                "variable": {
                    "value": "assert_op",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hparams.max_expected_train_example_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "hparams_truncated_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(hparams.truncated_length_secs * hparams_frames_per_second(hparams), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "py_func_529": {
                "variable": {
                    "value": "labels_dict[note_sequence]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "func": {
                    "value": "functools.partial(drum_mappings.map_sequences, mapping_name=hparams.drum_data_map)",
                    "type": "Call",
                    "possible_values": []
                },
                "inp": {
                    "value": "[labels_dict['note_sequence']]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "get_drum_sequences",
                    "type": "str",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tf_record_iterator_560": {
                "path": {
                    "value": "sfname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate_sharded_filenames(fname)",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordDataset_604": {
                "variable": {
                    "value": "input_dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filenames",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.data.Dataset.list_files(generate_sharded_filenames(examples), shuffle=shuffle_examples)",
                            "Call"
                        ],
                        [
                            "tf.data.Dataset.from_tensor_slices(sharded_filenames)",
                            "Call"
                        ]
                    ]
                }
            },
            "VarLenFeature_621": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_622": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_623": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_624": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_625": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_626": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_627": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_628": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_629": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_630": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assert_less_equal_375": {
                "x": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wav_to_num_frames_op(audio, hparams_frames_per_second(hparams))",
                            "Call"
                        ],
                        [
                            "tf.cast(input_tensors.length, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "hparams.max_expected_train_example_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Features_418": {
                "feature": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'spec': tf.train.Feature(float_list=tf.train.FloatList(value=inputs.spec.flatten())), 'spectrogram_hash': tf.train.Feature(int64_list=tf.train.Int64List(value=[inputs.spectrogram_hash])), 'labels': tf.train.Feature(float_list=tf.train.FloatList(value=inputs.labels.flatten())), 'label_weights': tf.train.Feature(float_list=tf.train.FloatList(value=inputs.label_weights.flatten())), 'length': tf.train.Feature(int64_list=tf.train.Int64List(value=[inputs.length])), 'onsets': tf.train.Feature(float_list=tf.train.FloatList(value=inputs.onsets.flatten())), 'offsets': tf.train.Feature(float_list=tf.train.FloatList(value=inputs.offsets.flatten())), 'velocities': tf.train.Feature(float_list=tf.train.FloatList(value=inputs.velocities.flatten())), 'sequence_id': tf.train.Feature(bytes_list=tf.train.BytesList(value=[inputs.sequence_id])), 'note_sequence': tf.train.Feature(bytes_list=tf.train.BytesList(value=[inputs.note_sequence]))}",
                            "Dict"
                        ]
                    ]
                }
            },
            "shape_469": {
                "input": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_wav_to_framed_samples(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "_wav_to_cqt(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "_wav_to_mel(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "librosa.power_to_db(spec)",
                            "Call"
                        ],
                        [
                            "tf.py_func(functools.partial(wav_to_spec, hparams=hparams), [wav_audio], tf.float32, name='wav_to_spec')",
                            "Call"
                        ],
                        [
                            "tflite_compat_mel(wav_audio, hparams=hparams)",
                            "Call"
                        ],
                        [
                            "wav_to_spec_op(audio, hparams=hparams)",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensors.spec, (-1, hparams_frame_size(hparams)))",
                            "Call"
                        ],
                        [
                            "tf.case([(spec_delta < 0, lambda : tf.pad(spec, tf.stack([(0, -spec_delta), (0, 0)]))), (spec_delta > 0, lambda : spec[0:-spec_delta])], default=lambda : spec)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_475": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.labels, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(labels, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : labels[0:-labels_delta])], default=lambda : labels)",
                            "Call"
                        ],
                        [
                            "LabelTensors(labels=tf.reshape(labels, (final_length, num_classes)), label_weights=tf.reshape(label_weights, (final_length, num_classes)), onsets=tf.reshape(onsets, (final_length, num_classes)), offsets=tf.reshape(offsets, (final_length, num_classes)), velocities=tf.reshape(velocities, (final_length, num_classes)), note_sequence=truncated_note_sequence)",
                            "Call"
                        ],
                        [
                            "LabelTensors(**labels_dict)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_503": {
                "tensor": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_wav_to_framed_samples(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "_wav_to_cqt(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "_wav_to_mel(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "librosa.power_to_db(spec)",
                            "Call"
                        ],
                        [
                            "tf.py_func(functools.partial(wav_to_spec, hparams=hparams), [wav_audio], tf.float32, name='wav_to_spec')",
                            "Call"
                        ],
                        [
                            "tflite_compat_mel(wav_audio, hparams=hparams)",
                            "Call"
                        ],
                        [
                            "wav_to_spec_op(audio, hparams=hparams)",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensors.spec, (-1, hparams_frame_size(hparams)))",
                            "Call"
                        ],
                        [
                            "tf.case([(spec_delta < 0, lambda : tf.pad(spec, tf.stack([(0, -spec_delta), (0, 0)]))), (spec_delta > 0, lambda : spec[0:-spec_delta])], default=lambda : spec)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(final_length, hparams_frame_size(hparams), 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_507": {
                "tensor": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.labels, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(labels, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : labels[0:-labels_delta])], default=lambda : labels)",
                            "Call"
                        ],
                        [
                            "LabelTensors(labels=tf.reshape(labels, (final_length, num_classes)), label_weights=tf.reshape(label_weights, (final_length, num_classes)), onsets=tf.reshape(onsets, (final_length, num_classes)), offsets=tf.reshape(offsets, (final_length, num_classes)), velocities=tf.reshape(velocities, (final_length, num_classes)), note_sequence=truncated_note_sequence)",
                            "Call"
                        ],
                        [
                            "LabelTensors(**labels_dict)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(final_length, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_508": {
                "tensor": {
                    "value": "label_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.label_weights, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(label_weights, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : label_weights[0:-labels_delta])], default=lambda : label_weights)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(final_length, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_509": {
                "tensor": {
                    "value": "onsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.onsets, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(onsets, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : onsets[0:-labels_delta])], default=lambda : onsets)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(final_length, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_510": {
                "tensor": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.offsets, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(offsets, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : offsets[0:-labels_delta])], default=lambda : offsets)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(final_length, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_511": {
                "tensor": {
                    "value": "velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.velocities, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(velocities, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : velocities[0:-labels_delta])], default=lambda : velocities)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(final_length, num_classes)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "to_dense_634": {
                "sp_input": {
                    "value": "record['spec']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_dense_636": {
                "sp_input": {
                    "value": "record['labels']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_dense_637": {
                "sp_input": {
                    "value": "record['label_weights']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_dense_639": {
                "sp_input": {
                    "value": "record['onsets']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_dense_640": {
                "sp_input": {
                    "value": "record['offsets']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "to_dense_641": {
                "sp_input": {
                    "value": "record['velocities']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "assert_equal_150": {
                "x": {
                    "value": "decoded_sample_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "hparams.sample_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FloatList_397": {
                "value": {
                    "value": "inputs.spec.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Int64List_399": {
                "value": {
                    "value": "[inputs.spectrogram_hash]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "FloatList_401": {
                "value": {
                    "value": "inputs.labels.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FloatList_403": {
                "value": {
                    "value": "inputs.label_weights.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Int64List_405": {
                "value": {
                    "value": "[inputs.length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "FloatList_407": {
                "value": {
                    "value": "inputs.onsets.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FloatList_409": {
                "value": {
                    "value": "inputs.offsets.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FloatList_411": {
                "value": {
                    "value": "inputs.velocities.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_413": {
                "value": {
                    "value": "[inputs.sequence_id]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_415": {
                "value": {
                    "value": "[inputs.note_sequence]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "control_dependencies_461": {
                "control_inputs": {
                    "value": "[assert_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_505": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "parallel_interleave_601": {
                "map_func": {
                    "value": "tf.data.TFRecordDataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sloppy": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "cycle_length": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_472": {
                "tensor": {
                    "value": "spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_wav_to_framed_samples(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "_wav_to_cqt(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "_wav_to_mel(wav_audio, hparams)",
                            "Call"
                        ],
                        [
                            "librosa.power_to_db(spec)",
                            "Call"
                        ],
                        [
                            "tf.py_func(functools.partial(wav_to_spec, hparams=hparams), [wav_audio], tf.float32, name='wav_to_spec')",
                            "Call"
                        ],
                        [
                            "tflite_compat_mel(wav_audio, hparams=hparams)",
                            "Call"
                        ],
                        [
                            "wav_to_spec_op(audio, hparams=hparams)",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_tensors.spec, (-1, hparams_frame_size(hparams)))",
                            "Call"
                        ],
                        [
                            "tf.case([(spec_delta < 0, lambda : tf.pad(spec, tf.stack([(0, -spec_delta), (0, 0)]))), (spec_delta > 0, lambda : spec[0:-spec_delta])], default=lambda : spec)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.stack([(0, -spec_delta), (0, 0)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_478": {
                "tensor": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.labels, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(labels, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : labels[0:-labels_delta])], default=lambda : labels)",
                            "Call"
                        ],
                        [
                            "LabelTensors(labels=tf.reshape(labels, (final_length, num_classes)), label_weights=tf.reshape(label_weights, (final_length, num_classes)), onsets=tf.reshape(onsets, (final_length, num_classes)), offsets=tf.reshape(offsets, (final_length, num_classes)), velocities=tf.reshape(velocities, (final_length, num_classes)), note_sequence=truncated_note_sequence)",
                            "Call"
                        ],
                        [
                            "LabelTensors(**labels_dict)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.stack([(0, -labels_delta), (0, 0)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_483": {
                "tensor": {
                    "value": "label_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.label_weights, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(label_weights, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : label_weights[0:-labels_delta])], default=lambda : label_weights)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.stack([(0, -labels_delta), (0, 0)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_488": {
                "tensor": {
                    "value": "onsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.onsets, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(onsets, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : onsets[0:-labels_delta])], default=lambda : onsets)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.stack([(0, -labels_delta), (0, 0)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_493": {
                "tensor": {
                    "value": "offsets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.offsets, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(offsets, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : offsets[0:-labels_delta])], default=lambda : offsets)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.stack([(0, -labels_delta), (0, 0)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_498": {
                "tensor": {
                    "value": "velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(input_tensors.velocities, (-1, num_classes))",
                            "Call"
                        ],
                        [
                            "tf.case([(labels_delta < 0, lambda : tf.pad(velocities, tf.stack([(0, -labels_delta), (0, 0)]))), (labels_delta > 0, lambda : velocities[0:-labels_delta])], default=lambda : velocities)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.stack([(0, -labels_delta), (0, 0)])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_691": {
                "input_tensor": {
                    "value": "features.length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_692": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_699": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_472": {
                "values": {
                    "value": "[(0, -spec_delta), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_478": {
                "values": {
                    "value": "[(0, -labels_delta), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_483": {
                "values": {
                    "value": "[(0, -labels_delta), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_488": {
                "values": {
                    "value": "[(0, -labels_delta), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_493": {
                "values": {
                    "value": "[(0, -labels_delta), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_498": {
                "values": {
                    "value": "[(0, -labels_delta), (0, 0)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_667": {
                "input": {
                    "value": "combined",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tensor[i, :lengths[i]] for i in range(batch_size)], axis=0)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/data_test.py": {
        "tensorflow": {
            "disable_v2_behavior_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_239": {
                "variable": {
                    "value": "examples_ph",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "main_317": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Example_55": {
                "features": {
                    "value": "tf.train.Features(feature=feature_dict)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "make_initializable_iterator_134": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data.provide_batch(examples=examples, preprocess_examples=True, params=hparams, is_training=False, shuffle_examples=False, skip_n_initial_records=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_307": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[1, 2, 3, 0, 0], [4, 5, 0, 0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_308": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_311": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Feature_41": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[filename.encode('utf-8')])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_45": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[sequence.SerializeToString()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_49": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[wav_data])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_51": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[velocity_range.SerializeToString()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Graph_306": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Features_55": {
                "feature": {
                    "value": "feature_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'id': tf.train.Feature(bytes_list=tf.train.BytesList(value=[filename.encode('utf-8')])), 'sequence': tf.train.Feature(bytes_list=tf.train.BytesList(value=[sequence.SerializeToString()])), 'audio': tf.train.Feature(bytes_list=tf.train.BytesList(value=[wav_data])), 'velocity_range': tf.train.Feature(bytes_list=tf.train.BytesList(value=[velocity_range.SerializeToString()]))}",
                            "Dict"
                        ]
                    ]
                }
            },
            "TFRecordWriter_208": {
                "path": {
                    "value": "temp_tfr.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "BytesList_42": {
                "value": {
                    "value": "[filename.encode('utf-8')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_46": {
                "value": {
                    "value": "[sequence.SerializeToString()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_49": {
                "value": {
                    "value": "[wav_data]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_52": {
                "value": {
                    "value": "[velocity_range.SerializeToString()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "local_variables_137": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_138": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/drum_mappings.py": {
        "tensorflow": {
            "stack_144": {
                "values": {
                    "value": "mapped_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "warn_158": {
                "msg": {
                    "value": "Could not find mapping for pitch %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "note.pitch",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_143": {
                "input": {
                    "value": "pianoroll[:, pitch]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_130": {
                "x": {
                    "value": "tf.math.reduce_any(tf.cast(tf.gather(pianoroll, mapped_pitches[pitch], axis=1), tf.bool), axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "pianoroll.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_131": {
                "input_tensor": {
                    "value": "tf.cast(tf.gather(pianoroll, mapped_pitches[pitch], axis=1), tf.bool)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_138": {
                "input_tensor": {
                    "value": "tf.gather(pianoroll, mapped_pitches[pitch], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_132": {
                "x": {
                    "value": "tf.gather(pianoroll, mapped_pitches[pitch], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_139": {
                "params": {
                    "value": "pianoroll",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "mapped_pitches[pitch]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_133": {
                "params": {
                    "value": "pianoroll",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "mapped_pitches[pitch]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/estimator_spec_util.py": {
        "tensorflow": {
            "py_func_121": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "functools.partial(predict_sequence, hparams=hparams)",
                    "type": "Call",
                    "possible_values": []
                },
                "inp": {
                    "value": "[frame_probs[i], onset_probs[i], frame_predictions[i], onset_predictions[i], offset_predictions[i], velocity_values[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_135": {
                "values": {
                    "value": "sequences",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_145": {
                "variable": {
                    "value": "onset_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "multi_class_labels": {
                    "value": "labels.onsets[:, :, :constants.MIDI_PITCHES]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "logits": {
                    "value": "onset_logits[:, :, :constants.MIDI_PITCHES]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "weights": {
                    "value": "tf.expand_dims(tf.sequence_mask(features.length, maxlen=tf.shape(labels.onsets)[1]), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_squared_error_164": {
                "variable": {
                    "value": "velocity_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "y_true": {
                    "value": "labels.velocities",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y_pred": {
                    "value": "velocity_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(map_values, velocity_values)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "labels.onsets * hparams.velocity_loss_weight",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_total_loss_179": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_182": {
                "variable": {
                    "value": "frame_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "frame_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sigmoid_183": {
                "variable": {
                    "value": "onset_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "onset_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_155": {
                "variable": {
                    "value": "offset_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "multi_class_labels": {
                    "value": "labels.offsets[:, :, :constants.MIDI_PITCHES]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "logits": {
                    "value": "offset_logits[:, :, :constants.MIDI_PITCHES]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "weights": {
                    "value": "tf.expand_dims(tf.sequence_mask(features.length, maxlen=tf.shape(labels.offsets)[1]), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_170": {
                "variable": {
                    "value": "frame_losses",
                    "type": "variable",
                    "possible_values": []
                },
                "multi_class_labels": {
                    "value": "labels.labels[:, :, :constants.MIDI_PITCHES]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "logits": {
                    "value": "frame_logits[:, :, :constants.MIDI_PITCHES]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "weights": {
                    "value": "tf.expand_dims(tf.sequence_mask(features.length, maxlen=tf.shape(labels.labels)[1]), axis=2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_185": {
                "variable": {
                    "value": "offset_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "offset_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_like_187": {
                "variable": {
                    "value": "offset_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "onset_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(onset_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_198": {
                "variable": {
                    "value": "frame_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "map_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "functools.partial(drum_mappings.map_pianoroll, mapping_name=hparams.drum_prediction_map, reduce_mode='any', min_pitch=constants.MIN_MIDI_PITCH)",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "frame_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "frame_probs > hparams.predict_frame_threshold",
                            "Compare"
                        ],
                        [
                            "tf.map_fn(map_predictions, frame_predictions)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_199": {
                "variable": {
                    "value": "onset_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "map_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "functools.partial(drum_mappings.map_pianoroll, mapping_name=hparams.drum_prediction_map, reduce_mode='any', min_pitch=constants.MIN_MIDI_PITCH)",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "onset_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "onset_probs > hparams.predict_onset_threshold",
                            "Compare"
                        ],
                        [
                            "tf.map_fn(map_predictions, onset_predictions)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_200": {
                "variable": {
                    "value": "offset_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "map_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "functools.partial(drum_mappings.map_pianoroll, mapping_name=hparams.drum_prediction_map, reduce_mode='any', min_pitch=constants.MIN_MIDI_PITCH)",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "offset_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "offset_probs > hparams.predict_offset_threshold",
                            "Compare"
                        ],
                        [
                            "tf.map_fn(map_predictions, offset_predictions)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_fn_206": {
                "variable": {
                    "value": "velocity_values",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "map_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "functools.partial(drum_mappings.map_pianoroll, mapping_name=hparams.drum_prediction_map, reduce_mode='max', min_pitch=constants.MIN_MIDI_PITCH)",
                            "Call"
                        ]
                    ]
                },
                "elems": {
                    "value": "velocity_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(map_values, velocity_values)",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUEstimatorSpec_232": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.losses.get_total_loss()",
                            "Call"
                        ]
                    ]
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.optimize_loss(name='training', loss=loss, global_step=tf.train.get_or_create_global_step(), learning_rate=hparams.learning_rate, learning_rate_decay_fn=functools.partial(tf.train.exponential_decay, decay_steps=hparams.decay_steps, decay_rate=hparams.decay_rate, staircase=True), clip_gradients=hparams.clip_norm, summaries=[], optimizer=lambda lr: tf.tpu.CrossShardOptimizer(tf.train.AdamOptimizer(lr)))",
                            "Call"
                        ]
                    ]
                }
            },
            "EstimatorSpec_236": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.losses.get_total_loss()",
                            "Call"
                        ]
                    ]
                },
                "eval_metric_ops": {
                    "value": "metric_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "metrics.define_metrics(frame_probs=frame_probs, onset_probs=onset_probs, frame_predictions=onset_predictions, onset_predictions=onset_predictions, offset_predictions=onset_predictions, velocity_values=velocity_values, length=features.length, sequence_label=labels.note_sequence, frame_labels=labels.labels, sequence_id=features.sequence_id, hparams=hparams, min_pitch=constants.MIN_MIDI_PITCH, max_pitch=constants.MAX_MIDI_PITCH, prefix='drums/', onsets_only=True, pitch_map=drum_mappings.GROOVE_PITCH_NAMES)",
                            "Call"
                        ],
                        [
                            "{k: tf.metrics.mean(v) for (k, v) in metrics_values.items()}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "expand_dims_148": {
                "input": {
                    "value": "tf.sequence_mask(features.length, maxlen=tf.shape(labels.onsets)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_220": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mean_235": {
                "a": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_273": {
                "variable": {
                    "value": "predictions[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "EstimatorSpec_275": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'frame_probs': frame_probs, 'onset_probs': onset_probs, 'frame_predictions': frame_predictions, 'onset_predictions': onset_predictions, 'offset_predictions': offset_predictions, 'velocity_values': velocity_values, 'sequence_predictions': _predict_sequences(frame_probs=frame_probs, onset_probs=onset_probs, frame_predictions=frame_predictions, onset_predictions=onset_predictions, offset_predictions=offset_predictions, velocity_values=velocity_values, hparams=hparams), 'sequence_ids': features.sequence_id, 'sequence_labels': labels.note_sequence, 'frame_labels': labels.labels, 'onset_labels': labels.onsets}",
                            "Dict"
                        ]
                    ]
                }
            },
            "sequence_mask_149": {
                "lengths": {
                    "value": "features.length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(labels.onsets)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_158": {
                "input": {
                    "value": "tf.sequence_mask(features.length, maxlen=tf.shape(labels.offsets)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_173": {
                "input": {
                    "value": "tf.sequence_mask(features.length, maxlen=tf.shape(labels.labels)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CrossShardOptimizer_230": {
                "opt": {
                    "value": "tf.train.AdamOptimizer(lr)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sequence_mask_159": {
                "lengths": {
                    "value": "features.length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(labels.offsets)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sequence_mask_174": {
                "lengths": {
                    "value": "features.length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(labels.labels)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "AdamOptimizer_230": {
                "learning_rate": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_150": {
                "input": {
                    "value": "labels.onsets",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_160": {
                "input": {
                    "value": "labels.offsets",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_175": {
                "input": {
                    "value": "labels.labels",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/infer.py": {
        "tensorflow": {
            "DEFINE_string_41": {
                "name": {
                    "value": "master",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the TensorFlow runtime to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_43": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "onsets_frames",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_45": {
                "name": {
                    "value": "model_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to look for checkpoints.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_46": {
                "name": {
                    "value": "checkpoint_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Filename of the checkpoint to use. If not specified, will use the latest checkpoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_50": {
                "name": {
                    "value": "examples_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to test examples TFRecord.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_52": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "~/tmp/onsets_frames/infer",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to store output midi files and summary events.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_55": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A comma-separated list of `name=value` hyperparameter values.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_60": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged: DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FileWriter_208": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_80": {
                "msg": {
                    "value": "model_dir=%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_81": {
                "msg": {
                    "value": "checkpoint_path=%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_82": {
                "msg": {
                    "value": "examples_path=%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "examples_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_83": {
                "msg": {
                    "value": "output_dir=%s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_204": {
                "msg": {
                    "value": "hparams",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config.hparams",
                            "Attribute"
                        ]
                    ]
                }
            },
            "MakeDirs_206": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "text_217": {
                "variable": {
                    "value": "run_config_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "run_config",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.constant(run_config, name='run_config')",
                    "type": "Call",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "info_118": {
                "msg": {
                    "value": "Infer time %f, frames %d, frames/sec %f, running average %f",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "infer_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "end_time - start_time",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "num_frames[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "info_123": {
                "msg": {
                    "value": "Scoring sequence %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "predictions['sequence_ids']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "info_137": {
                "msg": {
                    "value": "Writing inferred midi file to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, filename_safe + '.mid')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_141": {
                "msg": {
                    "value": "Writing label midi file to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "label_output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, filename_safe + '_label.mid')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_147": {
                "msg": {
                    "value": "Writing acoustic logit/label file to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "pianoroll_output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, filename_safe + '_pianoroll.png')",
                            "Call"
                        ]
                    ]
                }
            },
            "Graph_185": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_185": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_188": {
                "variable": {
                    "value": "metric_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "final_scalar_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'final/' + k",
                            "BinOp"
                        ]
                    ]
                },
                "data": {
                    "value": "np.mean(v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_210": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GFile_157": {
                "name": {
                    "value": "pianoroll_output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, filename_safe + '_pianoroll.png')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_169": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_169": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "histogram_175": {
                "variable": {
                    "value": "metric_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "histogram_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "k + '_histogram'",
                            "BinOp"
                        ]
                    ]
                },
                "data": {
                    "value": "all_metrics[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_178": {
                "variable": {
                    "value": "metric_summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "scalar_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "k",
                            "variable"
                        ]
                    ]
                },
                "data": {
                    "value": "np.mean(all_metrics[k])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_219": {
                "value": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'\\n\\n'.join(['model_dir: ' + FLAGS.model_dir, 'checkpoint_path: ' + str(FLAGS.checkpoint_path), 'examples_path: ' + FLAGS.examples_path, str(hparams)])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "run_config",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/infer_util_test.py": {
        "tensorflow": {
            "disable_v2_behavior_26": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_41": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/melspec_input.py": {
        "tensorflow": {
            "abs_45": {
                "variable": {
                    "value": "stft_magnitude",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.signal.stft(waveform_input, frame_length=window_length_samples, frame_step=hop_length_samples, fft_length=fft_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "magnitude_spectrogram",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_72": {
                "variable": {
                    "value": "real_dft_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.real(complex_dft_matrix_kept_values).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "real_dft_matrix",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_75": {
                "variable": {
                    "value": "imag_dft_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.imag(complex_dft_matrix_kept_values).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "imaginary_dft_matrix",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_80": {
                "variable": {
                    "value": "pad_values",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros([tf.rank(signal_tensor) - 1, 2], tf.int32), [[half_pad, fft_length - signal_frame_length - half_pad]]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_85": {
                "variable": {
                    "value": "padded_signal",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "signal_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "paddings": {
                    "value": "pad_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.zeros([tf.rank(signal_tensor) - 1, 2], tf.int32), [[half_pad, fft_length - signal_frame_length - half_pad]]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_86": {
                "variable": {
                    "value": "result_real_part",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "padded_signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(signal_tensor, pad_values)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "real_dft_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.real(complex_dft_matrix_kept_values).astype(np.float32), name='real_dft_matrix')",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_87": {
                "variable": {
                    "value": "result_imag_part",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "padded_signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(signal_tensor, pad_values)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "imag_dft_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.imag(complex_dft_matrix_kept_values).astype(np.float32), name='imaginary_dft_matrix')",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_140": {
                "variable": {
                    "value": "subframes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.slice(signal, begin=np.zeros(len(signal_shape), np.int32), size=trimmed_input_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "subframe_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[num_subframes, subframe_length] + inner_dimensions",
                            "BinOp"
                        ],
                        [
                            "outer_dimensions + [num_subframes, subframe_length]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_164": {
                "variable": {
                    "value": "frames",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.gather(subframes, selector.astype(np.int32), axis=gather_axis)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "result_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[num_frames, frame_length] + inner_dimensions",
                            "BinOp"
                        ],
                        [
                            "outer_dimensions + [num_frames, frame_length]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_193": {
                "variable": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.constant((0.5 - 0.5 * np.cos(2 * np.pi * np.arange(0, 1.0, 1.0 / frame_length))).astype(np.float32), name='window')",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, frame_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_213": {
                "variable": {
                    "value": "stft_magnitude",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.add(real_stft * real_stft, imag_stft * imag_stft)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "magnitude_spectrogram",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_279": {
                "variable": {
                    "value": "mel_spectrogram",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "magnitude_spectrogram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_stft_magnitude_tflite(waveform_input, window_length_samples, hop_length_samples, fft_length)",
                            "Call"
                        ],
                        [
                            "_stft_magnitude_full_tf(waveform_input, window_length_samples, hop_length_samples, fft_length)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "linear_to_mel_weight_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(mfcc_mel.SpectrogramToMelMatrix(num_mel_bins, num_spectrogram_bins, sample_rate, lower_edge_hz, upper_edge_hz).astype(np.float32), name='linear_to_mel_matrix')",
                            "Call"
                        ],
                        [
                            "tf.signal.linear_to_mel_weight_matrix(num_mel_bins, num_spectrogram_bins, sample_rate, lower_edge_hz, upper_edge_hz)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "mel_spectrogram",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_284": {
                "variable": {
                    "value": "log_mel_spectrogram",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mel_spectrogram + log_offset",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "log_mel_spectrogram",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_266": {
                "variable": {
                    "value": "linear_to_mel_weight_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mfcc_mel.SpectrogramToMelMatrix(num_mel_bins, num_spectrogram_bins, sample_rate, lower_edge_hz, upper_edge_hz).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "linear_to_mel_matrix",
                    "type": "str",
                    "possible_values": []
                }
            },
            "linear_to_mel_weight_matrix_275": {
                "variable": {
                    "value": "linear_to_mel_weight_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "num_mel_bins": {
                    "value": "num_mel_bins",
                    "type": "variable",
                    "possible_values": [
                        [
                            "64",
                            "Method Argument"
                        ]
                    ]
                },
                "num_spectrogram_bins": {
                    "value": "num_spectrogram_bins",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(magnitude_spectrogram.shape[-1])",
                            "Call"
                        ]
                    ]
                },
                "sample_rate": {
                    "value": "sample_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "16000",
                            "Method Argument"
                        ]
                    ]
                },
                "lower_edge_hertz": {
                    "value": "lower_edge_hz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "125.0",
                            "Method Argument"
                        ]
                    ]
                },
                "upper_edge_hertz": {
                    "value": "upper_edge_hz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "7500.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "frame_294": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "signal": {
                    "value": "log_mel_spectrogram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(mel_spectrogram + log_offset, name='log_mel_spectrogram')",
                            "Call"
                        ]
                    ]
                },
                "frame_length": {
                    "value": "frame_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "96",
                            "Method Argument"
                        ]
                    ]
                },
                "frame_step": {
                    "value": "frame_hop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stft_46": {
                "signals": {
                    "value": "waveform_input",
                    "type": "variable",
                    "possible_values": []
                },
                "frame_length": {
                    "value": "window_length_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(round(window_length_seconds * sample_rate))",
                            "Call"
                        ]
                    ]
                },
                "frame_step": {
                    "value": "hop_length_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(round(hop_length_seconds * sample_rate))",
                            "Call"
                        ]
                    ]
                },
                "fft_length": {
                    "value": "fft_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2 ** int(math.ceil(math.log(window_length_samples) / math.log(2.0)))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "slice_141": {
                "input_": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "begin": {
                    "value": "np.zeros(len(signal_shape), np.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "size": {
                    "value": "trimmed_input_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[num_subframes * subframe_length] + inner_dimensions",
                            "BinOp"
                        ],
                        [
                            "outer_dimensions + [num_subframes * subframe_length]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "gather_165": {
                "params": {
                    "value": "subframes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.slice(signal, begin=np.zeros(len(signal_shape), np.int32), size=trimmed_input_size), subframe_shape)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "selector.astype(np.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "gather_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "len(outer_dimensions)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_194": {
                "value": {
                    "value": "(0.5 - 0.5 * np.cos(2 * np.pi * np.arange(0, 1.0, 1.0 / frame_length))).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "window",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_214": {
                "x": {
                    "value": "real_stft * real_stft",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "imag_stft * imag_stft",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_81": {
                "shape": {
                    "value": "[tf.rank(signal_tensor) - 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "rank_81": {
                "input": {
                    "value": "signal_tensor",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/melspec_input_test.py": {
        "tensorflow": {
            "disable_v2_behavior_23": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_102": {
                "variable": {
                    "value": "self._graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_103": {
                "variable": {
                    "value": "self._session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "self._graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Interpreter_144": {
                "variable": {
                    "value": "interpreter",
                    "type": "variable",
                    "possible_values": []
                },
                "model_path": {
                    "value": "tflite_model_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "main_169": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_80": {
                "variable": {
                    "value": "waveform_input",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[input_length]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/metrics.py": {
        "tensorflow": {
            "cast_71": {
                "variable": {
                    "value": "frame_labels_bool",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "frame_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_72": {
                "variable": {
                    "value": "frame_predictions_bool",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "frame_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "variable": {
                    "value": "frame_true_positives",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(tf.logical_and(tf.equal(frame_labels_bool, True), tf.equal(frame_predictions_bool, True)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_77": {
                "variable": {
                    "value": "frame_false_positives",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(tf.logical_and(tf.equal(frame_labels_bool, False), tf.equal(frame_predictions_bool, True)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_80": {
                "variable": {
                    "value": "frame_false_negatives",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.to_float(tf.logical_and(tf.equal(frame_labels_bool, True), tf.equal(frame_predictions_bool, False)))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_88": {
                "variable": {
                    "value": "frame_precision",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(frame_true_positives + frame_false_positives, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.div(frame_true_positives, frame_true_positives + frame_false_positives)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_93": {
                "variable": {
                    "value": "frame_recall",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(frame_true_positives + frame_false_negatives, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.div(frame_true_positives, frame_true_positives + frame_false_negatives)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "py_func_319": {
                "variable": {
                    "value": "(note_precision, note_recall, note_f1, note_density, note_with_velocity_precision, note_with_velocity_recall, note_with_velocity_f1, note_with_offsets_precision, note_with_offsets_recall, note_with_offsets_f1, note_with_offsets_velocity_precision, note_with_offsets_velocity_recall, note_with_offsets_velocity_f1, processed_frame_predictions)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "functools.partial(_calculate_metrics_py, hparams=hparams, min_pitch=min_pitch, max_pitch=max_pitch, onsets_only=onsets_only)",
                    "type": "Call",
                    "possible_values": []
                },
                "inp": {
                    "value": "[frame_probs, onset_probs, frame_predictions, onset_predictions, offset_predictions, velocity_values, sequence_label, frame_labels, sequence_id]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float64] * 13 + [tf.float32]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "where_47": {
                "condition": {
                    "value": "tf.greater(precision + recall, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "2 * (precision * recall / (precision + recall))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_64": {
                "condition": {
                    "value": "tf.greater(true_positives + false_positives + false_negatives, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "true_positives / (true_positives + false_positives + false_negatives)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "info_130": {
                "msg": {
                    "value": "Calculating metrics for %s with length %d",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "sequence_id",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "frame_labels.shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "info_226": {
                "msg": {
                    "value": "Metrics for %s: Note F1 %f, Note w/ velocity F1 %f, Note w/ offsets F1 %f, Note w/ offsets & velocity: %f",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "sequence_id",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "note_f1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "greater_48": {
                "x": {
                    "value": "precision + recall",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_65": {
                "x": {
                    "value": "true_positives + false_positives + false_negatives",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_74": {
                "x": {
                    "value": "tf.logical_and(tf.equal(frame_labels_bool, True), tf.equal(frame_predictions_bool, True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_77": {
                "x": {
                    "value": "tf.logical_and(tf.equal(frame_labels_bool, False), tf.equal(frame_predictions_bool, True))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_80": {
                "x": {
                    "value": "tf.logical_and(tf.equal(frame_labels_bool, True), tf.equal(frame_predictions_bool, False))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_84": {
                "input_tensor": {
                    "value": "tf.to_float(tf.equal(frame_labels_bool, frame_predictions_bool))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_86": {
                "x": {
                    "value": "tf.size(frame_labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_89": {
                "x": {
                    "value": "frame_true_positives + frame_false_positives",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "div_90": {
                "x": {
                    "value": "frame_true_positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.to_float(tf.logical_and(tf.equal(frame_labels_bool, True), tf.equal(frame_predictions_bool, True))))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "frame_true_positives + frame_false_positives",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "greater_94": {
                "x": {
                    "value": "frame_true_positives + frame_false_negatives",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "div_95": {
                "x": {
                    "value": "frame_true_positives",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.to_float(tf.logical_and(tf.equal(frame_labels_bool, True), tf.equal(frame_predictions_bool, True))))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "frame_true_positives + frame_false_negatives",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_184": {
                "msg": {
                    "value": "Reference pitches were length 0, returning empty metrics for %s:",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "sequence_id",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "py_func_358": {
                "variable": {
                    "value": "(note_precision, note_recall, note_f1, note_density, note_with_velocity_precision, note_with_velocity_recall, note_with_velocity_f1, note_with_offsets_precision, note_with_offsets_recall, note_with_offsets_f1, note_with_offsets_velocity_precision, note_with_offsets_velocity_recall, note_with_offsets_velocity_f1, processed_frame_predictions)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "functools.partial(_calculate_metrics_py, hparams=hparams, min_pitch=min_pitch, max_pitch=max_pitch, onsets_only=onsets_only, restrict_to_pitch=pitch)",
                    "type": "Call",
                    "possible_values": []
                },
                "inp": {
                    "value": "[frame_probs, onset_probs, frame_predictions, onset_predictions, offset_predictions, velocity_values, sequence_label, frame_labels, sequence_id + name]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float64] * 13 + [tf.float32]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_412": {
                "device_name": {
                    "value": "/device:CPU:*",
                    "type": "str",
                    "possible_values": []
                }
            },
            "logical_and_74": {
                "x": {
                    "value": "tf.equal(frame_labels_bool, True)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(frame_predictions_bool, True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_77": {
                "x": {
                    "value": "tf.equal(frame_labels_bool, False)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(frame_predictions_bool, True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_80": {
                "x": {
                    "value": "tf.equal(frame_labels_bool, True)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(frame_predictions_bool, False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_85": {
                "x": {
                    "value": "tf.equal(frame_labels_bool, frame_predictions_bool)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "size_86": {
                "input": {
                    "value": "frame_labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "equal_75": {
                "x": {
                    "value": "frame_labels_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_labels, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "equal_76": {
                "x": {
                    "value": "frame_predictions_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_predictions, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "equal_78": {
                "x": {
                    "value": "frame_labels_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_labels, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "equal_79": {
                "x": {
                    "value": "frame_predictions_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_predictions, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "equal_81": {
                "x": {
                    "value": "frame_labels_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_labels, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "equal_82": {
                "x": {
                    "value": "frame_predictions_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_predictions, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "equal_85": {
                "x": {
                    "value": "frame_labels_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_labels, tf.bool)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "frame_predictions_bool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(frame_predictions, tf.bool)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/model.py": {
        "tensorflow": {
            "expand_dims_301": {
                "variable": {
                    "value": "frame_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "frame_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "frame_probs_flat > hparams.predict_frame_threshold",
                            "Compare"
                        ],
                        [
                            "tf.expand_dims(frame_predictions, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_302": {
                "variable": {
                    "value": "onset_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "onset_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "onset_probs_flat > hparams.predict_onset_threshold",
                            "Compare"
                        ],
                        [
                            "tf.expand_dims(onset_predictions, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_303": {
                "variable": {
                    "value": "offset_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "offset_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "offset_probs_flat > hparams.predict_offset_threshold",
                            "Compare"
                        ],
                        [
                            "tf.expand_dims(offset_predictions, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_304": {
                "variable": {
                    "value": "velocity_values",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "velocity_values_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_maybe_padded_sequences(velocity_values, length)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_66": {
                "variable": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "slim.conv2d(net, num_filters, [conv_temporal_size, conv_freq_size], scope='conv' + str(i), normalizer_fn=slim.batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (dims[0], dims[1], net.shape[2] * net.shape[3]), 'flatten_end')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, hparams.fc_size, scope='fc_end')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, hparams.fc_dropout_keep_amt, scope='dropout_end')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [1, freq_pool_size], stride=[1, freq_pool_size], scope='pool' + str(i))",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, dropout_amt, scope='dropout' + str(i))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_67": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "slim.conv2d(net, num_filters, [conv_temporal_size, conv_freq_size], scope='conv' + str(i), normalizer_fn=slim.batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (dims[0], dims[1], net.shape[2] * net.shape[3]), 'flatten_end')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, hparams.fc_size, scope='fc_end')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, hparams.fc_dropout_keep_amt, scope='dropout_end')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [1, freq_pool_size], stride=[1, freq_pool_size], scope='pool' + str(i))",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, dropout_amt, scope='dropout' + str(i))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(dims[0], dims[1], net.shape[2] * net.shape[3])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "flatten_end",
                    "type": "str",
                    "possible_values": []
                }
            },
            "py_func_340": {
                "variable": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "_predict",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[frame_probs[0], onset_probs[0], frame_predictions[0], onset_predictions[0], offset_predictions[0], velocity_values[0]]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_371": {
                "variable": {
                    "value": "predictions[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "concat_380": {
                "variable": {
                    "value": "onset_pianorolls",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[onset_labels[:, :, :, tf.newaxis], onset_probs[:, :, :, tf.newaxis], tf.zeros(tf.shape(onset_labels))[:, :, :, tf.newaxis]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_386": {
                "variable": {
                    "value": "offset_pianorolls",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_labels[:, :, :, tf.newaxis], offset_probs[:, :, :, tf.newaxis], tf.zeros(tf.shape(offset_labels))[:, :, :, tf.newaxis]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_392": {
                "variable": {
                    "value": "activation_pianorolls",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[frame_labels[:, :, :, tf.newaxis], frame_probs[:, :, :, tf.newaxis], tf.zeros(tf.shape(frame_labels))[:, :, :, tf.newaxis]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_total_loss_401": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "EstimatorSpec_420": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "predictions": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'frame_probs': frame_probs, 'onset_probs': onset_probs, 'frame_predictions': frame_predictions, 'onset_predictions': onset_predictions, 'offset_predictions': offset_predictions, 'velocity_values': velocity_values, 'sequence_predictions': predict_sequence(), 'sequence_ids': features.sequence_id, 'sequence_labels': labels.note_sequence, 'frame_labels': labels.labels, 'onset_labels': labels.onsets}",
                            "Dict"
                        ]
                    ]
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.losses.get_total_loss()",
                            "Call"
                        ]
                    ]
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "slim.optimize_loss(name='training', loss=loss, global_step=tf.train.get_or_create_global_step(), learning_rate=hparams.learning_rate, learning_rate_decay_fn=functools.partial(tf.train.exponential_decay, decay_steps=hparams.decay_steps, decay_rate=hparams.decay_rate, staircase=True), clip_gradients=hparams.clip_norm, optimizer='Adam')",
                            "Call"
                        ]
                    ]
                },
                "eval_metric_ops": {
                    "value": "metric_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{k: tf.metrics.mean(v) for (k, v) in metrics_values.items()}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "warning_86": {
                "msg": {
                    "value": "cuDNN LSTM no longer supported. Using regular LSTM.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_99": {
                "name_or_scope": {
                    "value": "cudnn_lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_251": {
                "variable": {
                    "value": "combined_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_353": {
                "input": {
                    "value": "sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.py_func(_predict, inp=[frame_probs[0], onset_probs[0], frame_predictions[0], onset_predictions[0], offset_predictions[0], velocity_values[0]], Tout=tf.string, stateful=False)",
                            "Call"
                        ],
                        [
                            "infer_util.predict_sequence(frame_probs=frame_probs, onset_probs=onset_probs, frame_predictions=frame_predictions, onset_predictions=onset_predictions, offset_predictions=offset_predictions, velocity_values=velocity_values, hparams=hparams, min_pitch=constants.MIN_MIDI_PITCH)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "mean_373": {
                "a": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "scalar_402": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.losses.get_total_loss()",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_152": {
                "name_or_scope": {
                    "value": "onsets",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_171": {
                "name_or_scope": {
                    "value": "offsets",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_191": {
                "name_or_scope": {
                    "value": "velocity",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_208": {
                "variable": {
                    "value": "velocity_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "onset_labels_flat * tf.square(velocity_labels_flat - velocity_values_flat)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "frame",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_loss_282": {
                "loss": {
                    "value": "tf.reduce_mean(frame_losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_399": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "scalar_405": {
                "name": {
                    "value": "loss_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'losses/' + label",
                            "BinOp"
                        ],
                        [
                            "'losses/' + label",
                            "BinOp"
                        ]
                    ]
                },
                "data": {
                    "value": "tf.reduce_mean(loss_collection)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_loss_169": {
                "loss": {
                    "value": "tf.reduce_mean(onset_losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_loss_189": {
                "loss": {
                    "value": "tf.reduce_mean(offset_losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_loss_212": {
                "loss": {
                    "value": "tf.reduce_mean(velocity_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_282": {
                "input_tensor": {
                    "value": "frame_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_utils.log_loss(frame_labels_flat, frame_probs_flat, weights=frame_loss_weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_loss_294": {
                "loss": {
                    "value": "tf.reduce_mean(activation_losses)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_405": {
                "input_tensor": {
                    "value": "loss_collection",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_410": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_169": {
                "input_tensor": {
                    "value": "onset_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_utils.log_loss(onset_labels_flat, onset_probs_flat)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_189": {
                "input_tensor": {
                    "value": "offset_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_utils.log_loss(offset_labels_flat, offset_probs_flat)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_212": {
                "input_tensor": {
                    "value": "velocity_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(onset_labels_flat * tf.square(velocity_labels_flat - velocity_values_flat), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_237": {
                "input": {
                    "value": "onset_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.fully_connected(onset_outputs, constants.MIDI_PITCHES, activation_fn=tf.sigmoid, scope='onset_probs')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_242": {
                "input": {
                    "value": "activation_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.fully_connected(activation_outputs, constants.MIDI_PITCHES, activation_fn=tf.sigmoid, scope='activation_probs')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(onset_outputs, constants.MIDI_PITCHES, activation_fn=tf.sigmoid, scope='activation_probs')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_247": {
                "input": {
                    "value": "offset_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.fully_connected(offset_outputs, constants.MIDI_PITCHES, activation_fn=tf.sigmoid, scope='offset_probs')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_294": {
                "input_tensor": {
                    "value": "activation_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_utils.log_loss(frame_labels_flat, flatten_maybe_padded_sequences(activation_probs, length), weights=activation_loss_weights)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_382": {
                "shape": {
                    "value": "tf.shape(onset_labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_388": {
                "shape": {
                    "value": "tf.shape(offset_labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_394": {
                "shape": {
                    "value": "tf.shape(frame_labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_210": {
                "x": {
                    "value": "velocity_labels_flat - velocity_values_flat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_382": {
                "input": {
                    "value": "onset_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels.onsets",
                            "Attribute"
                        ]
                    ]
                }
            },
            "shape_388": {
                "input": {
                    "value": "offset_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels.offsets",
                            "Attribute"
                        ]
                    ]
                }
            },
            "shape_394": {
                "input": {
                    "value": "frame_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels.labels",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/model_tpu.py": {
        "tensorflow": {
            "stack_175": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(outputs, axis=1)",
                            "Call"
                        ],
                        [
                            "prev_layer",
                            "variable"
                        ],
                        [
                            "combined_logits",
                            "variable"
                        ],
                        [
                            "lstm_layer_builder(tf.sigmoid(combined_logits), hparams.combined_lstm_units, hparams.bidirectional, is_training=is_training, lengths=length if hparams.use_lengths else None, stack_size=hparams.combined_rnn_stack_size, dropout_keep_prob=hparams.combined_rnn_dropout_keep_prob)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_59": {
                "variable": {
                    "value": "dims",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "slim.conv2d(net, num_filters, [conv_temporal_size, conv_freq_size], scope='conv' + str(i), normalizer_fn=slim.batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (dims[0], dims[1], net.shape[2] * net.shape[3]), 'flatten_end')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, hparams.fc_size, scope='fc_end')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, hparams.fc_dropout_keep_amt, scope='dropout_end')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [1, freq_pool_size], stride=[1, freq_pool_size], scope='pool' + str(i))",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, dropout_amt, scope='dropout' + str(i))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_60": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "slim.conv2d(net, num_filters, [conv_temporal_size, conv_freq_size], scope='conv' + str(i), normalizer_fn=slim.batch_norm)",
                            "Call"
                        ],
                        [
                            "tf.reshape(net, (dims[0], dims[1], net.shape[2] * net.shape[3]), 'flatten_end')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, hparams.fc_size, scope='fc_end')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, hparams.fc_dropout_keep_amt, scope='dropout_end')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [1, freq_pool_size], stride=[1, freq_pool_size], scope='pool' + str(i))",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, dropout_amt, scope='dropout' + str(i))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(dims[0], dims[1], net.shape[2] * net.shape[3])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "flatten_end",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BasicLSTMCell_81": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "num_units": {
                    "value": "num_units",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "DropoutWrapper_82": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.BasicLSTMCell(num_units)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=dropout_keep_prob if is_training else 1.0)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.BasicLSTMCell(num_units)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=dropout_keep_prob if is_training else 1.0)",
                            "Call"
                        ]
                    ]
                },
                "output_keep_prob": {
                    "value": "dropout_keep_prob if is_training else 1.0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "BasicLSTMCell_90": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "num_units": {
                    "value": "num_units",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "DropoutWrapper_91": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.BasicLSTMCell(num_units)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=dropout_keep_prob if is_training else 1.0)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.BasicLSTMCell(num_units)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=dropout_keep_prob if is_training else 1.0)",
                            "Call"
                        ]
                    ]
                },
                "output_keep_prob": {
                    "value": "dropout_keep_prob if is_training else 1.0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "dynamic_rnn_107": {
                "variable": {
                    "value": "(outputs, unused_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "tf.nn.rnn_cell.MultiRNNCell(cells_fw)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_134": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "static_rnn_168": {
                "variable": {
                    "value": "(outputs, unused_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "tf.nn.rnn_cell.MultiRNNCell(cells_fw)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "split_inputs",
                            "variable"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_288": {
                "variable": {
                    "value": "combined_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_94": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_106": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "split_135": {
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "inputs.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_154": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_167": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_209": {
                "name_or_scope": {
                    "value": "onsets",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_237": {
                "name_or_scope": {
                    "value": "velocity",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_250": {
                "name_or_scope": {
                    "value": "frame",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_155": {
                "name_or_scope": {
                    "value": "stack_bidirectional_rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_224": {
                "name_or_scope": {
                    "value": "offsets",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MultiRNNCell_108": {
                "cells": {
                    "value": "cells_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[cell_type(num_units, name='basic_lstm_cell') for _ in range(stack_size)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "static_bidirectional_rnn_158": {
                "variable": {
                    "value": "(prev_layer, _, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell_fw",
                    "type": "variable",
                    "possible_values": []
                },
                "cell_bw": {
                    "value": "cell_bw",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "prev_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "split_inputs",
                            "variable"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MultiRNNCell_169": {
                "cells": {
                    "value": "cells_fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[cell_type(num_units, name='basic_lstm_cell') for _ in range(stack_size)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "stop_gradient_273": {
                "input": {
                    "value": "onset_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.fully_connected(onset_outputs, constants.MIDI_PITCHES, activation_fn=None, scope='onset_logits')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_278": {
                "input": {
                    "value": "activation_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.fully_connected(activation_outputs, constants.MIDI_PITCHES, activation_fn=None, scope='activation_logits')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(onset_outputs, constants.MIDI_PITCHES, activation_fn=None, scope='activation_logits')",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_297": {
                "x": {
                    "value": "combined_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(logits, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_157": {
                "name_or_scope": {
                    "value": "'cell_%d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stop_gradient_284": {
                "input": {
                    "value": "offset_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "slim.fully_connected(offset_outputs, constants.MIDI_PITCHES, activation_fn=None, scope='offset_logits')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_create_dataset.py": {
        "tensorflow": {
            "disable_v2_behavior_37": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_38": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_create_dataset_maps.py": {
        "tensorflow": {
            "DEFINE_string_35": {
                "name": {
                    "value": "input_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory where the un-zipped MAPS files are.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "./",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory where the two output TFRecord files (train and test) will be placed.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "min_length",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "minimum segment length",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_41": {
                "name": {
                    "value": "max_length",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "20",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "maximum segment length",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_42": {
                "name": {
                    "value": "sample_rate",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "16000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "desired sample rate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_125": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_126": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TFRecordWriter_74": {
                "path": {
                    "value": "train_output_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.output_dir, 'maps_config2_train.tfrecord')",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordWriter_103": {
                "path": {
                    "value": "test_output_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.output_dir, 'maps_config2_test.tfrecord')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_create_tfrecords.py": {
        "tensorflow": {
            "disable_v2_behavior_46": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "makedirs_114": {
                "path": {
                    "value": "FLAGS.output_directory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_142": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "glob_80": {
                "variable": {
                    "value": "wav_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "pattern": {
                    "value": "wav_path_base + '*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "GFile_92": {
                "variable": {
                    "value": "wav_data",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "wav_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wav_paths",
                            "variable"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_116": {
                "name": {
                    "value": "FLAGS.csv",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_infer.py": {
        "tensorflow": {
            "disable_v2_behavior_34": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mark_flags_as_required_35": {
                "flag_names": {
                    "value": "['model_dir', 'examples_path']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "run_37": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_spectrogram_json.py": {
        "tensorflow": {
            "DEFINE_string_32": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "onsets_frames",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_34": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "onset_mode=length_ms,onset_length=32",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A comma-separated list of `name=value` hyperparameter values.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged: DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_52": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_69": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_58": {
                "msg": {
                    "value": "Generating spectrogram for %s...",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "argv[1:]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "info_64": {
                "msg": {
                    "value": "Wrote spectrogram json to %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "spec_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename + '.json'",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_train.py": {
        "tensorflow": {
            "DEFINE_string_33": {
                "name": {
                    "value": "master",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the TensorFlow runtime to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "tpu_cluster",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the TPU Cluster to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "onsets_frames",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_39": {
                "name": {
                    "value": "examples_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to a TFRecord file of train/eval examples.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_46": {
                "name": {
                    "value": "model_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "~/tmp/onsets_frames",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path where checkpoints and summary events will be located during training and evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_50": {
                "name": {
                    "value": "warm_start_from",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Optional string filepath to a checkpoint,  then all variables are warm-started during training",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_54": {
                "name": {
                    "value": "eval_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Name for this eval run.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_55": {
                "name": {
                    "value": "num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1000000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of training steps or `None` for infinite.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_57": {
                "name": {
                    "value": "eval_num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Number of eval steps or `None` to go through all examples.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_60": {
                "name": {
                    "value": "keep_checkpoint_max",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "Maximum number of checkpoints to keep in `train` mode or 0 for infinite.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_63": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A comma-separated list of `name=value` hyperparameter values.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_enum_68": {
                "name": {
                    "value": "mode",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "train",
                    "type": "str",
                    "possible_values": []
                },
                "enum_values": {
                    "value": "['train', 'eval']",
                    "type": "List",
                    "possible_values": []
                },
                "help": {
                    "value": "Which mode to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_70": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged: DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_78": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mark_flags_as_required_120": {
                "flag_names": {
                    "value": "['examples_path']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_128": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_129": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/onsets_frames_transcription_transcribe.py": {
        "tensorflow": {
            "DEFINE_string_35": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "onsets_frames",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Name of the config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "model_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to look for acoustic checkpoints.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_39": {
                "name": {
                    "value": "checkpoint_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Filename of the checkpoint to use. If not specified, will use the latest checkpoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_43": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A comma-separated list of `name=value` hyperparameter values.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_50": {
                "name": {
                    "value": "transcribed_file_suffix",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Optional suffix to add to transcribed files.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_53": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged: DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_verbosity_79": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_88": {
                "variable": {
                    "value": "examples",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "make_initializable_iterator_102": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_fn(examples=examples, preprocess_examples=True, params=hparams, is_training=False, shuffle_examples=False, skip_n_initial_records=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_154": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_155": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_87": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_112": {
                "msg": {
                    "value": "Starting transcription for %s...",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "argv[1:]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "info_118": {
                "msg": {
                    "value": "Processing file...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_129": {
                "msg": {
                    "value": "Running inference...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_146": {
                "msg": {
                    "value": "Transcription written to %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename + FLAGS.transcribed_file_suffix + '.midi'",
                            "BinOp"
                        ]
                    ]
                }
            },
            "global_variables_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_108": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/onsets_frames_transcription/train_util.py": {
        "tensorflow": {
            "RunConfig_87": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf_estimator.tpu.TPUConfig(iterations_per_loop=save_checkpoint_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "master": {
                    "value": "master",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "''",
                            "Method Argument"
                        ]
                    ]
                },
                "cluster": {
                    "value": "tpu_cluster_resolver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(tpu_cluster)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "save_summary_steps": {
                    "value": "save_summary_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "300",
                            "Method Argument"
                        ]
                    ]
                },
                "save_checkpoints_steps": {
                    "value": "save_checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "300",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_checkpoint_max": {
                    "value": "keep_checkpoint_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "info_35": {
                "msg": {
                    "value": "Writing hparams summary: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "FileWriter_50": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_81": {
                "variable": {
                    "value": "tpu_cluster_resolver",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "tpu_cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "TPUEstimator_99": {
                "use_tpu": {
                    "value": "use_tpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "model_fn": {
                    "value": "wrapped_model_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "copy.deepcopy(hparams)",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "hparams.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "hparams.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "predict_batch_size": {
                    "value": "hparams.predict_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_estimator.tpu.RunConfig(tpu_config=tf_estimator.tpu.TPUConfig(iterations_per_loop=save_checkpoint_steps), master=master, cluster=tpu_cluster_resolver, save_summary_steps=save_summary_steps, save_checkpoints_steps=save_checkpoint_steps, keep_checkpoint_max=keep_checkpoint_max, keep_checkpoint_every_n_hours=1)",
                            "Call"
                        ]
                    ]
                },
                "warm_start_from": {
                    "value": "warm_start_from",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "eval_on_tpu": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_49": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_197": {
                "msg": {
                    "value": "Checking for at least %d records...",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "records_to_check",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_steps * 5",
                            "BinOp"
                        ]
                    ]
                }
            },
            "make_initializable_iterator_206": {
                "variable": {
                    "value": "iterator",
                    "type": "variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "transcription_data_base(params=record_check_params, shuffle_examples=False, skip_n_initial_records=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_222": {
                "msg": {
                    "value": "Found at least %d records. Will skip a maximum of %d records during eval runs in order to support %d evaluation steps.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "records_available",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "records_available + 1",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "max_records_to_skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max(0, records_available - num_steps)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_52": {
                "msg": {
                    "value": "Writing summary for %s: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TPUConfig_88": {
                "iterations_per_loop": {
                    "value": "save_checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "300",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Graph_199": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_233": {
                "msg": {
                    "value": "Skipping %d initial record(s)",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "skip_n_initial_records",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random.randint(0, max_records_to_skip)",
                            "Call"
                        ]
                    ]
                }
            },
            "text_54": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.constant(summary, name=name)",
                    "type": "Call",
                    "possible_values": []
                },
                "collections": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_208": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_54": {
                "value": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_216": {
                "msg": {
                    "value": "Found %d records...",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "records_available",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "records_available + 1",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/performance_rnn/performance_rnn_create_dataset.py": {
        "tensorflow": {
            "set_verbosity_51": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_68": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_69": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/performance_rnn/performance_rnn_create_dataset_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_64": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/performance_rnn/performance_rnn_generate.py": {
        "tensorflow": {
            "DEFINE_string_33": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where the latest checkpoint will be loaded from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_36": {
                "name": {
                    "value": "bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the bundle file. If specified, this will take priority over run_dir, unless save_generator_bundle is True, in which case both this flag and run_dir are required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_45": {
                "name": {
                    "value": "bundle_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A short, human-readable text description of the bundle (e.g., training data, hyper parameters, etc.).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_49": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "performance",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/performance_rnn/generated",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory where MIDI files will be saved to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_54": {
                "name": {
                    "value": "num_outputs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of tracks to generate. One MIDI file will be created for each.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_58": {
                "name": {
                    "value": "num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "3000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The total number of steps the generated track should be, priming track length + generated steps. Each step is 10 milliseconds.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_62": {
                "name": {
                    "value": "primer_pitches",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of pitches that will be used as a starting chord with a quarter note duration. For example: \"[60, 64, 67]\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_67": {
                "name": {
                    "value": "primer_melody",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of note_seq.Melody event values. For example: \"[60, -2, 60, -2, 67, -2, 67, -2]\". The primer melody will be played at a fixed tempo of 120 QPM with 4 steps per quarter note.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_72": {
                "name": {
                    "value": "primer_midi",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to a MIDI file containing a polyphonic track that will be used as a priming track.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_76": {
                "name": {
                    "value": "disable_conditioning",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "When optional conditioning is available, a string representation of a Boolean indicating whether or not to disable conditioning. Similar to control signals, this can also be a list of Booleans; when it is a list, the other conditioning variables will be ignored for segments where conditioning is disabled.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_83": {
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "The randomness of the generated tracks. 1.0 uses the unaltered softmax probabilities, greater than 1.0 makes tracks more random, less than 1.0 makes tracks less random.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_88": {
                "name": {
                    "value": "beam_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The beam size to use for beam search when generating tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_91": {
                "name": {
                    "value": "branch_factor",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The branch factor to use for beam search when generating tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_94": {
                "name": {
                    "value": "steps_per_iteration",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of steps to take per beam search iteration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_97": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_101": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_109": {
                "name": {
                    "value": "control_signal_cls.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "control_signal_cls.description",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_235": {
                "msg": {
                    "value": "primer_sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "primer_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ],
                        [
                            "primer_melody.to_sequence()",
                            "Call"
                        ],
                        [
                            "note_seq.midi_file_to_sequence_proto(primer_midi)",
                            "Call"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_236": {
                "msg": {
                    "value": "generator_options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_249": {
                "msg": {
                    "value": "Wrote %d MIDI files to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.num_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_255": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_288": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_289": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_149": {
                "msg": {
                    "value": "--output_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_157": {
                "filename": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_158": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_196": {
                "msg": {
                    "value": "Priming sequence is longer than the total number of steps requested: Priming sequence length: %s, Total length requested: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generate_section.start_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "generate_end_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.num_steps * seconds_per_step",
                            "BinOp"
                        ]
                    ]
                }
            },
            "warning_215": {
                "msg": {
                    "value": "Disable conditioning flag set, but generator is not set up for optional conditioning. Requested disable conditioning flag will be ignored: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.disable_conditioning",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_281": {
                "msg": {
                    "value": "Saving generator bundle to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "bundle_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.bundle_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_208": {
                "msg": {
                    "value": "Control signal requested via flag, but generator is not set up to condition on this control signal. Request will be ignored: %s = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "control_cls.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "FLAGS[control_cls.name].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warning_280": {
                "msg": {
                    "value": "No bundle description provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_177": {
                "msg": {
                    "value": "No priming sequence specified. Defaulting to empty sequence.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/performance_rnn/performance_rnn_train.py": {
        "tensorflow": {
            "DEFINE_string_26": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/performance_rnn/logdir/run1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where checkpoints and summary events will be saved during training and evaluation. Separate subdirectories for training events and eval events will be created within `run_dir`. Multiple runs can be stored within the parent directory of `run_dir`. Point TensorBoard to the parent directory of `run_dir` to see all your runs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "performance",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The config to use",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_36": {
                "name": {
                    "value": "sequence_example_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to TFRecord file containing tf.SequenceExample records for training or evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_40": {
                "name": {
                    "value": "warm_start_bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to a bundle file that will be used to initialize the model weights for fine-tuning.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_43": {
                "name": {
                    "value": "num_training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The the number of global training steps your model should take before exiting training. Leave as 0 to run until terminated manually.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_47": {
                "name": {
                    "value": "num_eval_examples",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of evaluation examples your model should process for each evaluation step.Leave as 0 to use the entire evaluation set.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_51": {
                "name": {
                    "value": "summary_frequency",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "A summary statement will be logged every `summary_frequency` steps during training or every `summary_frequency` seconds during evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_56": {
                "name": {
                    "value": "num_checkpoints",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of most recent checkpoints to keep in the training directory. Keeps all if 0.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_62": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_65": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_82": {
                "variable": {
                    "value": "sequence_example_file_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "os.path.expanduser(FLAGS.sequence_example_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_73": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_94": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_95": {
                "msg": {
                    "value": "Train dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_116": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_117": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_76": {
                "msg": {
                    "value": "--run_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_79": {
                "msg": {
                    "value": "--sequence_example_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_99": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_100": {
                "msg": {
                    "value": "Eval dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/performance_rnn/performance_sequence_generator.py": {
        "tensorflow": {
            "info_238": {
                "msg": {
                    "value": "'Need to generate %d more steps for this sequence, will try asking for %d RNN steps' % (steps_to_gen, rnn_steps_to_gen)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "warning_172": {
                "msg": {
                    "value": "Control value not specified, using default: %s = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "control.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "control.default_value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fatal_195": {
                "msg": {
                    "value": "Invalid disable_conditioning value: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "args['disable_conditioning']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "fatal_181": {
                "msg": {
                    "value": "Invalid control value: %s = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "control.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "args[control.name]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/piano_genie/eval.py": {
        "tensorflow": {
            "get_collection_69": {
                "variable": {
                    "value": "genie_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "phero_model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "exp_143": {
                "variable": {
                    "value": "summary_name_to_batch_tensor[ppl_recons]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "model_dict['dec_recons_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "merge_168": {
                "variable": {
                    "value": "summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "summaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.summary.merge(summaries)",
                            "Call"
                        ],
                        [
                            "collections.defaultdict(list)",
                            "Call"
                        ]
                    ]
                }
            },
            "FileWriter_169": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "FLAGS.eval_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_172": {
                "variable": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_173": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "genie_vars + [step]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "sequence_mask_95": {
                "variable": {
                    "value": "gold_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "gold_seq_varlens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, [1])",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "gold_seq_maxlen",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gold.gold_longest()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_99": {
                "variable": {
                    "value": "gold_diff_l2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gold_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(gold_buttons, tf.float32) - tf.cast(gold_encodings, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "abs_100": {
                "variable": {
                    "value": "gold_diff_l1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gold_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(gold_buttons, tf.float32) - tf.cast(gold_encodings, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "placeholder_107": {
                "variable": {
                    "value": "gold_diff_l2_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_108": {
                "variable": {
                    "value": "gold_diff_l1_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_148": {
                "variable": {
                    "value": "summary_name_to_batch_tensor[ppl_recons_velocity]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "model_dict['dec_recons_velocity_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "placeholder_155": {
                "variable": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_249": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "IsDirectory_43": {
                "dirname": {
                    "value": "FLAGS.eval_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_44": {
                "dirname": {
                    "value": "FLAGS.eval_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_49": {
                "name": {
                    "value": "loader",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_62": {
                "name_or_scope": {
                    "value": "phero_model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_83": {
                "variable": {
                    "value": "gold_seq_varlens",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_84": {
                "variable": {
                    "value": "gold_buttons",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "latest_checkpoint_208": {
                "variable": {
                    "value": "latest_ckpt_fp",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.train_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_76": {
                "name_or_scope": {
                    "value": "phero_model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_97": {
                "x": {
                    "value": "gold_encodings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gold_model_dict['stp_emb_vq_discrete' if cfg.stp_emb_vq else 'stp_emb_iq_discrete']",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_157": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "summary_name_to_batch_tensor",
                            "variable"
                        ]
                    ]
                },
                "data": {
                    "value": "tf.reduce_mean(placeholder)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_161": {
                "name": {
                    "value": "gold_diff_l2",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(gold_diff_l2_placeholder)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_165": {
                "name": {
                    "value": "gold_diff_l1",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.reduce_mean(gold_diff_l1_placeholder)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_234": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_78": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_79": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_80": {
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_102": {
                "input_tensor": {
                    "value": "m",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_157": {
                "input_tensor": {
                    "value": "placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_162": {
                "input_tensor": {
                    "value": "gold_diff_l2_placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_166": {
                "input_tensor": {
                    "value": "gold_diff_l1_placeholder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None])",
                            "Call"
                        ]
                    ]
                }
            },
            "local_variables_initializer_235": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_213": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "local_variables_initializer_214": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/piano_genie/loader.py": {
        "tensorflow": {
            "Glob_126": {
                "variable": {
                    "value": "filenames",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TFRecordDataset_129": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filenames",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gfile.Glob(fp)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_166": {
                "variable": {
                    "value": "note_pitches",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "note_sequence_tensors[:, :, 0] + 0.0001",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_167": {
                "variable": {
                    "value": "note_velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "note_sequence_tensors[:, :, 1] + 0.0001",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_173": {
                "variable": {
                    "value": "note_delta_times_int",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.round(note_delta_times * 31.25) + 0.0001",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_118": {
                "variable": {
                    "value": "start_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "note_sequence_len - seq_len",
                            "BinOp"
                        ],
                        [
                            "tf.maximum(start_max, 0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "minimum_178": {
                "variable": {
                    "value": "note_delta_times_int",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "note_delta_times_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.round(note_delta_times * 31.25) + 0.0001, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.minimum(note_delta_times_int, max_discrete_times)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_discrete_times",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "minimum_182": {
                "variable": {
                    "value": "note_velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "note_velocities / (128 // max_discrete_velocities)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "max_discrete_velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "greater_equal_112": {
                "x": {
                    "value": "note_sequence_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(note_sequence_tensor)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(note_sequence_tensor)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_111": {
                "input": {
                    "value": "note_sequence_tensor",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_116": {
                "input": {
                    "value": "note_sequence_tensor",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "py_func_134": {
                "func": {
                    "value": "lambda x: _str_to_tensor(x, augment_stretch_bounds, augment_transpose_bounds)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "inp": {
                    "value": "[data]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "(tf.string, tf.float32)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "stateful": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "round_174": {
                "x": {
                    "value": "note_delta_times * 31.25",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/piano_genie/model.py": {
        "tensorflow": {
            "concat_427": {
                "variable": {
                    "value": "dec_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "dec_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "latents",
                            "variable"
                        ],
                        [
                            "tf.concat(dec_feats, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_35": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ],
                        [
                            "tf.concat([x_fw, x_bw], axis=2)",
                            "Call"
                        ],
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "rnn_nunits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "128",
                            "Method Argument"
                        ],
                        [
                            "128",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dense_77": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ],
                        [
                            "tf.concat([x_fw, x_bw], axis=2)",
                            "Call"
                        ],
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "rnn_nunits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "128",
                            "Method Argument"
                        ],
                        [
                            "128",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dynamic_rnn_89": {
                "variable": {
                    "value": "(x, final_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ],
                        [
                            "tf.concat([x_fw, x_bw], axis=2)",
                            "Call"
                        ],
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([batch_size], minval=cfg.train_seq_len_min, maxval=seq_len + 1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "seq_varlens",
                            "variable"
                        ],
                        [
                            "tf.ones([batch_size], dtype=tf.int32) * seq_len",
                            "BinOp"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell.zero_state(batch_size, dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_144": {
                "variable": {
                    "value": "stp_varlen_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([batch_size], minval=cfg.train_seq_len_min, maxval=seq_len + 1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "seq_varlens",
                            "variable"
                        ],
                        [
                            "tf.ones([batch_size], dtype=tf.int32) * seq_len",
                            "BinOp"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_171": {
                "variable": {
                    "value": "enc_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "enc_feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(enc_feats, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "embedding_lookup_225": {
                "variable": {
                    "value": "out_dict[stp_emb_vq_quantized_lookup]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "stp_emb_vq_codebook",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(vq_vae.embeddings)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "stp_emb_vq_discrete",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.argmax(vq_vae_output['encodings'], axis=1, output_type=tf.int32), [batch_size, seq_len])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_334": {
                "variable": {
                    "value": "out_dict[stp_emb_iq_quantized_lookup]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "2.0 * (stp_emb_iq_discrete_f / (cfg.stp_emb_iq_nbins - 1.0)) - 1.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_345": {
                "variable": {
                    "value": "seq_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[seq_emb_unconstrained] * seq_len",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_367": {
                "variable": {
                    "value": "seq_emb_vae",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[seq_emb_vae] * seq_len",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_403": {
                "variable": {
                    "value": "last_pitches",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "last_pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "curr_pitches[:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(last_pitches, [[0, 0], [1, 0]], constant_values=-1)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [1, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_449": {
                "variable": {
                    "value": "out_dict[dec_recons_scores]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "logits": {
                    "value": "dec_recons_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(dec_stp, 88)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_450": {
                "variable": {
                    "value": "out_dict[dec_recons_preds]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "dec_recons_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(dec_stp, 88)",
                            "Call"
                        ]
                    ]
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_475": {
                "variable": {
                    "value": "contour_violation",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.less(dx * dy, 0), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_477": {
                "variable": {
                    "value": "dx_hold",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pitches[:, 1:] - pitches[:, :-1]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_34": {
                "name_or_scope": {
                    "value": "rnn_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_45": {
                "name_or_scope": {
                    "value": "rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_47": {
                "variable": {
                    "value": "((x_fw, x_bw), (state_fw, state_bw))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ],
                        [
                            "tf.concat([x_fw, x_bw], axis=2)",
                            "Call"
                        ],
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([batch_size], minval=cfg.train_seq_len_min, maxval=seq_len + 1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "seq_varlens",
                            "variable"
                        ],
                        [
                            "tf.ones([batch_size], dtype=tf.int32) * seq_len",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_53": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x_fw, x_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_56": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[state_fw, state_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dynamic_rnn_59": {
                "variable": {
                    "value": "(x, state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell([celltype(rnn_nunits) for _ in range(rnn_nlayers)])",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ],
                        [
                            "tf.concat([x_fw, x_bw], axis=2)",
                            "Call"
                        ],
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([batch_size], minval=cfg.train_seq_len_min, maxval=seq_len + 1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "seq_varlens",
                            "variable"
                        ],
                        [
                            "tf.ones([batch_size], dtype=tf.int32) * seq_len",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_76": {
                "name_or_scope": {
                    "value": "rnn_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_87": {
                "name_or_scope": {
                    "value": "rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_100": {
                "input_tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_103": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(mask, axis=-1)",
                            "Call"
                        ],
                        [
                            "stp_emb_iq_note_held",
                            "variable"
                        ],
                        [
                            "stp_varlen_mask[:, 1:] * stp_emb_iq_note_held",
                            "BinOp"
                        ],
                        [
                            "stp_emb_iq_inrange_mask",
                            "variable"
                        ],
                        [
                            "stp_varlen_mask * stp_emb_iq_inrange_mask",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sequence_mask_148": {
                "variable": {
                    "value": "stp_varlen_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "seq_varlens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_188": {
                "variable": {
                    "value": "stp_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "enc_stp",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cfg.stp_emb_unconstrained_embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_340": {
                "variable": {
                    "value": "seq_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "enc_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cfg.seq_emb_unconstrained_embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_351": {
                "variable": {
                    "value": "seq_emb_vae",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "enc_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cfg.seq_emb_vae_embedding_dim * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_359": {
                "variable": {
                    "value": "kl",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "0.5 * tf.reduce_sum(tf.square(mean) + tf.square(stddev) - tf.log(1e-08 + tf.square(stddev)) - 1, axis=1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_377": {
                "variable": {
                    "value": "enc_lor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "enc_stp",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, seq_len // cfg.lor_emb_n, cfg.lor_emb_n * rnn_embedding_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_381": {
                "variable": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "enc_lor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(enc_stp, [batch_size, seq_len // cfg.lor_emb_n, cfg.lor_emb_n * rnn_embedding_dim])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "cfg.lor_emb_unconstrained_embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_387": {
                "variable": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(enc_lor, cfg.lor_emb_unconstrained_embedding_dim)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lor_emb_unconstrained, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.tile(lor_emb_unconstrained, [1, 1, cfg.lor_emb_n, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(lor_emb_unconstrained, [batch_size, seq_len, cfg.lor_emb_unconstrained_embedding_dim])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_388": {
                "variable": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(enc_lor, cfg.lor_emb_unconstrained_embedding_dim)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lor_emb_unconstrained, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.tile(lor_emb_unconstrained, [1, 1, cfg.lor_emb_n, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(lor_emb_unconstrained, [batch_size, seq_len, cfg.lor_emb_unconstrained_embedding_dim])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, cfg.lor_emb_n, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_390": {
                "variable": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "lor_emb_unconstrained",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(enc_lor, cfg.lor_emb_unconstrained_embedding_dim)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(lor_emb_unconstrained, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.tile(lor_emb_unconstrained, [1, 1, cfg.lor_emb_n, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(lor_emb_unconstrained, [batch_size, seq_len, cfg.lor_emb_unconstrained_embedding_dim])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, seq_len, cfg.lor_emb_unconstrained_embedding_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_412": {
                "variable": {
                    "value": "last_velocities",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "last_velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "curr_velocities[:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(last_velocities, [[0, 0], [1, 0]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [1, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_430": {
                "name_or_scope": {
                    "value": "decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_440": {
                "variable": {
                    "value": "dec_recons_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "dec_stp",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "88",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_104": {
                "input_tensor": {
                    "value": "tf.multiply(t, mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_105": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(mask, axis=-1)",
                            "Call"
                        ],
                        [
                            "stp_emb_iq_note_held",
                            "variable"
                        ],
                        [
                            "stp_varlen_mask[:, 1:] * stp_emb_iq_note_held",
                            "BinOp"
                        ],
                        [
                            "stp_emb_iq_inrange_mask",
                            "variable"
                        ],
                        [
                            "stp_varlen_mask * stp_emb_iq_inrange_mask",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_173": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_187": {
                "name_or_scope": {
                    "value": "stp_emb_unconstrained",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_197": {
                "name_or_scope": {
                    "value": "stp_emb_vq",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_200": {
                "variable": {
                    "value": "pre_vq_encoding",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "enc_stp",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cfg.stp_emb_vq_embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "stp_emb_vq_discrete",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.argmax(vq_vae_output['encodings'], axis=1, output_type=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, seq_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_214": {
                "variable": {
                    "value": "stp_emb_vq_codebook",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "vq_vae.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_230": {
                "name_or_scope": {
                    "value": "stp_emb_iq",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_239": {
                "variable": {
                    "value": "xp",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "(x + 1) / 2.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-eps",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1 + eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "round_240": {
                "variable": {
                    "value": "xpp",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "s * xp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_248": {
                "variable": {
                    "value": "stp_emb_iq_discrete",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stp_emb_iq_discrete_f + 0.0001",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_249": {
                "variable": {
                    "value": "stp_emb_iq_discrete_f",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stp_emb_iq_discrete",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(stp_emb_iq_discrete_f + 0.0001, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_250": {
                "variable": {
                    "value": "stp_emb_iq_quantized",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stp_emb_iq_discrete_rescaled",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_254": {
                "variable": {
                    "value": "stp_emb_iq_inrange",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(pre_iq_encoding, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less_equal(pre_iq_encoding, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_257": {
                "variable": {
                    "value": "stp_emb_iq_inrange_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stp_emb_iq_inrange",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.greater_equal(pre_iq_encoding, -1), tf.less_equal(pre_iq_encoding, 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_294": {
                "variable": {
                    "value": "stp_emb_iq_note_held",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(pitches[:, 1:] - pitches[:, :-1], 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_313": {
                "variable": {
                    "value": "stp_emb_iq_discrete_oh",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "stp_emb_iq_discrete",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(stp_emb_iq_discrete_f + 0.0001, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "cfg.stp_emb_iq_nbins",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_320": {
                "variable": {
                    "value": "stp_emb_iq_discrete_ppl",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-tf.reduce_sum(stp_emb_iq_avg_probs * tf.log(stp_emb_iq_avg_probs + 1e-10))",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_339": {
                "name_or_scope": {
                    "value": "seq_emb_unconstrained",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_350": {
                "name_or_scope": {
                    "value": "seq_emb_vae",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_374": {
                "name_or_scope": {
                    "value": "lor_emb_unconstrained",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_407": {
                "indices": {
                    "value": "last_pitches + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "89",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_418": {
                "indices": {
                    "value": "feat_dict['delta_times_int']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "cfg.data_max_discrete_times + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_423": {
                "indices": {
                    "value": "feat_dict['velocities']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "cfg.data_max_discrete_velocities + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_439": {
                "name_or_scope": {
                    "value": "pitches",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_443": {
                "logits": {
                    "value": "dec_recons_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(dec_stp, 88)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.demidify(feat_dict['midi_pitches'])",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_458": {
                "variable": {
                    "value": "dec_recons_velocity_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "dec_stp",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "cfg.data_max_discrete_velocities + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_475": {
                "x": {
                    "value": "tf.less(dx * dy, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_479": {
                "x": {
                    "value": "dx_hold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(dx, 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_105": {
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(mask, axis=-1)",
                            "Call"
                        ],
                        [
                            "stp_emb_iq_note_held",
                            "variable"
                        ],
                        [
                            "stp_varlen_mask[:, 1:] * stp_emb_iq_note_held",
                            "BinOp"
                        ],
                        [
                            "stp_emb_iq_inrange_mask",
                            "variable"
                        ],
                        [
                            "stp_varlen_mask * stp_emb_iq_inrange_mask",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_135": {
                "x": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.demidify(feat_dict['midi_pitches'])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_151": {
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_161": {
                "input": {
                    "value": "pitches_scalar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(pitches, tf.float32) / 87.0 * 2.0 - 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_163": {
                "indices": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.demidify(feat_dict['midi_pitches'])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "88",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_166": {
                "indices": {
                    "value": "feat_dict['delta_times_int']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "depth": {
                    "value": "cfg.data_max_discrete_times + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_170": {
                "indices": {
                    "value": "velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "feat_dict['velocities']",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "cfg.data_max_discrete_velocities + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_198": {
                "name_or_scope": {
                    "value": "pre_vq",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_202": {
                "name_or_scope": {
                    "value": "quantizer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_231": {
                "name_or_scope": {
                    "value": "pre_iq",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_244": {
                "name_or_scope": {
                    "value": "quantizer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_271": {
                "variable": {
                    "value": "stp_emb_iq_dnotes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "pitches[:, 1:] - pitches[:, :-1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softplus_354": {
                "features": {
                    "value": "seq_emb_vae[:, cfg.seq_emb_vae_embedding_dim:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "one_hot_414": {
                "indices": {
                    "value": "last_velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "curr_velocities[:, :-1]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(last_velocities, [[0, 0], [1, 0]])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "cfg.data_max_discrete_velocities + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_457": {
                "name_or_scope": {
                    "value": "velocities",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_462": {
                "logits": {
                    "value": "dec_recons_velocity_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(dec_stp, cfg.data_max_discrete_velocities + 1)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "velocities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "feat_dict['velocities']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "less_475": {
                "x": {
                    "value": "dx * dy",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "not_equal_479": {
                "x": {
                    "value": "dy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "discrete[:, 1:] - discrete[:, :-1]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_212": {
                "input": {
                    "value": "vq_vae_output['encodings']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "output_type": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dense_233": {
                "inputs": {
                    "value": "enc_stp",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_equal_255": {
                "x": {
                    "value": "pre_iq_encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(enc_stp, 1)[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "less_equal_256": {
                "x": {
                    "value": "pre_iq_encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(enc_stp, 1)[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_263": {
                "x": {
                    "value": "tf.maximum(tf.abs(pre_iq_encoding) - 1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_295": {
                "x": {
                    "value": "pitches[:, 1:] - pitches[:, :-1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_359": {
                "input_tensor": {
                    "value": "tf.square(mean) + tf.square(stddev) - tf.log(1e-08 + tf.square(stddev)) - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_242": {
                "input": {
                    "value": "xppp - x",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_263": {
                "x": {
                    "value": "tf.abs(pre_iq_encoding) - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_288": {
                "x": {
                    "value": "cfg.stp_emb_iq_contour_margin - comp_func(stp_emb_iq_dnotes, stp_emb_iq_dlatents)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_320": {
                "input_tensor": {
                    "value": "stp_emb_iq_avg_probs * tf.log(stp_emb_iq_avg_probs + 1e-10)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_357": {
                "input": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "seq_emb_vae[:, :cfg.seq_emb_vae_embedding_dim]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "divide_282": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ],
                        [
                            "tf.concat([x_fw, x_bw], axis=2)",
                            "Call"
                        ],
                        [
                            "features",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(x, rnn_nunits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y + 1e-06",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_263": {
                "x": {
                    "value": "pre_iq_encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(enc_stp, 1)[:, :, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "log_321": {
                "x": {
                    "value": "stp_emb_iq_avg_probs + 1e-10",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_360": {
                "x": {
                    "value": "1e-08 + tf.square(stddev)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_360": {
                "x": {
                    "value": "stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-06 + tf.nn.softplus(seq_emb_vae[:, cfg.seq_emb_vae_embedding_dim:])",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/piano_genie/train.py": {
        "tensorflow": {
            "AdamOptimizer_150": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "cfg.train_lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "image_61": {
                "name": {
                    "value": "piano_roll",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "util.discrete_to_piano_roll(util.demidify(feat_dict['midi_pitches']), 88)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_112": {
                "name": {
                    "value": "decoder_scores",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "util.discrete_to_piano_roll(model_dict['dec_recons_scores'], 88)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_115": {
                "name": {
                    "value": "decoder_preds",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "util.discrete_to_piano_roll(model_dict['dec_recons_preds'], 88)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_125": {
                "name": {
                    "value": "loss_recons",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['dec_recons_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_126": {
                "name": {
                    "value": "ppl_recons",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.exp(model_dict['dec_recons_loss'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_147": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_dict['dec_recons_loss']",
                            "Subscript"
                        ],
                        [
                            "loss + model_dict['dec_recons_velocity_loss']",
                            "BinOp"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_164": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_165": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "IsDirectory_39": {
                "dirname": {
                    "value": "FLAGS.train_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_40": {
                "dirname": {
                    "value": "FLAGS.train_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_48": {
                "name": {
                    "value": "loader",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_66": {
                "name_or_scope": {
                    "value": "phero_model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_76": {
                "name": {
                    "value": "codebook_perplexity",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_vq_codebook_ppl']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "image_78": {
                "name": {
                    "value": "genie",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "util.discrete_to_piano_roll(model_dict['stp_emb_vq_discrete'], cfg.stp_emb_vq_codebook_size, dilation=max(1, 88 // cfg.stp_emb_vq_codebook_size))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_84": {
                "name": {
                    "value": "loss_vqvae",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_vq_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_88": {
                "name": {
                    "value": "discrete_perplexity",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_iq_discrete_ppl']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_90": {
                "name": {
                    "value": "iq_valid_p",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_iq_valid_p']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "image_91": {
                "name": {
                    "value": "genie",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "util.discrete_to_piano_roll(model_dict['stp_emb_iq_discrete'], cfg.stp_emb_iq_nbins, dilation=max(1, 88 // cfg.stp_emb_iq_nbins))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_97": {
                "name": {
                    "value": "loss_iq_range",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_iq_range_penalty']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_98": {
                "name": {
                    "value": "loss_iq_contour",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_iq_contour_penalty']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_100": {
                "name": {
                    "value": "loss_iq_deviate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['stp_emb_iq_deviate_penalty']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_104": {
                "name": {
                    "value": "contour_violation",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['contour_violation']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_105": {
                "name": {
                    "value": "deviate_violation",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['deviate_violation']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_109": {
                "name": {
                    "value": "loss_kl",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['seq_emb_vae_kl']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_119": {
                "name": {
                    "value": "loss_recons_velocity",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "model_dict['dec_recons_velocity_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_121": {
                "name": {
                    "value": "ppl_recons_velocity",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tf.exp(model_dict['dec_recons_velocity_loss'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_126": {
                "x": {
                    "value": "model_dict['dec_recons_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "MonitoredTrainingSession_155": {
                "checkpoint_dir": {
                    "value": "FLAGS.train_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_checkpoint_secs": {
                    "value": "600",
                    "type": "int",
                    "possible_values": []
                },
                "save_summaries_secs": {
                    "value": "FLAGS.summary_every_nsecs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_122": {
                "x": {
                    "value": "model_dict['dec_recons_velocity_loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_152": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/piano_genie/util.py": {
        "tensorflow": {
            "stack_55": {
                "variable": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[piano_roll] * 3",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rot90_73": {
                "variable": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(categorical, dim)",
                            "Call"
                        ],
                        [
                            "tf.stack([piano_roll] * 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.multiply(piano_roll, colors_rgb)",
                            "Call"
                        ],
                        [
                            "piano_roll * 255.0",
                            "BinOp"
                        ],
                        [
                            "categorical",
                            "variable"
                        ],
                        [
                            "tf.image.rot90(piano_roll)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(piano_roll, [old_height * dilation, old_width])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.clip_by_value(piano_roll, 0.0, 255.0), tf.uint8)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_84": {
                "variable": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.clip_by_value(piano_roll, 0.0, 255.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_49": {
                "variable": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "categorical",
                    "type": "variable",
                    "possible_values": []
                },
                "depth": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_66": {
                "variable": {
                    "value": "colors_rgb",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "colors_rgb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.hsv_to_rgb(colors_hsv) * 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(colors_rgb, [1, 1, dim, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, dim, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_68": {
                "variable": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(categorical, dim)",
                            "Call"
                        ],
                        [
                            "tf.stack([piano_roll] * 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.multiply(piano_roll, colors_rgb)",
                            "Call"
                        ],
                        [
                            "piano_roll * 255.0",
                            "BinOp"
                        ],
                        [
                            "categorical",
                            "variable"
                        ],
                        [
                            "tf.image.rot90(piano_roll)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(piano_roll, [old_height * dilation, old_width])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.clip_by_value(piano_roll, 0.0, 255.0), tf.uint8)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "colors_rgb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.hsv_to_rgb(colors_hsv) * 255.0",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(colors_rgb, [1, 1, dim, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "resize_nearest_neighbor_80": {
                "variable": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(categorical, dim)",
                            "Call"
                        ],
                        [
                            "tf.stack([piano_roll] * 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.multiply(piano_roll, colors_rgb)",
                            "Call"
                        ],
                        [
                            "piano_roll * 255.0",
                            "BinOp"
                        ],
                        [
                            "categorical",
                            "variable"
                        ],
                        [
                            "tf.image.rot90(piano_roll)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(piano_roll, [old_height * dilation, old_width])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.clip_by_value(piano_roll, 0.0, 255.0), tf.uint8)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[old_height * dilation, old_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "assert_greater_equal_28": {
                "x": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "21",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assert_less_equal_29": {
                "x": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "108",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_31": {
                "control_inputs": {
                    "value": "assertions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.assert_greater_equal(pitches, 21), tf.assert_less_equal(pitches, 108)]",
                            "List"
                        ],
                        [
                            "[tf.assert_greater_equal(pitches, 0), tf.assert_less_equal(pitches, 87)]",
                            "List"
                        ]
                    ]
                }
            },
            "assert_greater_equal_38": {
                "x": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assert_less_equal_39": {
                "x": {
                    "value": "pitches",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "87",
                    "type": "int",
                    "possible_values": []
                }
            },
            "control_dependencies_41": {
                "control_inputs": {
                    "value": "assertions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.assert_greater_equal(pitches, 21), tf.assert_less_equal(pitches, 108)]",
                            "List"
                        ],
                        [
                            "[tf.assert_greater_equal(pitches, 0), tf.assert_less_equal(pitches, 87)]",
                            "List"
                        ]
                    ]
                }
            },
            "clip_by_value_84": {
                "t": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(categorical, dim)",
                            "Call"
                        ],
                        [
                            "tf.stack([piano_roll] * 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.multiply(piano_roll, colors_rgb)",
                            "Call"
                        ],
                        [
                            "piano_roll * 255.0",
                            "BinOp"
                        ],
                        [
                            "categorical",
                            "variable"
                        ],
                        [
                            "tf.image.rot90(piano_roll)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(piano_roll, [old_height * dilation, old_width])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.clip_by_value(piano_roll, 0.0, 255.0), tf.uint8)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "255.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "hsv_to_rgb_65": {
                "images": {
                    "value": "colors_hsv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.ones([dim, 3], dtype=np.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_77": {
                "input": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(categorical, dim)",
                            "Call"
                        ],
                        [
                            "tf.stack([piano_roll] * 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.multiply(piano_roll, colors_rgb)",
                            "Call"
                        ],
                        [
                            "piano_roll * 255.0",
                            "BinOp"
                        ],
                        [
                            "categorical",
                            "variable"
                        ],
                        [
                            "tf.image.rot90(piano_roll)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(piano_roll, [old_height * dilation, old_width])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.clip_by_value(piano_roll, 0.0, 255.0), tf.uint8)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_78": {
                "input": {
                    "value": "piano_roll",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(categorical, dim)",
                            "Call"
                        ],
                        [
                            "tf.stack([piano_roll] * 3, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.multiply(piano_roll, colors_rgb)",
                            "Call"
                        ],
                        [
                            "piano_roll * 255.0",
                            "BinOp"
                        ],
                        [
                            "categorical",
                            "variable"
                        ],
                        [
                            "tf.image.rot90(piano_roll)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_nearest_neighbor(piano_roll, [old_height * dilation, old_width])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.clip_by_value(piano_roll, 0.0, 255.0), tf.uint8)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/pianoroll_rnn_nade/pianoroll_rnn_nade_create_dataset.py": {
        "tensorflow": {
            "set_verbosity_49": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_66": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_67": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/pianoroll_rnn_nade/pianoroll_rnn_nade_create_dataset_test.py": {
        "tensorflow": {
            "disable_v2_behavior_25": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/pianoroll_rnn_nade/pianoroll_rnn_nade_generate.py": {
        "tensorflow": {
            "DEFINE_string_33": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where the latest checkpoint will be loaded from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_36": {
                "name": {
                    "value": "bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the bundle file. If specified, this will take priority over run_dir, unless save_generator_bundle is True, in which case both this flag and run_dir are required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_45": {
                "name": {
                    "value": "bundle_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A short, human-readable text description of the bundle (e.g., training data, hyper parameters, etc.).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_49": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "rnn-nade",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Config to use. Ignored if bundle is provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/pianoroll_rnn_nade/generated",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory where MIDI files will be saved to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_54": {
                "name": {
                    "value": "num_outputs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of tracks to generate. One MIDI file will be created for each.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_58": {
                "name": {
                    "value": "num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The total number of steps the generated track should be, priming track length + generated steps. Each step is a 16th of a bar.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_62": {
                "name": {
                    "value": "primer_pitches",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of pitches that will be used as a starting chord with a quarter note duration. For example: \"[60, 64, 67]\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_67": {
                "name": {
                    "value": "primer_pianoroll",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of `note_seq.PianorollSequence` event values (tuples of active MIDIpitches for a sequence of steps). For example: \"[(55,), (54,), (55, 53), (50,), (62, 52), (), (63, 55)]\".",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_72": {
                "name": {
                    "value": "primer_midi",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to a MIDI file containing a polyphonic track that will be used as a priming track.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_76": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to play generated output at. If a primer MIDI is given, the qpm from that will override this flag. If qpm is None, qpm will default to 60.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_81": {
                "name": {
                    "value": "beam_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The beam size to use for beam search when generating tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_84": {
                "name": {
                    "value": "branch_factor",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The branch factor to use for beam search when generating tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_87": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_91": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_199": {
                "msg": {
                    "value": "primer_sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "primer_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ],
                        [
                            "primer_pianoroll.to_sequence(qpm=qpm)",
                            "Call"
                        ],
                        [
                            "note_seq.midi_file_to_sequence_proto(primer_midi)",
                            "Call"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_200": {
                "msg": {
                    "value": "generator_options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_213": {
                "msg": {
                    "value": "Wrote %d MIDI files to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.num_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_219": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_248": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_249": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_134": {
                "msg": {
                    "value": "--output_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_142": {
                "filename": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_143": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_189": {
                "msg": {
                    "value": "Priming sequence is longer than the total number of steps requested: Priming sequence length: %s, Total length requested: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generate_section.start_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "generate_end_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.num_steps * seconds_per_step",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_241": {
                "msg": {
                    "value": "Saving generator bundle to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "bundle_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.bundle_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_240": {
                "msg": {
                    "value": "No bundle description provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_169": {
                "msg": {
                    "value": "No priming sequence specified. Defaulting to empty sequence.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/pianoroll_rnn_nade/pianoroll_rnn_nade_graph.py": {
        "tensorflow": {
            "Dense_68": {
                "variable": {
                    "value": "self._fc_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "num_dims + num_hidden",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_129": {
                "variable": {
                    "value": "(b_enc, b_dec)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "final_outputs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(final_outputs.rnn_output, lengths)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[self._nade.num_hidden, self._nade.num_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_158": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [hparams.batch_size, None, input_size])",
                            "Call"
                        ],
                        [
                            "sequences[:, 0:-1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(inputs, [[0, 0], [1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [1, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "info_242": {
                "msg": {
                    "value": "hparams = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.values()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_81": {
                "variable": {
                    "value": "self._empty_result",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[0, nade.num_dims]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_84": {
                "variable": {
                    "value": "(b_enc, b_dec)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [hparams.batch_size, None, input_size])",
                            "Call"
                        ],
                        [
                            "sequences[:, 0:-1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(inputs, [[0, 0], [1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[self._nade.num_hidden, self._nade.num_dims]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_107": {
                "variable": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.shape(inputs)[1:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_273": {
                "variable": {
                    "value": "inputs_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "magenta.common.flatten_maybe_padded_sequences(inputs, lengths)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_275": {
                "variable": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(cond_probs, 0.5)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_319": {
                "variable": {
                    "value": "f1_score",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(precision + recall, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "2 * (precision * recall / (precision + recall))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_209": {
                "name": {
                    "value": "RnnNadeZeroState",
                    "type": "str",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_256": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hparams.batch_size, None, input_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_278": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-log_probs",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_279": {
                "variable": {
                    "value": "perplexity",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(log_probs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_280": {
                "variable": {
                    "value": "correct_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(inputs_flat, predictions_flat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_282": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(inputs_flat, predictions_flat))",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_288": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "hparams.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_212": {
                "shape": {
                    "value": "(batch_size, self._nade.num_hidden)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "b_enc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_213": {
                "shape": {
                    "value": "(batch_size, self._num_dims)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "b_dec",
                    "type": "str",
                    "possible_values": []
                }
            },
            "greater_equal_275": {
                "x": {
                    "value": "cond_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_to_collection_292": {
                "name": {
                    "value": "train_op",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.learning.create_train_op(loss, optimizer, clip_gradient_norm=hparams.clip_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_320": {
                "x": {
                    "value": "precision + recall",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scalar_324": {
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_to_collection_325": {
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_to_collection_333": {
                "name": {
                    "value": "inputs",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [hparams.batch_size, None, input_size])",
                            "Call"
                        ],
                        [
                            "sequences[:, 0:-1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(inputs, [[0, 0], [1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_334": {
                "name": {
                    "value": "sample",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_to_collection_335": {
                "name": {
                    "value": "log_prob",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "flatten_338": {
                "structure": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn_nade.zero_state(hparams.batch_size)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "flatten_340": {
                "structure": {
                    "value": "final_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn_nade.steps(inputs, initial_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_107": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [hparams.batch_size, None, input_size])",
                            "Call"
                        ],
                        [
                            "sequences[:, 0:-1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(inputs, [[0, 0], [1, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_279": {
                "x": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "equal_281": {
                "x": {
                    "value": "inputs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(magenta.common.flatten_maybe_padded_sequences(inputs, lengths))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.greater_equal(cond_probs, 0.5))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_283": {
                "input_tensor": {
                    "value": "inputs_flat * predictions_flat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_284": {
                "input_tensor": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.greater_equal(cond_probs, 0.5))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_285": {
                "input_tensor": {
                    "value": "inputs_flat * predictions_flat",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_286": {
                "input_tensor": {
                    "value": "inputs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(magenta.common.flatten_maybe_padded_sequences(inputs, lengths))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_339": {
                "name": {
                    "value": "initial_state",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(initial_state)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(final_state)",
                            "Call"
                        ],
                        [
                            "self._get_state(inputs, lengths=lengths)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_341": {
                "name": {
                    "value": "final_state",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(initial_state)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(final_state)",
                            "Call"
                        ],
                        [
                            "self._get_state(inputs, lengths=lengths)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_315": {
                "name": {
                    "value": "eval_ops",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "updates_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "update_ops.values()",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_304": {
                "a": {
                    "value": "-log_probs",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mean_306": {
                "a": {
                    "value": "tf.exp(log_probs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "accuracy_308": {
                "labels": {
                    "value": "inputs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(magenta.common.flatten_maybe_padded_sequences(inputs, lengths))",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.greater_equal(cond_probs, 0.5))",
                            "Call"
                        ]
                    ]
                }
            },
            "precision_310": {
                "labels": {
                    "value": "inputs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(magenta.common.flatten_maybe_padded_sequences(inputs, lengths))",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.greater_equal(cond_probs, 0.5))",
                            "Call"
                        ]
                    ]
                }
            },
            "recall_312": {
                "labels": {
                    "value": "inputs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(magenta.common.flatten_maybe_padded_sequences(inputs, lengths))",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.greater_equal(cond_probs, 0.5))",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_306": {
                "x": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/pianoroll_rnn_nade/pianoroll_rnn_nade_train.py": {
        "tensorflow": {
            "DEFINE_string_26": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/rnn_nade/logdir/run1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where checkpoints and summary events will be saved during training and evaluation. Separate subdirectories for training events and eval events will be created within `run_dir`. Multiple runs can be stored within the parent directory of `run_dir`. Point TensorBoard to the parent directory of `run_dir` to see all your runs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "rnn-nade",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The config to use",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_36": {
                "name": {
                    "value": "sequence_example_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to TFRecord file containing tf.SequenceExample records for training or evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_40": {
                "name": {
                    "value": "num_training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The the number of global training steps your model should take before exiting training. Leave as 0 to run until terminated manually.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_44": {
                "name": {
                    "value": "num_eval_examples",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of evaluation examples your model should process for each evaluation step.Leave as 0 to use the entire evaluation set.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_48": {
                "name": {
                    "value": "summary_frequency",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "A summary statement will be logged every `summary_frequency` steps during training or every `summary_frequency` seconds during evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_53": {
                "name": {
                    "value": "num_checkpoints",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of most recent checkpoints to keep in the training directory. Keeps all if 0.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_59": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_62": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_79": {
                "variable": {
                    "value": "sequence_example_file_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "os.path.expanduser(FLAGS.sequence_example_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_70": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_91": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_92": {
                "msg": {
                    "value": "Train dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_112": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_113": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_73": {
                "msg": {
                    "value": "--run_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_76": {
                "msg": {
                    "value": "--sequence_example_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_96": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_97": {
                "msg": {
                    "value": "Eval dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_encoder_decoder_test.py": {
        "tensorflow": {
            "disable_v2_behavior_21": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_80": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_lib.py": {
        "tensorflow": {
            "debug_354": {
                "msg": {
                    "value": "'Ignoring START marker not at beginning of sequence at position %d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "debug_358": {
                "msg": {
                    "value": "'Ignoring END maker before end of sequence at position %d' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "debug_366": {
                "msg": {
                    "value": "'Attempted to continue pitch %s at step %s, but pitch was not active. Ignoring.' % (event.pitch, step)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_lib_test.py": {
        "tensorflow": {
            "disable_v2_behavior_26": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_588": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_rnn_create_dataset.py": {
        "tensorflow": {
            "set_verbosity_49": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_66": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_67": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_rnn_create_dataset_test.py": {
        "tensorflow": {
            "disable_v2_behavior_26": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_74": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_rnn_generate.py": {
        "tensorflow": {
            "disable_v2_behavior_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DEFINE_string_35": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where the latest checkpoint will be loaded from.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "bundle_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the bundle file. If specified, this will take priority over run_dir, unless save_generator_bundle is True, in which case both this flag and run_dir are required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_47": {
                "name": {
                    "value": "bundle_description",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "A short, human-readable text description of the bundle (e.g., training data, hyper parameters, etc.).",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "polyphony",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Config to use.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_53": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/polyphony_rnn/generated",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory where MIDI files will be saved to.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_56": {
                "name": {
                    "value": "num_outputs",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of tracks to generate. One MIDI file will be created for each.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_60": {
                "name": {
                    "value": "num_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The total number of steps the generated track should be, priming track length + generated steps. Each step is a 16th of a bar.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_64": {
                "name": {
                    "value": "primer_pitches",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of pitches that will be used as a starting chord with a quarter note duration. For example: \"[60, 64, 67]\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_69": {
                "name": {
                    "value": "primer_melody",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A string representation of a Python list of note_seq.Melody event values. For example: \"[60, -2, 60, -2, 67, -2, 67, -2]\".",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_73": {
                "name": {
                    "value": "primer_midi",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The path to a MIDI file containing a polyphonic track that will be used as a priming track.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_86": {
                "name": {
                    "value": "qpm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The quarters per minute to play generated output at. If a primer MIDI is given, the qpm from that will override this flag. If qpm is None, qpm will default to 120.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_91": {
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "The randomness of the generated tracks. 1.0 uses the unaltered softmax probabilities, greater than 1.0 makes tracks more random, less than 1.0 makes tracks less random.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_96": {
                "name": {
                    "value": "beam_size",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The beam size to use for beam search when generating tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_99": {
                "name": {
                    "value": "branch_factor",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The branch factor to use for beam search when generating tracks.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_102": {
                "name": {
                    "value": "steps_per_iteration",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of steps to take per beam search iteration.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_105": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_109": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_222": {
                "msg": {
                    "value": "primer_sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "primer_sequence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ],
                        [
                            "primer_melody.to_sequence(qpm=qpm)",
                            "Call"
                        ],
                        [
                            "note_seq.midi_file_to_sequence_proto(primer_midi)",
                            "Call"
                        ],
                        [
                            "music_pb2.NoteSequence()",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_223": {
                "msg": {
                    "value": "generator_options: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generator_options",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generator_pb2.GeneratorOptions()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_236": {
                "msg": {
                    "value": "Wrote %d MIDI files to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.num_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_242": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_271": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_152": {
                "msg": {
                    "value": "--output_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_160": {
                "filename": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_161": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_204": {
                "msg": {
                    "value": "Priming sequence is longer than the total number of steps requested: Priming sequence length: %s, Total length requested: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generate_section.start_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "generate_end_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.num_steps * seconds_per_step",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_264": {
                "msg": {
                    "value": "Saving generator bundle to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "bundle_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.bundle_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_263": {
                "msg": {
                    "value": "No bundle description provided.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_184": {
                "msg": {
                    "value": "No priming sequence specified. Defaulting to empty sequence.",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_rnn_train.py": {
        "tensorflow": {
            "disable_v2_behavior_25": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "DEFINE_string_28": {
                "name": {
                    "value": "run_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/polyphony_rnn/logdir/run1",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to the directory where checkpoints and summary events will be saved during training and evaluation. Separate subdirectories for training events and eval events will be created within `run_dir`. Multiple runs can be stored within the parent directory of `run_dir`. Point TensorBoard to the parent directory of `run_dir` to see all your runs.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_37": {
                "name": {
                    "value": "config",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "polyphony",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The config to use",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "sequence_example_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to TFRecord file containing tf.SequenceExample records for training or evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_42": {
                "name": {
                    "value": "num_training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The the number of global training steps your model should take before exiting training. Leave as 0 to run until terminated manually.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_46": {
                "name": {
                    "value": "num_eval_examples",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of evaluation examples your model should process for each evaluation step.Leave as 0 to use the entire evaluation set.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_50": {
                "name": {
                    "value": "summary_frequency",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "A summary statement will be logged every `summary_frequency` steps during training or every `summary_frequency` seconds during evaluation.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_55": {
                "name": {
                    "value": "num_checkpoints",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of most recent checkpoints to keep in the training directory. Keeps all if 0.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_61": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_64": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Comma-separated list of `name=value` pairs. For each pair, the value of the hyperparameter named `name` is set to `value`. This mapping is merged with the default hyperparameters.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Glob_81": {
                "variable": {
                    "value": "sequence_example_file_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "os.path.expanduser(FLAGS.sequence_example_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_verbosity_72": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MakeDirs_93": {
                "dirname": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_94": {
                "msg": {
                    "value": "Train dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'train')",
                            "Call"
                        ]
                    ]
                }
            },
            "run_114": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_75": {
                "msg": {
                    "value": "--run_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_78": {
                "msg": {
                    "value": "--sequence_example_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_98": {
                "dirname": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_99": {
                "msg": {
                    "value": "Eval dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "eval_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(run_dir, 'eval')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/polyphony_rnn/polyphony_sequence_generator.py": {
        "tensorflow": {
            "info_170": {
                "msg": {
                    "value": "'Need to generate %d more steps for this sequence, will try asking for %d RNN steps' % (steps_to_gen, rnn_steps_to_gen)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/rl_tuner/note_rnn_loader.py": {
        "tensorflow": {
            "latest_checkpoint_276": {
                "variable": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Coordinator_374": {
                "variable": {
                    "value": "coord",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_178": {
                "msg": {
                    "value": "Initializing melody RNN graph for scope %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_269": {
                "msg": {
                    "value": "Restoring variables from checkpoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_273": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "var_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dict()",
                            "Call"
                        ],
                        [
                            "self.get_variable_name_dict()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_275": {
                "msg": {
                    "value": "Checkpoint dir: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_281": {
                "msg": {
                    "value": "Checkpoint file: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(checkpoint_dir)",
                            "Call"
                        ],
                        [
                            "self.checkpoint_file",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "start_queue_runners_375": {
                "sess": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "coord": {
                    "value": "coord",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Coordinator()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_94": {
                "msg": {
                    "value": "Using custom hparams",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_97": {
                "msg": {
                    "value": "Empty hparams string. Using defaults",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_150": {
                "variable": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warn_278": {
                "msg": {
                    "value": "\"Can't find checkpoint file, using %s\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.checkpoint_file",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warn_292": {
                "msg": {
                    "value": "ERROR! No such primer file exists! %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.midi_primer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_306": {
                "msg": {
                    "value": "Priming the model with MIDI file %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.midi_primer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "warn_370": {
                "msg": {
                    "value": "No training file path was provided, cannot run trainingbatch",
                    "type": "str",
                    "possible_values": []
                }
            },
            "initialize_all_variables_153": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_181": {
                "device_name": {
                    "value": "lambda op: ''",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "placeholder_192": {
                "variable": {
                    "value": "self.melody_sequence",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, self.hparams.one_hot_length]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "melody_sequence",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_196": {
                "variable": {
                    "value": "self.lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "lengths",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_197": {
                "variable": {
                    "value": "self.initial_state",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, self.cell.state_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "initial_state",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_247": {
                "variable": {
                    "value": "self.softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_355": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_394": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_182": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dynamic_rnn_227": {
                "variable": {
                    "value": "(outputs, final_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "self.cell",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "m_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_state": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_235": {
                "variable": {
                    "value": "outputs_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self.hparams.rnn_layer_sizes[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_260": {
                "variable": {
                    "value": "self.train_softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.train_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_415": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_254": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/rl_tuner/rl_tuner.py": {
        "tensorflow": {
            "Graph_150": {
                "variable": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_all_535": {
                "variable": {
                    "value": "self.summarize",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_op_536": {
                "variable": {
                    "value": "self.no_op1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_199": {
                "variable": {
                    "value": "self.discount_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.dqn_hparams.discount_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_200": {
                "variable": {
                    "value": "self.target_network_update_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.dqn_hparams.target_network_update_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_203": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_297": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_298": {
                "variable": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_359": {
                "msg": {
                    "value": "Stored priming notes: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.priming_notes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_419": {
                "msg": {
                    "value": "Adding reward computation portion of the graph",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_421": {
                "variable": {
                    "value": "self.reward_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.reward_rnn()",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "reward_scores",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_423": {
                "msg": {
                    "value": "Adding taking action portion of graph",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_427": {
                "variable": {
                    "value": "self.action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.q_network()",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "action_scores",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_451": {
                "msg": {
                    "value": "Add estimating future rewards portion of graph",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stop_gradient_455": {
                "variable": {
                    "value": "self.next_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.target_q_network()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "placeholder_460": {
                "variable": {
                    "value": "self.rewards",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "rewards",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_485": {
                "msg": {
                    "value": "Adding q value prediction portion of graph",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_489": {
                "variable": {
                    "value": "self.action_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, self.num_actions)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "action_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_491": {
                "variable": {
                    "value": "self.masked_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.action_scores * self.action_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_500": {
                "variable": {
                    "value": "self.prediction_error",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(temp_diff)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "trainable_variables_503": {
                "variable": {
                    "value": "self.params",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_519": {
                "msg": {
                    "value": "Adding target network update portion of graph",
                    "type": "str",
                    "possible_values": []
                }
            },
            "group_530": {
                "variable": {
                    "value": "self.target_network_update",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*self.target_network_update",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "scalar_532": {
                "name": {
                    "value": "prediction_error",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.prediction_error",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_552": {
                "msg": {
                    "value": "Evaluating initial model...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1019": {
                "msg": {
                    "value": "Key: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1453": {
                "msg": {
                    "value": "Action_note: %s, prev_note: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "action_note",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "prev_note",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.composition[-1]",
                            "Subscript"
                        ],
                        [
                            "self.composition[prev_note_index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "debug_1492": {
                "msg": {
                    "value": "Interval:",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "interval",
                    "type": "variable",
                    "possible_values": [
                        [
                            "abs(action_note - prev_note)",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_1547": {
                "msg": {
                    "value": "Interval reward",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward * scaler",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_1747": {
                "msg": {
                    "value": "Priming with note %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "np.argmax(next_obs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_1788": {
                "msg": {
                    "value": "Generated sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "generated_seq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0] * length",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_1801": {
                "msg": {
                    "value": "Wrote a melody to %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "latest_checkpoint_2016": {
                "variable": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "directory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_2025": {
                "msg": {
                    "value": "Attempting to restore from checkpoint %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(directory, checkpoint_name)",
                            "Call"
                        ],
                        [
                            "tf.train.latest_checkpoint(directory)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_259": {
                "msg": {
                    "value": "Initializing q network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_269": {
                "msg": {
                    "value": "Initializing target q network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_280": {
                "msg": {
                    "value": "Initializing reward network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_290": {
                "msg": {
                    "value": "Q network cell: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.q_network.cell",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_293": {
                "msg": {
                    "value": "Adding RL graph variables",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_330": {
                "msg": {
                    "value": "Getting priming melodies",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_380": {
                "msg": {
                    "value": "Feeding priming state for midi file %s and corresponding note %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "priming_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.randint(0, len(self.priming_states))",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "priming_note",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.priming_notes[priming_idx]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "name_scope_420": {
                "name": {
                    "value": "reward_computation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_424": {
                "name": {
                    "value": "taking_action",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_428": {
                "name": {
                    "value": "action_scores",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.action_scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_436": {
                "variable": {
                    "value": "self.action_softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.g_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "action_softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_438": {
                "variable": {
                    "value": "self.predicted_actions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.argmax(self.g_action_scores, dimension=1, name='predicted_actions')",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.num_actions",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_444": {
                "variable": {
                    "value": "self.action_softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "action_softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_446": {
                "variable": {
                    "value": "self.predicted_actions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.argmax(self.action_scores, dimension=1, name='predicted_actions')",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.num_actions",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_452": {
                "name": {
                    "value": "estimating_future_rewards",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_456": {
                "name": {
                    "value": "target_action_scores",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "self.next_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_465": {
                "variable": {
                    "value": "self.target_vals",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.next_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_486": {
                "name": {
                    "value": "q_value_prediction",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_520": {
                "name": {
                    "value": "target_network_update",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_558": {
                "msg": {
                    "value": "Using stochastic environment",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1024": {
                "msg": {
                    "value": "Tonic: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1029": {
                "msg": {
                    "value": "Penalize repeating: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1034": {
                "msg": {
                    "value": "Penalize autocorr: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1039": {
                "msg": {
                    "value": "Reward motif: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1044": {
                "msg": {
                    "value": "Reward repeated motif: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1051": {
                "msg": {
                    "value": "Reward preferred_intervals: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1056": {
                "msg": {
                    "value": "Reward leap up back: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1061": {
                "msg": {
                    "value": "Reward high low unique: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.collect_reward(last_observation, new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_scale(obs, action)",
                            "Call"
                        ],
                        [
                            "self.reward_key_distribute_prob(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "reward + reward_amount",
                            "BinOp"
                        ],
                        [
                            "self.reward_non_repeating(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "self.reward_preferred_intervals(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_music_theory(action)",
                            "Call"
                        ],
                        [
                            "self.reward_key(action)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "extra_prob",
                            "variable"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "penalty_amount",
                            "variable"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.075",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.3",
                            "float"
                        ],
                        [
                            "-0.3",
                            "UnaryOp"
                        ],
                        [
                            "-1.0",
                            "UnaryOp"
                        ],
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.15",
                            "float"
                        ],
                        [
                            "0.09",
                            "float"
                        ],
                        [
                            "0.08",
                            "float"
                        ],
                        [
                            "0.07",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.02",
                            "float"
                        ],
                        [
                            "0.0",
                            "float"
                        ]
                    ]
                }
            },
            "debug_1450": {
                "msg": {
                    "value": "Action_note: %s, prev_note: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "action_note",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ],
                        [
                            "np.argmax(action)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "prev_note",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.composition[-1]",
                            "Subscript"
                        ],
                        [
                            "self.composition[prev_note_index]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "debug_1495": {
                "msg": {
                    "value": "No interval or uninteresting.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1503": {
                "msg": {
                    "value": "Rest interval.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1508": {
                "msg": {
                    "value": "Rest interval after 1st or 5th.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1515": {
                "msg": {
                    "value": "7th",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1518": {
                "msg": {
                    "value": "More than octave.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1523": {
                "msg": {
                    "value": "In key 5th",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1526": {
                "msg": {
                    "value": "In key 3rd",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1531": {
                "msg": {
                    "value": "3rd",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1534": {
                "msg": {
                    "value": "2nd",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1537": {
                "msg": {
                    "value": "4th",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1542": {
                "msg": {
                    "value": "6th",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1545": {
                "msg": {
                    "value": "5th",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1629": {
                "msg": {
                    "value": "Rest, adding to steps since last leap. It isnow: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.steps_since_last_leap",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_1669": {
                "msg": {
                    "value": "No leap, adding to steps since last leap. It is now: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.steps_since_last_leap",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_1705": {
                "msg": {
                    "value": "Leap resolved, awarding %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "resolving_leap_bonus",
                    "type": "variable",
                    "possible_values": [
                        [
                            "5.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_1804": {
                "msg": {
                    "value": "Visualizing note selection probabilities:",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_2015": {
                "msg": {
                    "value": "Directory %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "directory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "self.output_dir",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "fatal_2019": {
                "msg": {
                    "value": "Error! Cannot locate checkpoint in the directory",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_2035": {
                "msg": {
                    "value": "Attempting to load saved reward values from file %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "npz_file_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(directory, reward_file_name)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_174": {
                "msg": {
                    "value": "A midi primer file is required when usingthe single_midi priming mode.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_initializer_299": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_logsumexp_468": {
                "variable": {
                    "value": "self.g_normalizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.reward_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_470": {
                "variable": {
                    "value": "self.g_normalizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.g_normalizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_471": {
                "variable": {
                    "value": "self.g_normalizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.g_normalizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, self.num_actions]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "subtract_472": {
                "variable": {
                    "value": "self.g_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.next_action_scores + self.reward_scores",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.g_normalizer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_474": {
                "variable": {
                    "value": "self.target_vals",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.g_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_478": {
                "variable": {
                    "value": "self.target_vals",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.next_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_500": {
                "x": {
                    "value": "temp_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.masked_action_scores - self.future_rewards",
                            "BinOp"
                        ]
                    ]
                }
            },
            "histogram_512": {
                "name": {
                    "value": "var.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_594": {
                "msg": {
                    "value": "Evaluating model...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_612": {
                "msg": {
                    "value": "Training iteration %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(len(lengths))",
                            "Call"
                        ],
                        [
                            "range(num_steps)",
                            "Call"
                        ],
                        [
                            "range(len(self.composition) - 1, -1, -1)",
                            "Call"
                        ],
                        [
                            "range(len(prev_composition) - len(motif) + 1)",
                            "Call"
                        ],
                        [
                            "range(length)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_613": {
                "msg": {
                    "value": "\\tReward for last %s steps: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.output_every_nth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.reward_last_n",
                            "Attribute"
                        ]
                    ]
                }
            },
            "info_615": {
                "msg": {
                    "value": "\\t\\tMusic theory reward: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.music_theory_reward_last_n",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_617": {
                "msg": {
                    "value": "\\t\\tNote RNN reward: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.note_rnn_reward_last_n",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_645": {
                "msg": {
                    "value": "\\nResetting composition!\\n",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1637": {
                "msg": {
                    "value": "Detected an ascending leap",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1640": {
                "msg": {
                    "value": "Detected a descending leap",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1660": {
                "msg": {
                    "value": "There was no previous leap direction",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1679": {
                "msg": {
                    "value": "detected a gradually resolved leap",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1708": {
                "msg": {
                    "value": "Leap doubled, awarding %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "leaping_twice_punishment",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-5.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_319": {
                "msg": {
                    "value": "\\nSuccessfully initialized internal nets from checkpoint!",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_322": {
                "msg": {
                    "value": "Error! The model was not initialized from checkpoint properly",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warn_389": {
                "msg": {
                    "value": "Error! Invalid priming mode. Priming with random note",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_438": {
                "input": {
                    "value": "self.g_action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dimension": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "predicted_actions",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_446": {
                "input": {
                    "value": "self.action_scores",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dimension": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "predicted_actions",
                    "type": "str",
                    "possible_values": []
                }
            },
            "histogram_514": {
                "name": {
                    "value": "var.name + '/gradients'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_631": {
                "msg": {
                    "value": "\\tExploration probability is %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "exploration_p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rl_tuner_ops.linear_annealing(self.actions_executed_so_far, exploration_period, 1.0, self.dqn_hparams.random_action_probability)",
                            "Call"
                        ],
                        [
                            "rl_tuner_ops.linear_annealing(self.actions_executed_so_far, exploration_period, 1.0, self.dqn_hparams.random_action_probability)",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_1645": {
                "msg": {
                    "value": "Detected a resolved leap",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_1646": {
                "msg": {
                    "value": "Num steps since last leap: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.steps_since_last_leap",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "debug_1655": {
                "msg": {
                    "value": "Detected a double leap",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_norm_509": {
                "t": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "debug_1650": {
                "msg": {
                    "value": "Sufficient steps before leap resolved, awarding bonus",
                    "type": "str",
                    "possible_values": []
                }
            },
            "debug_948": {
                "msg": {
                    "value": "Note RNN reward: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "note_rnn_reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.reward_from_reward_rnn_scores(new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_from_reward_rnn_scores(action, reward_scores)",
                            "Call"
                        ]
                    ]
                }
            },
            "debug_952": {
                "msg": {
                    "value": "Total music theory reward: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.reward_scaler * reward",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "debug_954": {
                "msg": {
                    "value": "Total note rnn reward: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "note_rnn_reward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.reward_from_reward_rnn_scores(new_observation, reward_scores)",
                            "Call"
                        ],
                        [
                            "self.reward_from_reward_rnn_scores(action, reward_scores)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_961": {
                "msg": {
                    "value": "ERROR! Not a valid reward mode. Cannot compute reward",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/rl_tuner/rl_tuner_eval_metrics.py": {
        "tensorflow": {
            "info_55": {
                "msg": {
                    "value": "get_stat_dict_string(stat_dict)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/rl_tuner/rl_tuner_ops.py": {
        "tensorflow": {
            "MultiRNNCell_313": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cells": {
                    "value": "cells",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "state_is_tuple": {
                    "value": "state_is_tuple",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_320": {
                "variable": {
                    "value": "maxes",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xs - maxes",
                            "BinOp"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "LSTMCell_310": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "num_units",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn_layer_sizes",
                            "variable"
                        ]
                    ]
                },
                "state_is_tuple": {
                    "value": "state_is_tuple",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squeeze_322": {
                "input": {
                    "value": "maxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(xs, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_322": {
                "x": {
                    "value": "tf.reduce_sum(tf.exp(xs), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "warn_190": {
                "msg": {
                    "value": "\"Error! sample softmax function shouldn't get here\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_322": {
                "input_tensor": {
                    "value": "tf.exp(xs)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "global_variables_268": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "exp_322": {
                "x": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xs - maxes",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/rl_tuner/rl_tuner_test.py": {
        "tensorflow": {
            "disable_v2_behavior_31": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_46": {
                "variable": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_47": {
                "variable": {
                    "value": "self.session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "graph": {
                    "value": "graph",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "main_125": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_52": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "note_rnn.get_variable_name_dict()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/rl_tuner/rl_tuner_train.py": {
        "tensorflow": {
            "DEFINE_string_40": {
                "name": {
                    "value": "output_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory where the model will save itscompositions and checkpoints (midi files)",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_43": {
                "name": {
                    "value": "note_rnn_checkpoint_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to directory holding checkpoints for note rnnmelody prediction models. These will be loaded intothe NoteRNNLoader class object. The directory should contain a train subdirectory",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_48": {
                "name": {
                    "value": "note_rnn_checkpoint_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "note_rnn.ckpt",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Filename of a checkpoint within the note_rnn_checkpoint_dir directory.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_51": {
                "name": {
                    "value": "note_rnn_type",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "default",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "If `default`, will use the basic LSTM described in the research paper. If `basic_rnn`, will assume the checkpoint is from a Magenta basic_rnn model.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_55": {
                "name": {
                    "value": "midi_primer",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "./testdata/primer.mid",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "A midi file that can be used to prime the model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_57": {
                "name": {
                    "value": "training_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "1000000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of steps used to train the model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_59": {
                "name": {
                    "value": "exploration_steps",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "500000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of steps over which the modelsprobability of taking a random action (exploring)will be annealed from 1.0 to its normalexploration probability. Typically about half thetraining_steps",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_65": {
                "name": {
                    "value": "exploration_mode",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "boltzmann",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Can be either egreedy for epsilon-greedy or boltzmann, which will sample from the modelsoutput distribution to select the next action",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_69": {
                "name": {
                    "value": "output_every_nth",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "50000",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of steps before the model will evaluateitself and store a checkpoint",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_integer_72": {
                "name": {
                    "value": "num_notes_in_melody",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "help": {
                    "value": "The number of notes in each composition",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_float_74": {
                "name": {
                    "value": "reward_scaler",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "help": {
                    "value": "The weight placed on music theory rewards",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_76": {
                "name": {
                    "value": "training_data_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory where the model will get melody trainingexamples",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_79": {
                "name": {
                    "value": "algorithm",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "q",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The name of the algorithm to use for training themodel. Can be q, psi, or g",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_118": {
                "msg": {
                    "value": "Saving images and melodies to: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "rlt.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_120": {
                "msg": {
                    "value": "Training...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_124": {
                "msg": {
                    "value": "Finished training. Saving output figures and composition.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_132": {
                "msg": {
                    "value": "Calculating music theory metric stats for 1000 compositions.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_138": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_139": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/score2perf/datagen_beam.py": {
        "tensorflow": {
            "Glob_407": {
                "variable": {
                    "value": "existing_output_filenames",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "output_filename + '*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Glob_655": {
                "variable": {
                    "value": "existing_output_filenames",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "output_filename + '*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_409": {
                "msg": {
                    "value": "Data files already exist for split %s in problem %s, deleting.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "split_name",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "problem_name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_657": {
                "msg": {
                    "value": "Data files already exist for split %s in problem %s, deleting.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "split_name",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "problem_name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Remove_413": {
                "filename": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "existing_output_filenames",
                            "variable"
                        ],
                        [
                            "existing_output_filenames",
                            "variable"
                        ]
                    ]
                }
            },
            "Remove_661": {
                "filename": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "existing_output_filenames",
                            "variable"
                        ],
                        [
                            "existing_output_filenames",
                            "variable"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/score2perf/datagen_beam_test.py": {
        "tensorflow": {
            "disable_v2_behavior_31": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_62": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/score2perf/modalities.py": {
        "tensorflow": {
            "concat_42": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "shards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_56": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.gather(var, x[:, :, :, i] + sum(vocab_size[:i])) * tf.expand_dims(tf.to_float(tf.not_equal(x[:, :, :, i], 0)), -1) for i in range(len(vocab_size))]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "executing_eagerly_44": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_51": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_36": {
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'weights_%d' % i",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shard_size, hidden_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(0.0, hidden_dim ** (-0.5))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_38": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "hidden_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_57": {
                "params": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_get_weights(model_hparams, vocab_size)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "x[:, :, :, i] + sum(vocab_size[:i])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_58": {
                "input": {
                    "value": "tf.to_float(tf.not_equal(x[:, :, :, i], 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_float_58": {
                "x": {
                    "value": "tf.not_equal(x[:, :, :, i], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "not_equal_58": {
                "x": {
                    "value": "x[:, :, :, i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/score2perf/modalities_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_59": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "split_50": {
                "variable": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.stack([-1 + np.random.random_integers(vocab_size[i], size=(batch_size, length, 1)) for i in range(len(vocab_size))], axis=3)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_datashards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "5",
                            "int"
                        ]
                    ]
                }
            },
            "concat_52": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "sharded_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_parallelism(bottom, xs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/score2perf/music_encoders_test.py": {
        "tensorflow": {
            "disable_v2_behavior_23": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_367": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/score2perf/score2perf.py": {
        "tensorflow": {
            "VarLenFeature_228": {
                "variable": {
                    "value": "data_fields[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_243": {
                "variable": {
                    "value": "example[inputs]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_248": {
                "variable": {
                    "value": "max_offset",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(example['targets'])[0] - hparams.max_target_seq_length",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_250": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "max_offset > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.random_uniform([], maxval=max_offset, dtype=tf.int32)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : 0",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "VarLenFeature_342": {
                "variable": {
                    "value": "data_fields[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_438": {
                "variable": {
                    "value": "data_fields[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_225": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mod_263": {
                "variable": {
                    "value": "extra_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(example['targets'])[0]",
                            "Subscript"
                        ]
                    ]
                },
                "x2": {
                    "value": "hparams.max_target_seq_length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_338": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_339": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_435": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_241": {
                "input": {
                    "value": "example[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_262": {
                "input": {
                    "value": "example['targets']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_265": {
                "tensor": {
                    "value": "example['targets'][:length - extra_length]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, hparams.max_target_seq_length, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_270": {
                "tensor": {
                    "value": "example['targets'][-extra_length:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, -1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_249": {
                "input": {
                    "value": "example['targets']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/score2perf/transformer_autoencoder.py": {
        "tensorflow": {
            "dropout_90": {
                "variable": {
                    "value": "encoder_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(encoder_input, 1.0 - hparams.layer_prepostprocess_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - hparams.layer_prepostprocess_dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_165": {
                "variable": {
                    "value": "perf_encoder_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "perf_encoder_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(perf_encoder_input, 1.0 - hparams.layer_prepostprocess_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - hparams.layer_prepostprocess_dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_184": {
                "variable": {
                    "value": "mel_encoder_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mel_encoder_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(mel_encoder_input, 1.0 - hparams.layer_prepostprocess_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - hparams.layer_prepostprocess_dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_218": {
                "variable": {
                    "value": "perf_mean_vector",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "perf_encoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_function(perf_encoder_input, perf_self_attention_bias, hparams, name='perf_encoder', nonpadding=features_to_nonpadding(features, 'inputs'), save_weights_to=attention_weights, make_image_summary=not common_layers.is_xla_compiled(), losses=losses, attn_bias_for_padding=perf_attn_bias_for_padding, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "dropout_293": {
                "variable": {
                    "value": "decoder_input",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "decoder_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.dropout(decoder_input, 1.0 - hparams.layer_prepostprocess_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "1.0 - hparams.layer_prepostprocess_dropout",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_111": {
                "variable": {
                    "value": "encoder_output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "encoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_function(encoder_input, self_attention_bias, hparams, name='encoder', nonpadding=features_to_nonpadding(features, 'inputs'), save_weights_to=attention_weights, make_image_summary=not common_layers.is_xla_compiled(), losses=losses, attn_bias_for_padding=attn_bias_for_padding, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_mean(encoder_output, axis=1, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "mel_encoder_output + perf_mean_vector",
                            "BinOp"
                        ],
                        [
                            "tf.concat([mel_encoder_output, stop_token, perf_mean_vector], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([mel_encoder_output, tiled_mean], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_113": {
                "variable": {
                    "value": "encoder_decoder_attention_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "encoder_decoder_attention_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_mean(encoder_decoder_attention_bias, axis=-1, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "mel_encdec_attention_bias + perf_mean_bias",
                            "BinOp"
                        ],
                        [
                            "tf.concat([mel_encdec_attention_bias, stop_bias, perf_mean_bias], axis=-1)",
                            "Call"
                        ],
                        [
                            "mel_encdec_attention_bias",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_224": {
                "variable": {
                    "value": "perf_mean_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "perf_encdec_attention_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_480": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "decoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder_function(decoder_input, encoder_output, decoder_self_attention_bias, encoder_decoder_attention_bias, hparams, cache=cache, decode_loop_step=decode_loop_step, nonpadding=nonpadding, save_weights_to=attention_weights, losses=losses, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.decode(decoder_input, encoder_output, encoder_decoder_attention_bias, decoder_self_attention_bias, hparams, nonpadding=features_to_nonpadding(features, 'targets'), losses=losses, **decode_kwargs)",
                            "Call"
                        ],
                        [
                            "self.decode(decoder_input, encoder_output, encoder_decoder_attention_bias, decoder_self_attention_bias, hparams, nonpadding=features_to_nonpadding(features, 'targets'), losses=losses, **decode_kwargs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "targets_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common_layers.shape_list(targets)",
                            "Call"
                        ],
                        [
                            "common_layers.shape_list(targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "slice_593": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int64(features['partial_targets'])",
                            "Call"
                        ],
                        [
                            "tf.zeros((batch_size, 0, 1, 1), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(initial_output, 2)",
                            "Call"
                        ],
                        [
                            "tf.zeros((batch_size, 0, 1, dim), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.slice(initial_output, [0, 0, 0, 0], common_layers.shape_list(initial_output))",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "common_layers.shape_list(initial_output)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "while_loop_653": {
                "variable": {
                    "value": "(result, logits, loss)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "while_exit_cond",
                    "type": "variable",
                    "possible_values": []
                },
                "body": {
                    "value": "infer_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[result, logits, loss]",
                    "type": "List",
                    "possible_values": []
                },
                "shape_invariants": {
                    "value": "[tf.TensorShape([None, None, None, None]), tf.TensorShape(logits_shape_inv), tf.TensorShape([])]",
                    "type": "List",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_775": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "decoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder_function(decoder_input, encoder_output, decoder_self_attention_bias, encoder_decoder_attention_bias, hparams, cache=cache, decode_loop_step=decode_loop_step, nonpadding=nonpadding, save_weights_to=attention_weights, losses=losses, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.decode(decoder_input, encoder_output, encoder_decoder_attention_bias, decoder_self_attention_bias, hparams, nonpadding=features_to_nonpadding(features, 'targets'), losses=losses, **decode_kwargs)",
                            "Call"
                        ],
                        [
                            "self.decode(decoder_input, encoder_output, encoder_decoder_attention_bias, decoder_self_attention_bias, hparams, nonpadding=features_to_nonpadding(features, 'targets'), losses=losses, **decode_kwargs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "targets_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common_layers.shape_list(targets)",
                            "Call"
                        ],
                        [
                            "common_layers.shape_list(targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_230": {
                "variable": {
                    "value": "stop_token",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, 384)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_231": {
                "variable": {
                    "value": "encoder_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[mel_encoder_output, stop_token, perf_mean_vector]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_233": {
                "variable": {
                    "value": "perf_mean_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "perf_encdec_attention_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_235": {
                "variable": {
                    "value": "stop_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_236": {
                "variable": {
                    "value": "encoder_decoder_attention_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[mel_encdec_attention_bias, stop_bias, perf_mean_bias]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_316": {
                "input": {
                    "value": "decoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder_function(decoder_input, encoder_output, decoder_self_attention_bias, encoder_decoder_attention_bias, hparams, cache=cache, decode_loop_step=decode_loop_step, nonpadding=nonpadding, save_weights_to=attention_weights, losses=losses, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.decode(decoder_input, encoder_output, encoder_decoder_attention_bias, decoder_self_attention_bias, hparams, nonpadding=features_to_nonpadding(features, 'targets'), losses=losses, **decode_kwargs)",
                            "Call"
                        ],
                        [
                            "self.decode(decoder_input, encoder_output, encoder_decoder_attention_bias, decoder_self_attention_bias, hparams, nonpadding=features_to_nonpadding(features, 'targets'), losses=losses, **decode_kwargs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_450": {
                "variable": {
                    "value": "chunk_number_each_token",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features['chunk_number']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "(-1, -2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "to_int64_529": {
                "variable": {
                    "value": "features[partial_targets]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "partial_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features.get('inputs')",
                            "Call"
                        ],
                        [
                            "features['targets']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "pad_547": {
                "variable": {
                    "value": "padded",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "recent_output",
                    "type": "variable",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, 0], [0, 1], [0, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_571": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[recent_logits, logits[:, -1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int64_578": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "features['partial_targets']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_614": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0, 1, vocab_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_618": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0, 1, 1, vocab_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "slice_672": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initial_output",
                            "variable"
                        ],
                        [
                            "tf.slice(result, [0, partial_target_length, 0, 0], [-1, -1, -1, -1])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, partial_target_length, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, -1, -1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_745": {
                "variable": {
                    "value": "chunk_number_each_token",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "features['chunk_number']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "(-1, -2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "convert_to_tensor_241": {
                "variable": {
                    "value": "shp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[1, dynamic_val, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_242": {
                "variable": {
                    "value": "tiled_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "perf_mean_vector",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.reduce_mean(perf_encoder_output, axis=1, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "shp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor([1, dynamic_val, 1], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_244": {
                "variable": {
                    "value": "encoder_output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[mel_encoder_output, tiled_mean]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_512": {
                "variable": {
                    "value": "features[inputs]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "features['inputs']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_562": {
                "variable": {
                    "value": "cur_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cur_sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples[:, -1, :, :]",
                            "Subscript"
                        ],
                        [
                            "samples[:, common_layers.shape_list(recent_output)[1], :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(cur_sample, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int64(tf.expand_dims(cur_sample, axis=1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_563": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[recent_output, cur_sample]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int64_565": {
                "variable": {
                    "value": "cur_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(cur_sample, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_566": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[recent_output, cur_sample]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_580": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_int64(features['partial_targets'])",
                            "Call"
                        ],
                        [
                            "tf.zeros((batch_size, 0, 1, 1), dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(initial_output, 2)",
                            "Call"
                        ],
                        [
                            "tf.zeros((batch_size, 0, 1, dim), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.slice(initial_output, [0, 0, 0, 0], common_layers.shape_list(initial_output))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_588": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0, 1, dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_590": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "executing_eagerly_620": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cond_637": {
                "variable": {
                    "value": "not_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.not_equal(length, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "fn_not_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : True",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_517": {
                "variable": {
                    "value": "features[melody]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "features['melody']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_521": {
                "variable": {
                    "value": "features[performance]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "features['performance']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "executing_eagerly_539": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cond_645": {
                "pred": {
                    "value": "tf.equal(batch_size, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.logical_and(not_overflow, not_eos)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : not_overflow",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "shape_240": {
                "input": {
                    "value": "mel_encoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_function(mel_encoder_input, mel_self_attention_bias, hparams, name='mel_encoder', nonpadding=features_to_nonpadding(features, 'inputs'), save_weights_to=attention_weights, make_image_summary=not common_layers.is_xla_compiled(), losses=losses, attn_bias_for_padding=mel_attn_bias_for_padding, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_482": {
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{'training': loss}",
                            "Dict"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_565": {
                "input": {
                    "value": "cur_sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "samples[:, -1, :, :]",
                            "Subscript"
                        ],
                        [
                            "samples[:, common_layers.shape_list(recent_output)[1], :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(cur_sample, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int64(tf.expand_dims(cur_sample, axis=1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "executing_eagerly_567": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "not_equal_634": {
                "x": {
                    "value": "tf.squeeze(result[:, -1, :, :])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "text_encoder.EOS_ID",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "not_equal_640": {
                "x": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common_layers.shape_list(result)[1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_646": {
                "x": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common_layers.shape_list(features['performance'])[0]",
                            "Subscript"
                        ],
                        [
                            "common_layers.shape_list(initial_output)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_657": {
                "dims": {
                    "value": "[None, None, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_658": {
                "dims": {
                    "value": "logits_shape_inv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[None, None, None, None]",
                            "List"
                        ],
                        [
                            "[None, None, None, None, None]",
                            "List"
                        ]
                    ]
                }
            },
            "TensorShape_659": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_777": {
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{'training': loss}",
                            "Dict"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squeeze_635": {
                "input": {
                    "value": "result[:, -1, :, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "logical_and_648": {
                "x": {
                    "value": "not_overflow",
                    "type": "variable",
                    "possible_values": [
                        [
                            "length < decode_length",
                            "Compare"
                        ]
                    ]
                },
                "y": {
                    "value": "not_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(tf.not_equal(length, 0), fn_not_eos, lambda : True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/shared/events_rnn_graph.py": {
        "tensorflow": {
            "info_96": {
                "msg": {
                    "value": "hparams = %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "hparams.values()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dynamic_rnn_137": {
                "variable": {
                    "value": "(outputs, final_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_cell(rnn_layer_sizes[i])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell(cells)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.AttentionCellWrapper(cell, attn_length, state_is_tuple=True)",
                            "Call"
                        ],
                        [
                            "rnn.ResidualWrapper(cell)",
                            "Call"
                        ],
                        [
                            "rnn.DropoutWrapper(cell, output_keep_prob=dropout_keep_prob)",
                            "Call"
                        ],
                        [
                            "contrib_rnn.InputProjectionWrapper(cell, rnn_layer_sizes[i])",
                            "Call"
                        ],
                        [
                            "make_rnn_cell(hparams.rnn_layer_sizes, dropout_keep_prob=dropout_keep_prob, attn_length=hparams.attn_length, residual_connections=hparams.residual_connections)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "expanded_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.cast(tf.squeeze(inputs, axis=-1), tf.int64), encoder_decoder.input_depth)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_state": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell.zero_state(hparams.batch_size, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "warning_94": {
                "msg": {
                    "value": "cuDNN LSTM no longer supported. Using regular LSTM.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_121": {
                "variable": {
                    "value": "expanded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.cast(tf.squeeze(inputs, axis=-1), tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "encoder_decoder.input_depth",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_172": {
                "variable": {
                    "value": "correct_predictions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(labels_flat, predictions_flat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_174": {
                "variable": {
                    "value": "event_positions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.not_equal(labels_flat, no_event_label)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_175": {
                "variable": {
                    "value": "no_event_positions",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(labels_flat, no_event_label)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "py_func_185": {
                "variable": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "batch_labels_to_num_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[labels, lengths]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_116": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[hparams.batch_size, None, input_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_154": {
                "variable": {
                    "value": "softmax_cross_entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "labels_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.layers.linear(outputs_flat, num_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_156": {
                "variable": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.layers.linear(outputs_flat, num_logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_170": {
                "variable": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_189": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "softmax_cross_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels_flat, logits=logits_flat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "exp_190": {
                "variable": {
                    "value": "perplexity",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(softmax_cross_entropy)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_191": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "correct_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(labels_flat, predictions_flat))",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_200": {
                "variable": {
                    "value": "perplexity_per_step",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "loss_per_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(softmax_cross_entropy) / num_steps",
                            "BinOp"
                        ]
                    ]
                }
            },
            "AdamOptimizer_202": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "hparams.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_250": {
                "variable": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_122": {
                "x": {
                    "value": "tf.squeeze(inputs, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_173": {
                "x": {
                    "value": "labels_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits_flat, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack(predictions, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_174": {
                "x": {
                    "value": "labels_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "no_event_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_decoder.default_event_label",
                            "Attribute"
                        ]
                    ]
                }
            },
            "equal_175": {
                "x": {
                    "value": "labels_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "no_event_label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_decoder.default_event_label",
                            "Attribute"
                        ]
                    ]
                }
            },
            "add_to_collection_206": {
                "name": {
                    "value": "train_op",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.learning.create_train_op(loss, optimizer, clip_gradient_norm=hparams.clip_norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_240": {
                "variable": {
                    "value": "vars_to_summarize[metrics/perplexity]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "vars_to_summarize['loss']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "exp_242": {
                "variable": {
                    "value": "vars_to_summarize[metrics/perplexity_per_step]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "vars_to_summarize['metrics/loss_per_step']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "scalar_246": {
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_to_collection_247": {
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "softmax_252": {
                "variable": {
                    "value": "softmax_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tf.div(logits_flat, tf.fill([num_classes], temperature))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_254": {
                "variable": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "softmax_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tf.div(logits_flat, tf.fill([num_classes], temperature)))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[hparams.batch_size, -1, num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_267": {
                "name": {
                    "value": "inputs",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [hparams.batch_size, None, input_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_268": {
                "name": {
                    "value": "temperature",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [])",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_269": {
                "name": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(softmax_flat, [hparams.batch_size, -1, num_classes])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "flatten_271": {
                "structure": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell.zero_state(hparams.batch_size, tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_273": {
                "structure": {
                    "value": "final_state",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "squeeze_122": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [hparams.batch_size, None, input_size])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_193": {
                "input_tensor": {
                    "value": "correct_predictions * event_positions",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_194": {
                "input_tensor": {
                    "value": "event_positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.not_equal(labels_flat, no_event_label))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_196": {
                "input_tensor": {
                    "value": "correct_predictions * no_event_positions",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_197": {
                "input_tensor": {
                    "value": "no_event_positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(labels_flat, no_event_label))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_199": {
                "input_tensor": {
                    "value": "softmax_cross_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels_flat, logits=logits_flat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "softmax_260": {
                "variable": {
                    "value": "sm",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tf.div(logits_flat[:, logits_offsets[i]:logits_offsets[i + 1]], tf.fill([num_classes[i]], temperature))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_264": {
                "variable": {
                    "value": "sm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tf.div(logits_flat[:, logits_offsets[i]:logits_offsets[i + 1]], tf.fill([num_classes[i]], temperature)))",
                            "Call"
                        ],
                        [
                            "tf.reshape(sm, [hparams.batch_size, -1, num_classes[i]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[hparams.batch_size, -1, num_classes[i]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_to_collection_272": {
                "name": {
                    "value": "initial_state",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(initial_state)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(final_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_274": {
                "name": {
                    "value": "final_state",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(initial_state)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(final_state)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_163": {
                "labels": {
                    "value": "labels_flat[:, i]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits_flat[:, logits_offsets[i]:logits_offsets[i + 1]]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf_slim.layers.linear(outputs_flat, num_logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_168": {
                "input": {
                    "value": "logits_flat[:, logits_offsets[i]:logits_offsets[i + 1]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_237": {
                "name": {
                    "value": "eval_ops",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "updates_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "update_ops.values()",
                            "Call"
                        ]
                    ]
                }
            },
            "div_253": {
                "x": {
                    "value": "logits_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_slim.layers.linear(outputs_flat, num_logits)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.fill([num_classes], temperature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_220": {
                "a": {
                    "value": "softmax_cross_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels_flat, logits=logits_flat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "accuracy_222": {
                "labels": {
                    "value": "labels_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits_flat, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack(predictions, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_per_class_accuracy_224": {
                "labels": {
                    "value": "labels_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "magenta.common.flatten_maybe_padded_sequences(labels, lengths)",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "predictions_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits_flat, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.stack(predictions, 1)",
                            "Call"
                        ]
                    ]
                },
                "num_classes": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_decoder.num_classes",
                            "Attribute"
                        ]
                    ]
                }
            },
            "recall_228": {
                "labels": {
                    "value": "event_positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.not_equal(labels_flat, no_event_label))",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "correct_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(labels_flat, predictions_flat))",
                            "Call"
                        ]
                    ]
                }
            },
            "recall_230": {
                "labels": {
                    "value": "no_event_positions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(labels_flat, no_event_label))",
                            "Call"
                        ]
                    ]
                },
                "predictions": {
                    "value": "correct_predictions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(tf.equal(labels_flat, predictions_flat))",
                            "Call"
                        ]
                    ]
                }
            },
            "mean_232": {
                "a": {
                    "value": "tf.reduce_sum(softmax_cross_entropy) / num_steps",
                    "type": "BinOp",
                    "possible_values": []
                },
                "weights": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.py_func(batch_labels_to_num_steps, [labels, lengths], tf.float32)",
                            "Call"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "num_steps + encoder_decoder.labels_to_num_steps(labels[:length])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "fill_253": {
                "dims": {
                    "value": "[num_classes]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [])",
                            "Call"
                        ]
                    ]
                }
            },
            "div_261": {
                "x": {
                    "value": "logits_flat[:, logits_offsets[i]:logits_offsets[i + 1]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill([num_classes[i]], temperature)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "fill_263": {
                "dims": {
                    "value": "[num_classes[i]]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_233": {
                "input_tensor": {
                    "value": "softmax_cross_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels_flat, logits=logits_flat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/shared/events_rnn_graph_test.py": {
        "tensorflow": {
            "disable_v2_behavior_26": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_53": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_59": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_64": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/shared/events_rnn_model.py": {
        "tensorflow": {
            "info_380": {
                "msg": {
                    "value": "Beam search yields sequence with log-likelihood: %f ",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "loglik",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(len(event_sequences))",
                            "Call"
                        ],
                        [
                            "self._config.encoder_decoder.evaluate_log_likelihood(event_sequences, softmax[:, :-1, :])",
                            "Call"
                        ],
                        [
                            "np.zeros(len(event_sequences))",
                            "Call"
                        ],
                        [
                            "self._config.encoder_decoder.evaluate_log_likelihood(event_sequences, softmaxes)",
                            "Call"
                        ],
                        [
                            "np.empty(len(event_sequences))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/shared/events_rnn_train.py": {
        "tensorflow": {
            "get_or_create_global_step_140": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_144": {
                "variable": {
                    "value": "eval_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "eval_ops",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Graph_52": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_or_create_global_step_56": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Graph_137": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_53": {
                "device_name": {
                    "value": "tf.train.replica_device_setter(num_ps_tasks)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Scaffold_97": {
                "variable": {
                    "value": "scaffold",
                    "type": "variable",
                    "possible_values": []
                },
                "init_fn": {
                    "value": "init_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "lambda scaffold, sess: sess.run(init_op, init_feed_dict)",
                            "Lambda"
                        ]
                    ]
                },
                "saver": {
                    "value": "tf.train.Saver(max_to_keep=checkpoints_to_keep, keep_checkpoint_every_n_hours=keep_checkpoint_every_n_hours)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_141": {
                "key": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_142": {
                "key": {
                    "value": "metrics/perplexity",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_143": {
                "key": {
                    "value": "metrics/accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "replica_device_setter_53": {
                "ps_tasks": {
                    "value": "num_ps_tasks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_collection_57": {
                "key": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_58": {
                "key": {
                    "value": "metrics/perplexity",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_59": {
                "key": {
                    "value": "metrics/accuracy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_60": {
                "key": {
                    "value": "train_op",
                    "type": "str",
                    "possible_values": []
                }
            },
            "NanTensorHook_69": {
                "loss_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection('loss')[0]",
                            "Subscript"
                        ],
                        [
                            "tf.get_collection('loss')[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "LoggingTensorHook_70": {
                "tensors": {
                    "value": "logging_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'Global Step': global_step, 'Loss': loss, 'Perplexity': perplexity, 'Accuracy': accuracy}",
                            "Dict"
                        ],
                        [
                            "{'Global Step': global_step, 'Loss': loss, 'Perplexity': perplexity, 'Accuracy': accuracy}",
                            "Dict"
                        ]
                    ]
                },
                "every_n_iter": {
                    "value": "summary_frequency",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "StepCounterHook_72": {
                "output_dir": {
                    "value": "train_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "every_n_steps": {
                    "value": "summary_frequency",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_103": {
                "msg": {
                    "value": "Starting training loop...",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_113": {
                "msg": {
                    "value": "Training complete.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "StopAtStepHook_76": {
                "num_steps": {
                    "value": "num_training_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Saver_99": {
                "max_to_keep": {
                    "value": "checkpoints_to_keep",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_checkpoint_every_n_hours": {
                    "value": "keep_checkpoint_every_n_hours",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/shared/model.py": {
        "tensorflow": {
            "Saver_54": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_55": {
                "variable": {
                    "value": "self._session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_68": {
                "variable": {
                    "value": "self._session",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "import_meta_graph_69": {
                "variable": {
                    "value": "new_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "meta_graph_or_file": {
                    "value": "metagraph_filename",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Saver_79": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "sharded": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "write_version": {
                    "value": "tf.train.SaverDef.V1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Graph_52": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_56": {
                "msg": {
                    "value": "Checkpoint used: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Graph_67": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/shared/sequence_generator.py": {
        "tensorflow": {
            "Exists_36": {
                "filename": {
                    "value": "checkpoint_file_or_prefix",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Exists_37": {
                "filename": {
                    "value": "checkpoint_file_or_prefix + '.index'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "IsDirectory_129": {
                "dirname": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._checkpoint",
                            "Attribute"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_130": {
                "variable": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._checkpoint",
                            "Attribute"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_217": {
                "msg": {
                    "value": "Writing bundle file with no generator description.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warn_219": {
                "msg": {
                    "value": "Writing bundle file with no bundle description.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "IsDirectory_135": {
                "dirname": {
                    "value": "checkpoint_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._checkpoint",
                            "Attribute"
                        ],
                        [
                            "tf.train.latest_checkpoint(checkpoint_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "DeleteRecursively_251": {
                "dirname": {
                    "value": "tempdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tempfile.mkdtemp()",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tempfile.mkdtemp()",
                            "Call"
                        ]
                    ]
                }
            },
            "DeleteRecursively_159": {
                "dirname": {
                    "value": "tempdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tempfile.mkdtemp()",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tempfile.mkdtemp()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/shared/sequence_generator_bundle.py": {
        "tensorflow": {}
    },
    "magenta/models/shared/sequence_generator_test.py": {
        "tensorflow": {
            "disable_v2_behavior_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_98": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/sketch_rnn/model.py": {
        "tensorflow": {
            "bidirectional_dynamic_rnn_89": {
                "variable": {
                    "value": "(unused_outputs, last_states)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "self.enc_cell_fw",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cell_bw": {
                    "value": "self.enc_cell_bw",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "batch",
                    "type": "variable",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "ENC_RNN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_102": {
                "variable": {
                    "value": "last_h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[last_h_fw, last_h_bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_187": {
                "variable": {
                    "value": "self.sequence_lengths",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.hps.batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_189": {
                "variable": {
                    "value": "self.input_data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.hps.batch_size, self.hps.max_seq_len + 1, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dynamic_rnn_243": {
                "variable": {
                    "value": "(output, last_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell_fn(hps.dec_rnn_size, use_recurrent_dropout=use_recurrent_dropout, dropout_keep_prob=self.hps.recurrent_dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, input_keep_prob=self.hps.input_dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=self.hps.output_dropout_prob)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "actual_input_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([self.input_x, overlay_x], 2)",
                            "Call"
                        ],
                        [
                            "self.input_x",
                            "Attribute"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "self.initial_state",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "RNN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_252": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(output, [-1, hps.dec_rnn_size])",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(output, output_w, output_b)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, hps.dec_rnn_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "xw_plus_b_253": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(output, [-1, hps.dec_rnn_size])",
                            "Call"
                        ],
                        [
                            "tf.nn.xw_plus_b(output, output_w, output_b)",
                            "Call"
                        ]
                    ]
                },
                "weights": {
                    "value": "output_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_w', [self.hps.dec_rnn_size, n_out])",
                            "Call"
                        ]
                    ]
                },
                "biases": {
                    "value": "output_b",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('output_b', [n_out])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_337": {
                "variable": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.output_x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 5]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_338": {
                "variable": {
                    "value": "[x1_data, x2_data, eos_data, eoc_data, cont_data]",
                    "type": "List",
                    "possible_values": []
                },
                "value": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.output_x, [-1, 5])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_339": {
                "variable": {
                    "value": "pen_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[eos_data, eoc_data, cont_data]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_344": {
                "variable": {
                    "value": "self.r_cost",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "lossfunc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_lossfunc(o_pi, o_mu1, o_mu2, o_sigma1, o_sigma2, o_corr, o_pen_logits, x1_data, x2_data, pen_data)",
                            "Call"
                        ]
                    ]
                }
            },
            "Variable_122": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_172": {
                "msg": {
                    "value": "Input dropout mode = %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "use_input_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.hps.use_input_dropout",
                            "Attribute"
                        ]
                    ]
                }
            },
            "info_173": {
                "msg": {
                    "value": "Output dropout mode = %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "use_output_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.hps.use_output_dropout",
                            "Attribute"
                        ]
                    ]
                }
            },
            "info_174": {
                "msg": {
                    "value": "Recurrent dropout mode = %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "use_recurrent_dropout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.hps.use_recurrent_dropout",
                            "Attribute"
                        ]
                    ]
                }
            },
            "DropoutWrapper_178": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell_fn(hps.dec_rnn_size, use_recurrent_dropout=use_recurrent_dropout, dropout_keep_prob=self.hps.recurrent_dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, input_keep_prob=self.hps.input_dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=self.hps.output_dropout_prob)",
                            "Call"
                        ]
                    ]
                },
                "input_keep_prob": {
                    "value": "self.hps.input_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "DropoutWrapper_183": {
                "variable": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell_fn(hps.dec_rnn_size, use_recurrent_dropout=use_recurrent_dropout, dropout_keep_prob=self.hps.recurrent_dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, input_keep_prob=self.hps.input_dropout_prob)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.DropoutWrapper(cell, output_keep_prob=self.hps.output_dropout_prob)",
                            "Call"
                        ]
                    ]
                },
                "output_keep_prob": {
                    "value": "self.hps.output_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_203": {
                "variable": {
                    "value": "self.sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.presig / 2.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_210": {
                "variable": {
                    "value": "self.kl_cost",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.kl_cost",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.hps.kl_tolerance",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "pre_tile_y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.batch_z",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.hps.batch_size, 1, self.hps.z_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_213": {
                "variable": {
                    "value": "overlay_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pre_tile_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.batch_z, [self.hps.batch_size, 1, self.hps.z_size])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, self.hps.max_seq_len, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_214": {
                "variable": {
                    "value": "actual_input_x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.input_x, overlay_x]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_215": {
                "variable": {
                    "value": "self.initial_state",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "rnn.super_linear(self.batch_z, cell.state_size, init_w='gaussian', weight_start=0.001, input_size=self.hps.z_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_223": {
                "variable": {
                    "value": "self.batch_z",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.hps.batch_size, self.hps.z_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_225": {
                "variable": {
                    "value": "self.kl_cost",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_239": {
                "variable": {
                    "value": "output_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.hps.dec_rnn_size, n_out]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_240": {
                "variable": {
                    "value": "output_b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "output_b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_out]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "subtract_259": {
                "variable": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "mu1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "subtract_260": {
                "variable": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "mu2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "multiply_261": {
                "variable": {
                    "value": "s1s2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "s1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "s1 * (temp * temp)",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "s2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "s2 * (temp * temp)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exp_266": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.div(-z, 2 * neg_rho)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "div_268": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(tf.div(-z, 2 * neg_rho))",
                            "Call"
                        ],
                        [
                            "tf.div(result, denom)",
                            "Call"
                        ],
                        [
                            "result1 + result2",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "denom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2 * np.pi * tf.multiply(s1s2, tf.sqrt(neg_rho))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_281": {
                "variable": {
                    "value": "result1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "result0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf_2d_normal(x1_data, x2_data, z_mu1, z_mu2, z_sigma1, z_sigma2, z_corr)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "z_pi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(z_pi)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_282": {
                "variable": {
                    "value": "result1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "result1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(result0, z_pi)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(result1, 1, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "-tf.log(result1 + epsilon)",
                            "UnaryOp"
                        ],
                        [
                            "tf.multiply(result1, fs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_286": {
                "variable": {
                    "value": "fs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - pen_data[:, 2]",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(fs, [-1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_288": {
                "variable": {
                    "value": "result1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "result1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(result0, z_pi)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(result1, 1, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "-tf.log(result1 + epsilon)",
                            "UnaryOp"
                        ],
                        [
                            "tf.multiply(result1, fs)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "fs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - pen_data[:, 2]",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(fs, [-1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_291": {
                "variable": {
                    "value": "result2",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "pen_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([eos_data, eoc_data, cont_data], 1)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "z_pen_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z[:, 0:3]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_293": {
                "variable": {
                    "value": "result2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "result2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=pen_data, logits=z_pen_logits)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result2, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.multiply(result2, fs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_307": {
                "variable": {
                    "value": "(z_pi, z_mu1, z_mu2, z_sigma1, z_sigma2, z_corr)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "z[:, 3:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "6",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_312": {
                "variable": {
                    "value": "z_pi",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "z_pi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(z_pi)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_313": {
                "variable": {
                    "value": "z_pen",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "z_pen_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z[:, 0:3]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "exp_316": {
                "variable": {
                    "value": "z_sigma1",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "z_sigma1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(z_sigma1)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_317": {
                "variable": {
                    "value": "z_sigma2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "z_sigma2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(z_sigma2)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_318": {
                "variable": {
                    "value": "z_corr",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "z_corr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(z_corr)",
                            "Call"
                        ]
                    ]
                }
            },
            "Variable_347": {
                "variable": {
                    "value": "self.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.hps.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "AdamOptimizer_348": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_350": {
                "variable": {
                    "value": "self.kl_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.hps.kl_weight_start",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_381": {
                "msg": {
                    "value": "Error with sampling ensemble.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_78": {
                "name_or_scope": {
                    "value": "vector_rnn",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_176": {
                "msg": {
                    "value": "Dropout to input w/ keep_prob = %4.4f.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.hps.input_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_181": {
                "msg": {
                    "value": "Dropout to output w/ keep_prob = %4.4f.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.hps.output_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_238": {
                "name_or_scope": {
                    "value": "RNN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_295": {
                "variable": {
                    "value": "result2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "result2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=pen_data, logits=z_pen_logits)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result2, [-1, 1])",
                            "Call"
                        ],
                        [
                            "tf.multiply(result2, fs)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "fs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - pen_data[:, 2]",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(fs, [-1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "info_84": {
                "msg": {
                    "value": "Model using gpu.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "multiply_206": {
                "x": {
                    "value": "self.sigma",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_normal((self.hps.batch_size, self.hps.z_size), 0.0, 1.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_208": {
                "input_tensor": {
                    "value": "1 + self.presig - tf.square(self.mean) - tf.exp(self.presig)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_265": {
                "x": {
                    "value": "rho",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "div_266": {
                "x": {
                    "value": "-z",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2 * neg_rho",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "multiply_267": {
                "x": {
                    "value": "s1s2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(s1, s2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.sqrt(neg_rho)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_283": {
                "x": {
                    "value": "result1 + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_80": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_81": {
                "msg": {
                    "value": "Model using cpu.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_263": {
                "x": {
                    "value": "tf.div(norm2, s2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "div_264": {
                "x": {
                    "value": "tf.multiply(rho, tf.multiply(norm1, norm2))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "s1s2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(s1, s2)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_267": {
                "x": {
                    "value": "neg_rho",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.square(rho)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "clip_by_value_355": {
                "t": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-g",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.hps.grad_clip",
                            "Attribute"
                        ]
                    ]
                }
            },
            "exp_209": {
                "x": {
                    "value": "self.presig",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "div_263": {
                "x": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(x2, mu2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "s2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "s2 * (temp * temp)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_264": {
                "x": {
                    "value": "norm1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(x1, mu1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "norm2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.subtract(x2, mu2)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_209": {
                "x": {
                    "value": "self.mean",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/sketch_rnn/rnn.py": {
        "tensorflow": {
            "reshape_131": {
                "variable": {
                    "value": "h_reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(h_reshape, [batch_size, base * num_units])",
                            "Call"
                        ],
                        [
                            "total_h[:, 0:self.num_units]",
                            "Subscript"
                        ],
                        [
                            "total_h[:, 0:self.num_units]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, base, num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_132": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "h_reshape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(h, [batch_size, base, num_units])",
                            "Call"
                        ],
                        [
                            "(h_reshape - mean) * rstd",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_133": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(h_reshape - mean)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "constant_134": {
                "variable": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(epsilon)",
                            "Call"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "rsqrt_135": {
                "variable": {
                    "value": "rstd",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_138": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h_reshape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(h, [batch_size, base, num_units])",
                            "Call"
                        ],
                        [
                            "(h_reshape - mean) * rstd",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, base * num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_162": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1]",
                            "List"
                        ],
                        [
                            "[1]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_164": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(x_shifted)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1]",
                            "List"
                        ],
                        [
                            "[1]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "rsqrt_165": {
                "variable": {
                    "value": "inv_std",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "var + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_183": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1]",
                            "List"
                        ],
                        [
                            "[1]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_184": {
                "variable": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(tf.square(x - mean), axes, keep_dims=True) + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_80": {
                "variable": {
                    "value": "(unused_c, h)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_142": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ln_gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4 * num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(gamma_start)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_169": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ln_gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(gamma_start)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_219": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "super_linear_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x_size, output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.constant_initializer(0.0)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(weight_start)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_start)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "split_268": {
                "variable": {
                    "value": "(h, unused_c)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_373": {
                "variable": {
                    "value": "(total_h, unused_total_c)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_33": {
                "value": {
                    "value": "orthogonal(shape) * scale",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_49": {
                "value": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(shape)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.float32",
                            "Method Argument"
                        ],
                        [
                            "tf.float32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "split_85": {
                "variable": {
                    "value": "(c, h)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_94": {
                "variable": {
                    "value": "w_xh",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_xh",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x_size, 4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.constant_initializer(0.0)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(weight_start)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_start)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "get_variable_96": {
                "variable": {
                    "value": "w_hh",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_hh",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_units, 4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "h_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_98": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_102": {
                "variable": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_103": {
                "variable": {
                    "value": "w_full",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[w_xh, w_hh]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_106": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(concat, w_full) + bias",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_133": {
                "x": {
                    "value": "h_reshape - mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_139": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'hyper'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_146": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ln_beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4 * num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_164": {
                "x": {
                    "value": "x_shifted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x - mean",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_166": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'hyper'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_173": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "ln_beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_201": {
                "name_or_scope": {
                    "value": "scope or 'linear'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "constant_initializer_211": {
                "variable": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "get_variable_222": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "super_linear_b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(bias_start)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_227": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('super_linear_w', [x_size, output_size], tf.float32, initializer=w_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_273": {
                "variable": {
                    "value": "(h, c)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_283": {
                "variable": {
                    "value": "w_xh",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_xh",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x_size, 4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.constant_initializer(0.0)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(weight_start)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_start)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "get_variable_285": {
                "variable": {
                    "value": "w_hh",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_hh",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_units, 4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "h_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_288": {
                "variable": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_289": {
                "variable": {
                    "value": "w_full",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[w_xh, w_hh]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_290": {
                "variable": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(concat, w_full)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, h_size, 'ln_all')",
                            "Call"
                        ],
                        [
                            "tf.concat([i, j, f, o], 1)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, self.num_units, 'ln_all')",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_full",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([w_xh, w_hh], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([w_xh, w_hh], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_294": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(concat, w_full)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, h_size, 'ln_all')",
                            "Call"
                        ],
                        [
                            "tf.concat([i, j, f, o], 1)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, self.num_units, 'ln_all')",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multiply_398": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "super_linear(zw, num_units, init_w='constant', weight_start=init_gamma / embedding_size, use_bias=False, scope='alpha')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "split_420": {
                "variable": {
                    "value": "(total_h, total_c)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_423": {
                "variable": {
                    "value": "self.hyper_state",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "[total_h[:, self.num_units:], total_c[:, self.num_units:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_434": {
                "variable": {
                    "value": "w_xh",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_xh",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[x_size, 4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.constant_initializer(0.0)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(weight_start)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=weight_start)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                }
            },
            "get_variable_436": {
                "variable": {
                    "value": "w_hh",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_hh",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_units, 4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "h_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ],
                        [
                            "lstm_ortho_initializer(1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_438": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4 * self.num_units]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_443": {
                "variable": {
                    "value": "hyper_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_449": {
                "variable": {
                    "value": "xh",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w_xh",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W_xh', [x_size, 4 * self.num_units], initializer=w_init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('W_xh', [x_size, 4 * self.num_units], initializer=w_init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('W_xh', [x_size, 4 * self.num_units], initializer=w_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_450": {
                "variable": {
                    "value": "hh",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(h_reshape, [batch_size, base * num_units])",
                            "Call"
                        ],
                        [
                            "total_h[:, 0:self.num_units]",
                            "Subscript"
                        ],
                        [
                            "total_h[:, 0:self.num_units]",
                            "Subscript"
                        ]
                    ]
                },
                "b": {
                    "value": "w_hh",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W_hh', [self.num_units, 4 * self.num_units], initializer=h_init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('W_hh', [self.num_units, 4 * self.num_units], initializer=h_init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('W_hh', [self.num_units, 4 * self.num_units], initializer=h_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_453": {
                "variable": {
                    "value": "(ix, jx, fx, ox)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "xh",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(x, w_xh)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_460": {
                "variable": {
                    "value": "(ih, jh, fh, oh)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hh",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(h, w_hh)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_467": {
                "variable": {
                    "value": "(ib, jb, fb, ob)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('bias', [4 * self.num_units], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('bias', [4 * self.num_units], initializer=tf.constant_initializer(0.0))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_488": {
                "variable": {
                    "value": "(hyper_h, hyper_c)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hyper_new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_489": {
                "variable": {
                    "value": "new_total_h",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_h, hyper_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_490": {
                "variable": {
                    "value": "new_total_c",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_c, hyper_c]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_491": {
                "variable": {
                    "value": "new_total_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[new_total_h, new_total_c]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_84": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "dropout_109": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tanh(j)",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_111": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "jx + jh + jb",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_scope_141": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_168": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_185": {
                "input_tensor": {
                    "value": "tf.square(x - mean)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1]",
                            "List"
                        ],
                        [
                            "[1]",
                            "List"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_scope_203": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_213": {
                "variable": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "weight_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_272": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "dropout_297": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tanh(j)",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_299": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "jx + jh + jb",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_304": {
                "values": {
                    "value": "[new_h, new_c]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_382": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "'hyper'",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_419": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "concat_476": {
                "variable": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[i, j, f, o]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_478": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(concat, w_full)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, h_size, 'ln_all')",
                            "Call"
                        ],
                        [
                            "tf.concat([i, j, f, o], 1)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, self.num_units, 'ln_all')",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_481": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tanh(j)",
                    "type": "Call",
                    "possible_values": []
                },
                "rate": {
                    "value": "self.dropout_keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_483": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "jx + jh + jb",
                            "BinOp"
                        ]
                    ]
                }
            },
            "matmul_104": {
                "a": {
                    "value": "concat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x, h], 1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(concat, w_full)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, h_size, 'ln_all')",
                            "Call"
                        ],
                        [
                            "tf.concat([i, j, f, o], 1)",
                            "Call"
                        ],
                        [
                            "layer_norm_all(concat, batch_size, 4, self.num_units, 'ln_all')",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w_full",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([w_xh, w_hh], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([w_xh, w_hh], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_114": {
                "x": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "c * tf.sigmoid(f + self.forget_bias) + tf.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * tf.sigmoid(f + self.forget_bias) + tf.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * tf.sigmoid(f + self.forget_bias) + tf.sigmoid(i) * g",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_114": {
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ox + oh + ob",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_116": {
                "values": {
                    "value": "[new_c, new_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_144": {
                "value": {
                    "value": "gamma_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_171": {
                "value": {
                    "value": "gamma_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_185": {
                "x": {
                    "value": "x - mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_215": {
                "variable": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "weight_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_226": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('super_linear_w', [x_size, output_size], tf.float32, initializer=w_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_302": {
                "x": {
                    "value": "layer_norm(new_c, h_size, 'ln_c')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_302": {
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ox + oh + ob",
                            "BinOp"
                        ]
                    ]
                }
            },
            "tanh_486": {
                "x": {
                    "value": "layer_norm(new_c, self.num_units, 'ln_c')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_486": {
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ox + oh + ob",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_100": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "tanh_109": {
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "jx + jh + jb",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_113": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ix + ih + ib",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_147": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_174": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_initializer_225": {
                "value": {
                    "value": "bias_start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tanh_297": {
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "jx + jh + jb",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_301": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ix + ih + ib",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_440": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "tanh_481": {
                "x": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": [
                        [
                            "jx + jh + jb",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_485": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ix + ih + ib",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/sketch_rnn/sketch_rnn_train.py": {
        "tensorflow": {
            "set_verbosity_30": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "DEFINE_string_34": {
                "name": {
                    "value": "data_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "https://github.com/hardmaru/sketch-rnn-datasets/raw/master/aaron_sheep",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory in which to find the dataset specified in model hparams. If data_dir starts with \"http://\" or \"https://\", the file will be fetched remotely.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_40": {
                "name": {
                    "value": "log_root",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/sketch_rnn/models/default",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory to store model checkpoints, tensorboard.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_46": {
                "name": {
                    "value": "hparams",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "\"Pass in comma-separated key=value pairs such as 'save_every=40,decay_rate=0.99' (no whitespace) to be read into the HParams object defined in model.py\"",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_default_session_58": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_232": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_233": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_save_path, 'vector')",
                            "Call"
                        ]
                    ]
                }
            },
            "Saver_239": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_249": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "FLAGS.log_root",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_252": {
                "variable": {
                    "value": "t_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_259": {
                "variable": {
                    "value": "model_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "InteractiveSession_441": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MakeDirs_93": {
                "dirname": {
                    "value": "models_root_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/tmp/sketch_rnn/models'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_103": {
                "msg": {
                    "value": "Unzipping %s...",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "zip_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(models_root_dir, os.path.basename(pretrained_models_url))",
                            "Call"
                        ]
                    ]
                }
            },
            "info_106": {
                "msg": {
                    "value": "Unzipping complete.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_150": {
                "msg": {
                    "value": "'Dataset combined: {} ({}/{}/{}), avg len {}'.format(len(all_strokes), len(train_strokes), len(valid_strokes), len(test_strokes), int(avg_len))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_159": {
                "msg": {
                    "value": "model_params.max_seq_len %i.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "model_params.max_seq_len",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_202": {
                "msg": {
                    "value": "normalizing_scale_factor %4.4f.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "normalizing_scale_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "train_set.calculate_normalizing_scale_factor()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_234": {
                "msg": {
                    "value": "Loading model %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "ckpt.model_checkpoint_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "info_241": {
                "msg": {
                    "value": "saving model %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_save_path, 'vector')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_242": {
                "msg": {
                    "value": "global_step %i.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_258": {
                "msg": {
                    "value": "Total trainable variables %i.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "count_t_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "count_t_vars + num_param",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_426": {
                "msg": {
                    "value": "sketch-rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_427": {
                "msg": {
                    "value": "Hyperparams:",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_428": {
                "msg": {
                    "value": "Loading data files.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_448": {
                "dirname": {
                    "value": "FLAGS.log_root",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_465": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_466": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_97": {
                "msg": {
                    "value": "%s already exists, using cached copy",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "zip_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(models_root_dir, os.path.basename(pretrained_models_url))",
                            "Call"
                        ]
                    ]
                }
            },
            "info_99": {
                "msg": {
                    "value": "Downloading pretrained models from %s...",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "pretrained_models_url",
                    "type": "variable",
                    "possible_values": [
                        [
                            "PRETRAINED_MODELS_URL",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "info_102": {
                "msg": {
                    "value": "Download complete.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_133": {
                "msg": {
                    "value": "'Loaded {}/{}/{} from {}'.format(len(data['train']), len(data['valid']), len(data['test']), dataset)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_232": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_239": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_257": {
                "msg": {
                    "value": "%s %s %i",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "var.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "str(var.get_shape())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Summary_301": {
                "variable": {
                    "value": "cost_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_303": {
                "variable": {
                    "value": "reconstr_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_306": {
                "variable": {
                    "value": "kl_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_308": {
                "variable": {
                    "value": "lr_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_311": {
                "variable": {
                    "value": "kl_weight_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_314": {
                "variable": {
                    "value": "time_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_344": {
                "variable": {
                    "value": "valid_cost_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_347": {
                "variable": {
                    "value": "valid_reconstr_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_350": {
                "variable": {
                    "value": "valid_kl_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_353": {
                "variable": {
                    "value": "valid_time_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_442": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_127": {
                "msg": {
                    "value": "Downloading %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "data_filepath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/'.join([data_dir, dataset])",
                            "Call"
                        ],
                        [
                            "os.path.join(data_dir, dataset)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_324": {
                "msg": {
                    "value": "output_log",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_format % output_values",
                            "BinOp"
                        ],
                        [
                            "output_format % output_values",
                            "BinOp"
                        ],
                        [
                            "output_format % output_values",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_363": {
                "msg": {
                    "value": "output_log",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_format % output_values",
                            "BinOp"
                        ],
                        [
                            "output_format % output_values",
                            "BinOp"
                        ],
                        [
                            "output_format % output_values",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Summary_382": {
                "variable": {
                    "value": "best_valid_cost_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_396": {
                "variable": {
                    "value": "eval_cost_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_398": {
                "variable": {
                    "value": "eval_reconstr_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_401": {
                "variable": {
                    "value": "eval_kl_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_404": {
                "variable": {
                    "value": "eval_time_summ",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_380": {
                "msg": {
                    "value": "time_taken_save %4.4f.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "time_taken_save",
                    "type": "variable",
                    "possible_values": [
                        [
                            "end - start",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_413": {
                "msg": {
                    "value": "output_log",
                    "type": "variable",
                    "possible_values": [
                        [
                            "output_format % output_values",
                            "BinOp"
                        ],
                        [
                            "output_format % output_values",
                            "BinOp"
                        ],
                        [
                            "output_format % output_values",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/svg_vae/datagen_beam.py": {
        "tensorflow": {
            "disable_v2_behavior_25": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/svg_vae/glyphazzn.py": {
        "tensorflow": {
            "reshape_205": {
                "variable": {
                    "value": "example[targets_cls]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "example['targets_cls']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_206": {
                "variable": {
                    "value": "example[targets_sln]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "example['targets_sln']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_208": {
                "variable": {
                    "value": "example[targets_rel]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "example['targets_rel']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[51, 1, 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Glob_155": {
                "filename": {
                    "value": "RAW_DATA_FILES",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/path/to/glyphazzn-internal-train*'",
                            "str"
                        ]
                    ]
                }
            },
            "identity_223": {
                "variable": {
                    "value": "example[inputs]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "example['targets_rel']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "identity_224": {
                "variable": {
                    "value": "example[targets]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "example['targets_rel']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "info_128": {
                "msg": {
                    "value": "'Loading binary_fp: train/test from {}'.format(URL_SPLITS)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_131": {
                "value": {
                    "value": "\\n",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_136": {
                "filename": {
                    "value": "data_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "MakeDirs_137": {
                "dirname": {
                    "value": "data_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Exists_139": {
                "filename": {
                    "value": "os.path.join(data_dir, 'mean.npz')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tf_record_iterator_141": {
                "path": {
                    "value": "RAW_STAT_FILE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/path/to/glyphazzn-internal-stats-00000-of-00001'",
                            "str"
                        ]
                    ]
                }
            },
            "Example_142": {
                "variable": {
                    "value": "stats",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "tf_record_iterator_156": {
                "path": {
                    "value": "raw_data_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gfile.Glob(RAW_DATA_FILES)",
                            "Call"
                        ]
                    ]
                }
            },
            "Example_157": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FixedLenFeature_187": {
                "shape": {
                    "value": "[51 * 10]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_188": {
                "shape": {
                    "value": "[64 * 64]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_189": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FixedLenFeature_190": {
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_214": {
                "tensor": {
                    "value": "example['targets_rnd']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 64 * 64]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/svg_vae/image_vae.py": {
        "tensorflow": {
            "log_36": {
                "x": {
                    "value": "tf.math.expm1(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_66": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "features['targets']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 64, 64, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pow_68": {
                "variable": {
                    "value": "loss_num",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits - targets",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_74": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, 64, 64, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 64, 64, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_75": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(features['targets'], [-1, 64, 64, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(targets, [-1, 64, 64, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 64, 64, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expm1_36": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_82": {
                "variable": {
                    "value": "enc_out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "enc_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.visual_encoder(inputs, clss, hparams, train)",
                            "Call"
                        ],
                        [
                            "tf.reshape(enc_out, [-1, 2 * hparams.bottleneck_bits])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2 * hparams.bottleneck_bits]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_107": {
                "variable": {
                    "value": "elbo",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-(b_loss + rec_loss)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_108": {
                "variable": {
                    "value": "losses[rec_loss]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "rec_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-dec_out.log_prob(inputs)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "reduce_mean_134": {
                "variable": {
                    "value": "kl_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.maximum(kl - free_bits, 0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_142": {
                "variable": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['cls']",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_148": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_153": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_158": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_163": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_169": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_175": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_178": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_179": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "2 * hparams.bottleneck_bits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "dense_187": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "reshape_188": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 4, 4, 64]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_189": {
                "variable": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features['cls']",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_195": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_201": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_206": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_211": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_216": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_221": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_226": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 1, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(2 * hparams.bottleneck_bits, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.flatten(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(ret, 2 * hparams.bottleneck_bits, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(bottleneck, 1024, activation=None)",
                            "Call"
                        ],
                        [
                            "tf.reshape(ret, [-1, 4, 4, 64])",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 4, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(2 * hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, 2, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2DTranspose(hparams.base_depth, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "ops.conditional_instance_norm(ret, clss, hparams.num_categories)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(ret)",
                            "Call"
                        ],
                        [
                            "tf.layers.Conv2D(1, 5, padding='SAME', activation=None)(ret)",
                            "Call"
                        ],
                        [
                            "tfd.Independent(tfd.Bernoulli(logits=ret), reinterpreted_batch_ndims=3, name='image')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_69": {
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "common_layers.weights_all(targets)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_79": {
                "name_or_scope": {
                    "value": "vae_internal",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_123": {
                "name_or_scope": {
                    "value": "bottleneck",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_140": {
                "name_or_scope": {
                    "value": "visual_encoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_185": {
                "name_or_scope": {
                    "value": "visual_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_86": {
                "input_tensor": {
                    "value": "b_loss",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_130": {
                "input_tensor": {
                    "value": "tf.exp(log_sigma) + tf.square(mu) - 1.0 - log_sigma",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "maximum_134": {
                "x": {
                    "value": "kl - free_bits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Conv2D_145": {
                "filters": {
                    "value": "hparams.base_depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2D_150": {
                "filters": {
                    "value": "hparams.base_depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2D_155": {
                "filters": {
                    "value": "2 * hparams.base_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2D_160": {
                "filters": {
                    "value": "2 * hparams.base_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2D_166": {
                "filters": {
                    "value": "2 * hparams.bottleneck_bits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2D_172": {
                "filters": {
                    "value": "2 * hparams.bottleneck_bits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_192": {
                "filters": {
                    "value": "2 * hparams.base_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_198": {
                "filters": {
                    "value": "2 * hparams.base_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_203": {
                "filters": {
                    "value": "2 * hparams.base_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_208": {
                "filters": {
                    "value": "2 * hparams.base_depth",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_213": {
                "filters": {
                    "value": "hparams.base_depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_218": {
                "filters": {
                    "value": "hparams.base_depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_223": {
                "filters": {
                    "value": "hparams.base_depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "Conv2D_228": {
                "filters": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "name_scope_114": {
                "name": {
                    "value": "train if train else test",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "image_115": {
                "name": {
                    "value": "rendered_out",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "dec_out.mean()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "image_116": {
                "name": {
                    "value": "rendered_og",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, 64, 64, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_129": {
                "x": {
                    "value": "log_sigma / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_131": {
                "x": {
                    "value": "log_sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[..., self.hparams.bottleneck_bits:]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "square_131": {
                "x": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[..., :self.hparams.bottleneck_bits]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/svg_vae/svg_decoder.py": {
        "tensorflow": {
            "reshape_148": {
                "variable": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "while_loop_226": {
                "variable": {
                    "value": "(logits, final_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "while_exit_cond",
                    "type": "variable",
                    "possible_values": []
                },
                "body": {
                    "value": "infer_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[logits_so_far, initial_state]",
                    "type": "List",
                    "possible_values": []
                },
                "shape_invariants": {
                    "value": "[tf.TensorShape([None, None, 1, hparams.hidden_size]), tuple(((s[0].get_shape(), s[1].get_shape()) for s in initial_state))]",
                    "type": "List",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_251": {
                "variable": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_267": {
                "variable": {
                    "value": "pre_tile_y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories), tf.one_hot(sln, max_decode_length)), -1)",
                            "Call"
                        ],
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories)), -1)",
                            "Call"
                        ],
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories), tf.one_hot(sln, 51)), -1)",
                            "Call"
                        ],
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories)), -1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[common_layers.shape_list(bottleneck)[0], 1, hparams.bottleneck_bits + hparams.num_categories + sln_offset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_271": {
                "variable": {
                    "value": "overlay_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pre_tile_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(bottleneck, [common_layers.shape_list(bottleneck)[0], 1, hparams.bottleneck_bits + hparams.num_categories + sln_offset])",
                            "Call"
                        ],
                        [
                            "tf.reshape(bottleneck, [common_layers.shape_list(bottleneck)[0], 1, hparams.bottleneck_bits + hparams.num_categories + sln_offset])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, common_layers.shape_list(inputs)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_272": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, overlay_x]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_306": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 0, 1, hdim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_307": {
                "variable": {
                    "value": "zero_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1, 1, dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "slice_310": {
                "variable": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "initial_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((batch_size, 0, 1, hdim), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.slice(initial_output, [0, 0, 0, 0], common_layers.shape_list(initial_output))",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "common_layers.shape_list(initial_output)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "slice_312": {
                "variable": {
                    "value": "zero_pad",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "zero_pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((batch_size, 1, 1, dim), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.slice(zero_pad, [0, 0, 0, 0], common_layers.shape_list(zero_pad))",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "common_layers.shape_list(zero_pad)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_56": {
                "variable": {
                    "value": "vae_features[inputs]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "vae_features['targets_psr'][:, -1, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 64, 64, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_60": {
                "variable": {
                    "value": "vae_features[bottleneck]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "(0, 128)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "stop_gradient_77": {
                "variable": {
                    "value": "sampled_bottleneck",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sampled_bottleneck",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.pretrained_visual_encoder(features, hparams)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(sampled_bottleneck)",
                            "Call"
                        ],
                        [
                            "features['bottleneck']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "expand_dims_129": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_150": {
                "variable": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_152": {
                "variable": {
                    "value": "sln",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_153": {
                "variable": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(bottleneck, tf.one_hot(clss, hparams.num_categories), tf.one_hot(sln, max_decode_length))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_157": {
                "variable": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(bottleneck, tf.one_hot(clss, hparams.num_categories))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_169": {
                "variable": {
                    "value": "reset_scope",
                    "type": "variable",
                    "possible_values": []
                },
                "name_or_scope": {
                    "value": "tf.VariableScope(tf.AUTO_REUSE, '')",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "auxiliary_name_scope": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_172": {
                "variable": {
                    "value": "top_scope",
                    "type": "variable",
                    "possible_values": []
                },
                "name_or_scope": {
                    "value": "'svg_decoder/{}_modality'.format(tm)",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_180": {
                "variable": {
                    "value": "samples_so_far",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[zero_pad, samples_so_far]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_189": {
                "variable": {
                    "value": "pre_tile_y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories), tf.one_hot(sln, max_decode_length)), -1)",
                            "Call"
                        ],
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories)), -1)",
                            "Call"
                        ],
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories), tf.one_hot(sln, 51)), -1)",
                            "Call"
                        ],
                        [
                            "tf.concat((bottleneck, tf.one_hot(clss, hparams.num_categories)), -1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[common_layers.shape_list(bottleneck)[0], 1, hparams.bottleneck_bits + hparams.num_categories + sln_offset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_193": {
                "variable": {
                    "value": "overlay_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pre_tile_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(bottleneck, [common_layers.shape_list(bottleneck)[0], 1, hparams.bottleneck_bits + hparams.num_categories + sln_offset])",
                            "Call"
                        ],
                        [
                            "tf.reshape(bottleneck, [common_layers.shape_list(bottleneck)[0], 1, hparams.bottleneck_bits + hparams.num_categories + sln_offset])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, common_layers.shape_list(shifted_targets)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_195": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[shifted_targets, overlay_x]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_197": {
                "variable": {
                    "value": "seq_len_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[common_layers.shape_list(inputs)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_210": {
                "variable": {
                    "value": "next_step",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "next_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(next_step, [1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_211": {
                "variable": {
                    "value": "logits_so_far",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits_so_far, next_step]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_253": {
                "variable": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_255": {
                "variable": {
                    "value": "sln",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_256": {
                "variable": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(bottleneck, tf.one_hot(clss, hparams.num_categories), tf.one_hot(sln, 51))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_260": {
                "variable": {
                    "value": "bottleneck",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(bottleneck, tf.one_hot(clss, hparams.num_categories))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dense_275": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([shifted_targets, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hparams.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "bottom",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tanh_276": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([shifted_targets, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_298": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(x, res_size, name='dense', activation='tanh')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "res_size",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "dense",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "tanh",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_50": {
                "name_or_scope": {
                    "value": "tf.VariableScope(tf.AUTO_REUSE, '')",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "auxiliary_name_scope": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "executing_eagerly_64": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_79": {
                "name_or_scope": {
                    "value": "render2cmd_v3_internal",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_201": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([shifted_targets, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "hparams.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "bottom",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tanh_202": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([shifted_targets, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "dynamic_rnn_206": {
                "variable": {
                    "value": "(next_step, next_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn.MultiRNNCell([self.lstm_cell(hparams, train) for _ in range(hparams.num_hidden_layers)])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell([self.lstm_cell(hparams, train) for _ in range(hparams.num_hidden_layers)])",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([shifted_targets, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "seq_len_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([common_layers.shape_list(inputs)[0]])",
                            "Call"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "current_hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tuple((rnn.LSTMStateTuple(c=s[0], h=s[1]) for s in current_hidden))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_274": {
                "name_or_scope": {
                    "value": "pre_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_278": {
                "name_or_scope": {
                    "value": "lstm_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dynamic_rnn_279": {
                "cell": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rnn.MultiRNNCell([self.lstm_cell(hparams, train) for _ in range(hparams.num_hidden_layers)])",
                            "Call"
                        ],
                        [
                            "rnn.MultiRNNCell([self.lstm_cell(hparams, train) for _ in range(hparams.num_hidden_layers)])",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([shifted_targets, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ],
                        [
                            "tf.concat([inputs, overlay_x], -1)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs, hparams.hidden_size, name='bottom')",
                            "Call"
                        ],
                        [
                            "tf.nn.tanh(inputs)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_state": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tuple(((s.c, s.h) for s in initial_state))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "time_major": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_297": {
                "name_or_scope": {
                    "value": "'unbottleneck{}'.format(name_append)",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.AUTO_REUSE",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "VariableScope_50": {
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "VariableScope_169": {
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_200": {
                "name_or_scope": {
                    "value": "pre_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_205": {
                "name_or_scope": {
                    "value": "lstm_decoder",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_284": {
                "x": {
                    "value": "train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._hparams.mode == tf_estimator.ModeKeys.TRAIN",
                            "Compare"
                        ]
                    ]
                }
            },
            "one_hot_154": {
                "indices": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "hparams.num_categories",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_155": {
                "indices": {
                    "value": "sln",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sequence_length, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(sequence_length, [-1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "max_decode_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "51",
                            "int"
                        ]
                    ]
                }
            },
            "one_hot_158": {
                "indices": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "hparams.num_categories",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_230": {
                "dims": {
                    "value": "[None, None, 1, hparams.hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_257": {
                "indices": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "hparams.num_categories",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_258": {
                "indices": {
                    "value": "sln",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sequence_length, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(sequence_length, [-1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "51",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_261": {
                "indices": {
                    "value": "clss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ],
                        [
                            "tf.reshape(clss, [-1])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(clss)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "hparams.num_categories",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/models/svg_vae/svg_decoder_loss.py": {
        "tensorflow": {
            "reduce_logsumexp_42": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logmix + _tf_lognormal(y, mean, logstd, logsqrttwopi)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_logsumexp(v, 1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(v, [-1, 51, 1, 6])",
                            "Call"
                        ],
                        [
                            "tf.multiply(v, batch_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_43": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logmix + _tf_lognormal(y, mean, logstd, logsqrttwopi)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_logsumexp(v, 1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(v, [-1, 51, 1, 6])",
                            "Call"
                        ],
                        [
                            "tf.multiply(v, batch_mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 51, 1, 6]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multiply_46": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logmix + _tf_lognormal(y, mean, logstd, logsqrttwopi)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_logsumexp(v, 1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(v, [-1, 51, 1, 6])",
                            "Call"
                        ],
                        [
                            "tf.multiply(v, batch_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "batch_mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "split_113": {
                "variable": {
                    "value": "(logmix, mean, logstd)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_65": {
                "variable": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "top_out[:, :, :, 4:]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(args, [-1, 3 * num_mix])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3 * num_mix]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_71": {
                "variable": {
                    "value": "masktemplate",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 0.0, 0.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_75": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "targets_commands_rel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets[..., :4]",
                            "Subscript"
                        ]
                    ]
                },
                "b": {
                    "value": "masktemplate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([[0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 1.0, 1.0], [0.0, 0.0, 0.0, 0.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0]])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[-1], [-2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_78": {
                "variable": {
                    "value": "targs_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "targets_args_rel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets[..., 4:]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_89": {
                "variable": {
                    "value": "softmax_xent_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "targets_commands_rel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "targets[..., :4]",
                            "Subscript"
                        ]
                    ]
                },
                "logits": {
                    "value": "commands",
                    "type": "variable",
                    "possible_values": [
                        [
                            "top_out[:, :, :, :4]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "dense_142": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "body_output",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "nout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4 + 6 * num_mix * 3",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "top",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_49": {
                "input_tensor": {
                    "value": "tf.reduce_sum(v, axis=3)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_60": {
                "name_or_scope": {
                    "value": "full_command_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_94": {
                "variable": {
                    "value": "softmax_xent_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "softmax_xent_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=targets_commands_rel, logits=commands)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(softmax_xent_loss, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(softmax_xent_loss)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_96": {
                "variable": {
                    "value": "softmax_xent_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "softmax_xent_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=targets_commands_rel, logits=commands)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(softmax_xent_loss, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(softmax_xent_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_109": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_114": {
                "input_tensor": {
                    "value": "logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logmix - tf.reduce_logsumexp(logmix, -1, keepdims=True)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_141": {
                "name_or_scope": {
                    "value": "real_top",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_150": {
                "variable": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "command - tf.reduce_max(command, axis=[-1], keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Categorical_156": {
                "variable": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": []
                },
                "probs": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(ret[:, :, :, :4]) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(command - tf.reduce_max(command, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "command / tf.reduce_sum(command, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=command).sample()",
                            "Call"
                        ],
                        [
                            "tf.one_hot(command, 4)",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_158": {
                "variable": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(ret[:, :, :, :4]) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(command - tf.reduce_max(command, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "command / tf.reduce_sum(command, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=command).sample()",
                            "Call"
                        ],
                        [
                            "tf.one_hot(command, 4)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_162": {
                "variable": {
                    "value": "arguments",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "arguments",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ret[:, :, :, 4:]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(arguments, [-1, 3 * num_mix])",
                            "Call"
                        ],
                        [
                            "chosen_mean + tf.exp(chosen_logstd) * rand_gaussian",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(arguments, [batch_size, -1, 1, 6])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3 * num_mix]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_169": {
                "variable": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Categorical_174": {
                "variable": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": []
                },
                "probs": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_176": {
                "variable": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_177": {
                "variable": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_179": {
                "variable": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.range(tf.size(out_logmix)), out_logmix]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_182": {
                "variable": {
                    "value": "chosen_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "out_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_183": {
                "variable": {
                    "value": "chosen_logstd",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "out_logstd",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_189": {
                "variable": {
                    "value": "arguments",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "arguments",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ret[:, :, :, 4:]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(arguments, [-1, 3 * num_mix])",
                            "Call"
                        ],
                        [
                            "chosen_mean + tf.exp(chosen_logstd) * rand_gaussian",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(arguments, [batch_size, -1, 1, 6])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, 1, 6]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_192": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[command, arguments]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_198": {
                "name_or_scope": {
                    "value": "real_bottom",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_199": {
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_48": {
                "input_tensor": {
                    "value": "tf.reduce_sum(v, axis=3)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_49": {
                "input_tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logmix + _tf_lognormal(y, mean, logstd, logsqrttwopi)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_logsumexp(v, 1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(v, [-1, 51, 1, 6])",
                            "Call"
                        ],
                        [
                            "tf.multiply(v, batch_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_102": {
                "name": {
                    "value": "losses_command",
                    "type": "str",
                    "possible_values": []
                }
            },
            "scalar_103": {
                "name": {
                    "value": "mdn_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "mdn_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_get_mdn_loss(out_logmix, out_mean, out_logstd, targs_flat, mask, model_hparams.dont_reduce_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "scalar_104": {
                "name": {
                    "value": "softmax_xent_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "softmax_xent_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(labels=targets_commands_rel, logits=commands)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(softmax_xent_loss, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(softmax_xent_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_48": {
                "input_tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logmix + _tf_lognormal(y, mean, logstd, logsqrttwopi)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_logsumexp(v, 1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reshape(v, [-1, 51, 1, 6])",
                            "Call"
                        ],
                        [
                            "tf.multiply(v, batch_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "identity_149": {
                "input": {
                    "value": "ret[:, :, :, :4]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_152": {
                "input_tensor": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(ret[:, :, :, :4]) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(command - tf.reduce_max(command, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "command / tf.reduce_sum(command, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=command).sample()",
                            "Call"
                        ],
                        [
                            "tf.one_hot(command, 4)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "identity_168": {
                "input": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_171": {
                "input_tensor": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "normal_186": {
                "shape": {
                    "value": "tf.shape(chosen_mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_187": {
                "x": {
                    "value": "model_hparams.gauss_temperature",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_151": {
                "input_tensor": {
                    "value": "command",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(ret[:, :, :, :4]) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(command - tf.reduce_max(command, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "command / tf.reduce_sum(command, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=command).sample()",
                            "Call"
                        ],
                        [
                            "tf.one_hot(command, 4)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_170": {
                "input_tensor": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_186": {
                "input": {
                    "value": "chosen_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(out_mean, out_logmix)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_188": {
                "x": {
                    "value": "chosen_logstd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather_nd(out_logstd, out_logmix)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_34": {
                "x": {
                    "value": "logstd",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_180": {
                "input": {
                    "value": "out_logmix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.identity(out_logmix) / temperature",
                            "BinOp"
                        ],
                        [
                            "tf.exp(out_logmix - tf.reduce_max(out_logmix, axis=[-1], keepdims=True))",
                            "Call"
                        ],
                        [
                            "out_logmix / tf.reduce_sum(out_logmix, axis=[-1], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.distributions.Categorical(probs=out_logmix).sample()",
                            "Call"
                        ],
                        [
                            "tf.cast(out_logmix, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out_logmix, [-1])",
                            "Call"
                        ],
                        [
                            "tf.stack([tf.range(tf.size(out_logmix)), out_logmix], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/models/svg_vae/svg_utils.py": {
        "tensorflow": {
            "make_tensor_proto_695": {
                "variable": {
                    "value": "svg_proto",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "svg",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/pipelines/chord_pipelines.py": {
        "tensorflow": {
            "warning_48": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_52": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_56": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/pipelines/drum_pipelines.py": {
        "tensorflow": {
            "warning_162": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/pipelines/event_sequence_pipeline.py": {
        "tensorflow": {}
    },
    "magenta/pipelines/lead_sheet_pipelines.py": {
        "tensorflow": {
            "warning_65": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_69": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/pipelines/melody_pipelines.py": {
        "tensorflow": {
            "warning_58": {
                "msg": {
                    "value": "Skipped sequence: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "detail",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/pipelines/note_sequence_pipelines.py": {
        "tensorflow": {
            "warn_180": {
                "msg": {
                    "value": "Key signatures ignored by TranspositionPipeline.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warn_182": {
                "msg": {
                    "value": "Pitch names ignored by TranspositionPipeline.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warn_185": {
                "msg": {
                    "value": "Chord symbols ignored by TranspositionPipeline.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_108": {
                "msg": {
                    "value": "Multiple time signatures in NoteSequence %s: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "note_sequence.filename",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_114": {
                "msg": {
                    "value": "Multiple tempos found in NoteSequence %s: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "note_sequence.filename",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_120": {
                "msg": {
                    "value": "Bad time signature in NoteSequence %s: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "note_sequence.filename",
                    "type": "Attribute",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/pipelines/performance_pipeline.py": {
        "tensorflow": {}
    },
    "magenta/pipelines/pipeline.py": {
        "tensorflow": {
            "tf_record_iterator_310": {
                "path": {
                    "value": "tfrecord_file",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_386": {
                "msg": {
                    "value": "\\n\\nCompleted.\\n",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_387": {
                "msg": {
                    "value": "Processed %d inputs total. Produced %d outputs.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "total_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_inputs + 1",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "total_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_outputs + len(output_list)",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                }
            },
            "info_424": {
                "msg": {
                    "value": "\\n\\nCompleted.\\n",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_425": {
                "msg": {
                    "value": "Processed %d inputs total. Produced %d outputs.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "total_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_inputs + 1",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "total_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_outputs + len(output_list)",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                }
            },
            "IsDirectory_289": {
                "dirname": {
                    "value": "sub",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dirs.pop()",
                            "Call"
                        ]
                    ]
                }
            },
            "Exists_355": {
                "filename": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "MakeDirs_356": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ListDirectory_286": {
                "dirname": {
                    "value": "root_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "info_383": {
                "msg": {
                    "value": "Processed %d inputs so far. Produced %d outputs.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "total_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_inputs + 1",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "total_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_outputs + len(output_list)",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                }
            },
            "info_421": {
                "msg": {
                    "value": "Processed %d inputs so far. Produced %d outputs.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "total_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_inputs + 1",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "total_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "total_outputs + len(output_list)",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                }
            },
            "TFRecordWriter_368": {
                "path": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ListDirectory_292": {
                "dirname": {
                    "value": "sub",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dirs.pop()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/pipelines/pipeline_test.py": {
        "tensorflow": {
            "tf_record_iterator_115": {
                "variable": {
                    "value": "dataset_1_reader",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "dataset_1_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, 'dataset_1.tfrecord')",
                            "Call"
                        ]
                    ]
                }
            },
            "tf_record_iterator_121": {
                "variable": {
                    "value": "dataset_2_reader",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "dataset_2_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, 'dataset_2.tfrecord')",
                            "Call"
                        ]
                    ]
                }
            },
            "MakeDirs_63": {
                "dirname": {
                    "value": "os.path.dirname(abs_path)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GFile_64": {
                "name": {
                    "value": "abs_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, path)",
                            "Call"
                        ],
                        [
                            "os.path.join(root_dir, path)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "write_64": {
                "tag": {
                    "value": "contents",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "MakeDirs_87": {
                "dirname": {
                    "value": "os.path.dirname(abs_path)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GFile_88": {
                "name": {
                    "value": "abs_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, path)",
                            "Call"
                        ],
                        [
                            "os.path.join(root_dir, path)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "write_88": {
                "tag": {
                    "value": "contents",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_data_files_path_97": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Exists_112": {
                "filename": {
                    "value": "dataset_1_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, 'dataset_1.tfrecord')",
                            "Call"
                        ]
                    ]
                }
            },
            "Exists_113": {
                "filename": {
                    "value": "dataset_2_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, 'dataset_2.tfrecord')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/pipelines/pipelines_common.py": {
        "tensorflow": {
            "FeatureLists_87": {
                "variable": {
                    "value": "feature_lists",
                    "type": "variable",
                    "possible_values": []
                },
                "feature_list": {
                    "value": "feature_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'inputs': tf.train.FeatureList(feature=input_features), 'labels': tf.train.FeatureList(feature=label_features)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "SequenceExample_88": {
                "feature_lists": {
                    "value": "feature_lists",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.FeatureLists(feature_list=feature_list)",
                            "Call"
                        ]
                    ]
                }
            },
            "Feature_75": {
                "float_list": {
                    "value": "tf.train.FloatList(value=input_)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FeatureList_84": {
                "feature": {
                    "value": "input_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.train.Feature(float_list=tf.train.FloatList(value=input_)) for input_ in inputs]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "FeatureList_85": {
                "feature": {
                    "value": "label_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "Feature_82": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=label)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FloatList_75": {
                "value": {
                    "value": "input_",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Int64List_82": {
                "value": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "labels",
                            "variable"
                        ],
                        [
                            "[label]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/pipelines/statistics.py": {
        "tensorflow": {}
    },
    "magenta/scripts/abc_compare.py": {
        "tensorflow": {
            "DEFINE_string_35": {
                "name": {
                    "value": "input_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory containing files to convert.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ListDirectory_50": {
                "variable": {
                    "value": "files_in_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "dirname": {
                    "value": "directory",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "run_105": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_96": {
                "msg": {
                    "value": "--input_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Exists_61": {
                "filename": {
                    "value": "midi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "re.sub('\\\\.abc$', str(ref_num) + '.mid', os.path.join(directory, file_in_dir))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "magenta/scripts/convert_dir_to_note_sequences.py": {
        "tensorflow": {
            "DEFINE_string_36": {
                "name": {
                    "value": "input_dir",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Directory containing files to convert.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_38": {
                "name": {
                    "value": "output_file",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to output TFRecord file. Will be overwritten if it already exists.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_bool_41": {
                "name": {
                    "value": "recursive",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "help": {
                    "value": "Whether or not to recurse into subdirectories.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_43": {
                "name": {
                    "value": "log",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "INFO",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "The threshold for what messages will be logged DEBUG, INFO, WARN, ERROR, or FATAL.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ListDirectory_83": {
                "variable": {
                    "value": "files_in_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "dirname": {
                    "value": "os.path.join(dir_to_convert)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "info_82": {
                "msg": {
                    "value": "\"Converting files in '%s'.\"",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "dir_to_convert",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, sub_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_152": {
                "msg": {
                    "value": "Converted MIDI file %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_179": {
                "msg": {
                    "value": "Converted MusicXML file %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "set_verbosity_239": {
                "level": {
                    "value": "FLAGS.log",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_259": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_260": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "log_every_n_87": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                },
                "msg": {
                    "value": "%d files converted.",
                    "type": "str",
                    "possible_values": []
                },
                "n": {
                    "value": "1000",
                    "type": "int",
                    "possible_values": []
                },
                "*args": {
                    "value": "written_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ]
                    ]
                }
            },
            "warning_205": {
                "msg": {
                    "value": "Could not parse tune in ABC file %s. It will be skipped. Error was: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "exception",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exceptions",
                            "variable"
                        ]
                    ]
                }
            },
            "info_216": {
                "msg": {
                    "value": "Converted ABC file %s.",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordWriter_234": {
                "path": {
                    "value": "output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.expanduser(FLAGS.output_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_242": {
                "msg": {
                    "value": "--input_dir required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "fatal_245": {
                "msg": {
                    "value": "--output_file required",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MakeDirs_253": {
                "dirname": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.dirname(output_file)",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_142": {
                "name": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_144": {
                "msg": {
                    "value": "Could not parse MIDI file %s. It will be skipped. Error was: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "warning_171": {
                "msg": {
                    "value": "Could not parse MusicXML file %s. It will be skipped. Error was: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_197": {
                "name": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "warning_199": {
                "msg": {
                    "value": "Could not parse ABC file %s. It will be skipped. Error was: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_95": {
                "msg": {
                    "value": "%r generated an exception: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "exc",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fatal_104": {
                "msg": {
                    "value": "%r generated an exception: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "exc",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "IsDirectory_118": {
                "dirname": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "warning_121": {
                "msg": {
                    "value": "Unable to find a converter for file %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "fatal_112": {
                "msg": {
                    "value": "%r generated an exception: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "full_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(dir_to_convert, file_in_dir)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "exc",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/scripts/convert_dir_to_note_sequences_test.py": {
        "tensorflow": {
            "disable_v2_behavior_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "main_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "MkDir_38": {
                "dirname": {
                    "value": "sub_1_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, 'sub_1')",
                            "Call"
                        ]
                    ]
                }
            },
            "MkDir_39": {
                "dirname": {
                    "value": "sub_2_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(root_dir, 'sub_2')",
                            "Call"
                        ]
                    ]
                }
            },
            "MkDir_40": {
                "dirname": {
                    "value": "sub_1_sub_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(sub_1_dir, 'sub')",
                            "Call"
                        ]
                    ]
                }
            },
            "Copy_42": {
                "oldpath": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), '../testdata/example.mid')",
                            "Call"
                        ]
                    ]
                },
                "newpath": {
                    "value": "os.path.join(root_dir, 'midi_1.mid')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Copy_43": {
                "oldpath": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), '../testdata/example.mid')",
                            "Call"
                        ]
                    ]
                },
                "newpath": {
                    "value": "os.path.join(root_dir, 'midi_2.mid')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Copy_44": {
                "oldpath": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), '../testdata/example.mid')",
                            "Call"
                        ]
                    ]
                },
                "newpath": {
                    "value": "os.path.join(sub_1_dir, 'midi_3.mid')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Copy_45": {
                "oldpath": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), '../testdata/example.mid')",
                            "Call"
                        ]
                    ]
                },
                "newpath": {
                    "value": "os.path.join(sub_2_dir, 'midi_3.mid')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Copy_46": {
                "oldpath": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), '../testdata/example.mid')",
                            "Call"
                        ]
                    ]
                },
                "newpath": {
                    "value": "os.path.join(sub_2_dir, 'midi_4.mid')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Copy_47": {
                "oldpath": {
                    "value": "midi_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(tf.resource_loader.get_data_files_path(), '../testdata/example.mid')",
                            "Call"
                        ]
                    ]
                },
                "newpath": {
                    "value": "os.path.join(sub_1_sub_dir, 'midi_5.mid')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GFile_49": {
                "name": {
                    "value": "os.path.join(root_dir, 'non_midi_file')",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "write_49": {
                "tag": {
                    "value": "non-midi data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tf_record_iterator_82": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "path": {
                    "value": "output_file.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_data_files_path_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/scripts/unpack_bundle.py": {
        "tensorflow": {
            "DEFINE_string_26": {
                "name": {
                    "value": "bundle_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path to .mag file containing the bundle",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_28": {
                "name": {
                    "value": "checkpoint_path",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "/tmp/model.ckpt",
                    "type": "str",
                    "possible_values": []
                },
                "help": {
                    "value": "Path where the extracted checkpoint shouldbe saved",
                    "type": "str",
                    "possible_values": []
                }
            },
            "disable_v2_behavior_47": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "magenta/tensor2tensor/t2t_datagen.py": {
        "tensorflow": {
            "disable_v2_behavior_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_31": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_32": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/tensor2tensor/t2t_decoder.py": {
        "tensorflow": {
            "disable_v2_behavior_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_31": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_32": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "magenta/tensor2tensor/t2t_trainer.py": {
        "tensorflow": {
            "disable_v2_behavior_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_31": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "run_32": {
                "main": {
                    "value": "main",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    }
}