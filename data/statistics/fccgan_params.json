{
    "KerasCIFAR/fid.py": {
        "sklearn": {},
        "tensorflow": {
            "Graph_222": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_225": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "GraphDef_42": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FastGFile_41": {
                "name": {
                    "value": "pth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pth",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "import_graph_def_45": {
                "variable": {
                    "value": "_",
                    "type": "variable",
                    "possible_values": []
                },
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "FID_Inception_Net",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorShape_70": {
                "variable": {
                    "value": "o.__dict__[_shape_val]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/gan_cifar10_trainable.py": {
        "sklearn": {
            "train_test_split_41": {
                "variable": {
                    "value": "(X_train1, X_train2, Y_train1, Y_train2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "X_train",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                },
                "train_size": {
                    "value": "sel_pct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_size / X_train.shape[0]",
                            "BinOp"
                        ]
                    ]
                },
                "stratify": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "KerasMNIST/fid.py": {
        "sklearn": {
            "train_test_split_277": {
                "variable": {
                    "value": "(X_train1, X_train2, Y_train1, Y_train2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "X_train",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                },
                "train_size": {
                    "value": "sel_pct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "size / X_train.shape[0]",
                            "BinOp"
                        ]
                    ]
                },
                "stratify": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Graph_245": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_248": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "GraphDef_43": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FastGFile_42": {
                "name": {
                    "value": "pth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pth",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "import_graph_def_46": {
                "variable": {
                    "value": "_",
                    "type": "variable",
                    "possible_values": []
                },
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "FID_Inception_Net",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorShape_71": {
                "variable": {
                    "value": "o.__dict__[_shape_val]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "KerasMNIST/gan_mnist_trainable.py": {
        "sklearn": {
            "train_test_split_233": {
                "variable": {
                    "value": "(X_train1, X_train2, Y_train1, Y_train2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "xtrain",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "ytrain",
                    "type": "variable",
                    "possible_values": []
                },
                "train_size": {
                    "value": "sel_pct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_size / xtrain.shape[0]",
                            "BinOp"
                        ]
                    ]
                },
                "stratify": {
                    "value": "ytrain",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "KerasMNIST/mnist_fid.py": {
        "sklearn": {
            "train_test_split_264": {
                "variable": {
                    "value": "(X_train1, X_train2, Y_train1, Y_train2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "X_train",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                },
                "train_size": {
                    "value": "sel_pct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "size / X_train.shape[0]",
                            "BinOp"
                        ]
                    ]
                },
                "stratify": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Graph_246": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_249": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "GraphDef_43": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FastGFile_42": {
                "name": {
                    "value": "pth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pth",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "import_graph_def_46": {
                "variable": {
                    "value": "_",
                    "type": "variable",
                    "possible_values": []
                },
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "FID_Inception_Net",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorShape_71": {
                "variable": {
                    "value": "o.__dict__[_shape_val]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "KerasMNIST/myutils.py": {
        "sklearn": {},
        "tensorflow": {}
    },
    "KerasSVHN/fid.py": {
        "sklearn": {
            "train_test_split_242": {
                "variable": {
                    "value": "(X_train1, X_train2, Y_train1, Y_train2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*arrays_0": {
                    "value": "X_train",
                    "type": "variable",
                    "possible_values": []
                },
                "*arrays_1": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                },
                "train_size": {
                    "value": "sel_pct",
                    "type": "variable",
                    "possible_values": [
                        [
                            "size / X_train.shape[0]",
                            "BinOp"
                        ]
                    ]
                },
                "stratify": {
                    "value": "Y_train",
                    "type": "variable",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "Graph_224": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_227": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "graph": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Graph()",
                            "Call"
                        ]
                    ]
                }
            },
            "GraphDef_43": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FastGFile_42": {
                "name": {
                    "value": "pth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pth",
                            "Method Argument"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "import_graph_def_46": {
                "variable": {
                    "value": "_",
                    "type": "variable",
                    "possible_values": []
                },
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "FID_Inception_Net",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TensorShape_71": {
                "variable": {
                    "value": "o.__dict__[_shape_val]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "KerasSVHN/myutils.py": {
        "sklearn": {},
        "tensorflow": {}
    },
    "KerasCIFAR/fccgan_resnet_cifar10.py": {
        "tensorflow": {
            "cast_219": {
                "variable": {
                    "value": "fake_labels_100",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.random_uniform([100]) * 10",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_94": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output, output, output, output]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_95": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depth_to_space_96": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "block_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_97": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_161": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, DIM_G, 4, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_170": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_176": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 3, 32, 32]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_182": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_190": {
                "variable": {
                    "value": "output_wgan",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_200": {
                "variable": {
                    "value": "real_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "real_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(real_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "real_outputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_201": {
                "variable": {
                    "value": "fake_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fake_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_202": {
                "variable": {
                    "value": "real_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones((batch_size, 1)).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_203": {
                "variable": {
                    "value": "fake_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.zeros((batch_size, 1)).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_mean_204": {
                "variable": {
                    "value": "loss_real",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(labels=real_targets, logits=real_outputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_205": {
                "variable": {
                    "value": "loss_fake",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(labels=fake_targets, logits=fake_outputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "fake_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "fake_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "constant_212": {
                "variable": {
                    "value": "real_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones((batch_size, 1)).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "leaky_relu_60": {
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_171": {
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, inputs, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.add_n([output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]) / 4.0",
                            "BinOp"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "tf.concat([output, output, output, output], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.depth_to_space(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(output, [0, 3, 1, 2])",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D(name, input_dim, output_dim, filter_size, output, he_init=he_init, biases=biases)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "Normalize(name + '.N1', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_1(name + '.Conv1', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "Normalize(name + '.N2', output, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2(name + '.Conv2', filter_size=filter_size, inputs=output)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "variable"
                        ],
                        [
                            "conv_1('Discriminator.1.Conv1', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "conv_2('Discriminator.1.Conv2', filter_size=3, inputs=output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC1', 128, 64, noise)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.FC2', 64, 512, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Generator.Input', 512, 4 * 4 * DIM_G, output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, DIM_G, 4, 4])",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.1', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.2', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Generator.3', DIM_G, DIM_G, 3, output, resample='up', labels=labels)",
                            "Call"
                        ],
                        [
                            "Normalize('Generator.OutputN', output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.conv2d.Conv2D('Generator.Output', DIM_G, 3, 3, output, he_init=False)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 3, 32, 32])",
                            "Call"
                        ],
                        [
                            "OptimizedResBlockDisc1(output)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.2', DIM_D, DIM_D, 3, output, resample='down', labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.3', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "ResidualBlock('Discriminator.4', DIM_D, DIM_D, 3, output, resample=None, labels=labels)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(output, axis=[2, 3])",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.FC3', 128, 16, output)",
                            "Call"
                        ],
                        [
                            "nonlinearity(output)",
                            "Call"
                        ],
                        [
                            "lib.ops.linear.Linear('Discriminator.Output', 16, 1, output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, OUTPUT_DIM]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_225": {
                "variable": {
                    "value": "_iteration",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "placeholder_226": {
                "variable": {
                    "value": "all_real_data_int",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[BATCH_SIZE, OUTPUT_DIM]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_227": {
                "variable": {
                    "value": "all_real_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[BATCH_SIZE]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_229": {
                "variable": {
                    "value": "labels_splits",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "all_real_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=[BATCH_SIZE])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "len(DEVICES)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_236": {
                "variable": {
                    "value": "all_real_data",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "2 * (tf.cast(all_real_data_int, tf.float32) / 256.0 - 0.5)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[BATCH_SIZE, OUTPUT_DIM]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_238": {
                "variable": {
                    "value": "all_real_data_splits",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "all_real_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(2 * (tf.cast(all_real_data_int, tf.float32) / 256.0 - 0.5), [BATCH_SIZE, OUTPUT_DIM])",
                            "Call"
                        ],
                        [
                            "all_real_data + tf.random_uniform(shape=[BATCH_SIZE, OUTPUT_DIM], minval=0.0, maxval=1.0 / 128)",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "len(DEVICES)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_292": {
                "variable": {
                    "value": "disc_acgan",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_293": {
                "variable": {
                    "value": "disc_acgan_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_294": {
                "variable": {
                    "value": "disc_acgan_fake_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdamOptimizer_332": {
                "variable": {
                    "value": "gen_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "LR * decay",
                    "type": "BinOp",
                    "possible_values": []
                },
                "beta1": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "beta2": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                }
            },
            "AdamOptimizer_333": {
                "variable": {
                    "value": "disc_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "LR * decay",
                    "type": "BinOp",
                    "possible_values": []
                },
                "beta1": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "beta2": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_341": {
                "variable": {
                    "value": "fixed_noise",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.normal(size=(100, 128)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_342": {
                "variable": {
                    "value": "fixed_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9] * 10, dtype='int32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_391": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_439": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_83": {
                "inputs": {
                    "value": "[output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_88": {
                "inputs": {
                    "value": "[output[:, :, ::2, ::2], output[:, :, 1::2, ::2], output[:, :, ::2, 1::2], output[:, :, 1::2, 1::2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_204": {
                "labels": {
                    "value": "real_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.ones((batch_size, 1)).astype(np.float32), shape=(batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.constant(np.ones((batch_size, 1)).astype(np.float32), shape=(batch_size, 1))",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "real_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(real_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "real_outputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sigmoid_cross_entropy_with_logits_205": {
                "labels": {
                    "value": "fake_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.zeros((batch_size, 1)).astype(np.float32), shape=(batch_size, 1))",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "fake_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_213": {
                "input_tensor": {
                    "value": "tf.nn.sigmoid_cross_entropy_with_logits(labels=real_targets, logits=fake_outputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_224": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "maximum_300": {
                "variable": {
                    "value": "decay",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.25",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0 - tf.cast(_iteration, tf.float32) / ITERS",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_428": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_213": {
                "labels": {
                    "value": "real_targets",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(np.ones((batch_size, 1)).astype(np.float32), shape=(batch_size, 1))",
                            "Call"
                        ],
                        [
                            "tf.constant(np.ones((batch_size, 1)).astype(np.float32), shape=(batch_size, 1))",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "fake_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "tf.reshape(fake_outputs, (-1, 1))",
                            "Call"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ],
                        [
                            "fake_outputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_249": {
                "variable": {
                    "value": "real_and_fake_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_real_data_splits[i], all_real_data_splits[len(DEVICES_A) + i], fake_data_splits[i], fake_data_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_255": {
                "variable": {
                    "value": "real_and_fake_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[labels_splits[i], labels_splits[len(DEVICES_A) + i], labels_splits[i], labels_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_272": {
                "variable": {
                    "value": "real_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_real_data_splits[i], all_real_data_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_273": {
                "variable": {
                    "value": "fake_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fake_data_splits[i], fake_data_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_274": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[labels_splits[i], labels_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sqrt_286": {
                "variable": {
                    "value": "slopes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(gradients), reduction_indices=[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_n_290": {
                "inputs": {
                    "value": "disc_costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "concat_308": {
                "variable": {
                    "value": "real_and_fake_data",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_real_data_splits[i], all_real_data_splits[len(DEVICES_A) + i], fake_data_splits[i], fake_data_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_314": {
                "variable": {
                    "value": "real_and_fake_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[labels_splits[i], labels_splits[len(DEVICES_A) + i], labels_splits[i], labels_splits[len(DEVICES_A) + i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_330": {
                "inputs": {
                    "value": "gen_costs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "initialize_all_variables_389": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_233": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "device in enumerate(DEVICES)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_B)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_248": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "device in enumerate(DEVICES)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_B)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_271": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "device in enumerate(DEVICES)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_B)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_307": {
                "device_name": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "device in enumerate(DEVICES)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_B)",
                            "Call"
                        ],
                        [
                            "device in enumerate(DEVICES_A)",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_285": {
                "ys": {
                    "value": "Discriminator(interpolates, labels)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "xs": {
                    "value": "[interpolates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_286": {
                "input_tensor": {
                    "value": "tf.square(gradients)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_287": {
                "input_tensor": {
                    "value": "(slopes - 1.0) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_236": {
                "x": {
                    "value": "all_real_data_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=[BATCH_SIZE, OUTPUT_DIM])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_286": {
                "x": {
                    "value": "gradients",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(Discriminator(interpolates, labels)[0], [interpolates])[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_300": {
                "x": {
                    "value": "_iteration",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.int32, shape=None)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "KerasCIFAR/inception.py": {
        "tensorflow": {
            "InteractiveSession_25": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_28": {
                "variable": {
                    "value": "inception_images",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[BATCH_SIZE, 3, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_31": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(images, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(images, [size, size])",
                            "Call"
                        ],
                        [
                            "inception_images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bilinear_33": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(images, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(images, [size, size])",
                            "Call"
                        ],
                        [
                            "inception_images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "[size, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_34": {
                "variable": {
                    "value": "generated_images_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(images, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(images, [size, size])",
                            "Call"
                        ],
                        [
                            "inception_images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_fn_36": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "functools.partial(tfgan.eval.run_inception, output_tensor='logits:0')",
                    "type": "Call",
                    "possible_values": []
                },
                "elems": {
                    "value": "array_ops.stack(generated_images_list)",
                    "type": "Call",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "RunClassifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_43": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "array_ops.unstack(logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_43": {
                "value": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inception_logits()",
                            "Call"
                        ],
                        [
                            "functional_ops.map_fn(fn=functools.partial(tfgan.eval.run_inception, output_tensor='logits:0'), elems=array_ops.stack(generated_images_list), parallel_iterations=1, back_prop=False, swap_memory=True, name='RunClassifier')",
                            "Call"
                        ],
                        [
                            "array_ops.concat(array_ops.unstack(logits), 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_38": {
                "values": {
                    "value": "generated_images_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "array_ops.split(images, num_or_size_splits=num_splits)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/tflib/__init__.py": {
        "tensorflow": {
            "Variable_25": {
                "variable": {
                    "value": "param",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "*args",
                    "type": "Starred",
                    "possible_values": []
                }
            }
        }
    },
    "KerasCIFAR/tflib/inception_score.py": {
        "tensorflow": {
            "GraphDef_74": {
                "variable": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "import_graph_def_76": {
                "variable": {
                    "value": "_",
                    "type": "variable",
                    "possible_values": []
                },
                "graph_def": {
                    "value": "graph_def",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.GraphDef()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_95": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.squeeze(pool3, [1, 2])",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sess.graph.get_operation_by_name('softmax/logits/MatMul').inputs[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "softmax_96": {
                "variable": {
                    "value": "softmax",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.squeeze(pool3, [1, 2]), w)",
                            "Call"
                        ]
                    ]
                }
            },
            "Session_36": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FastGFile_72": {
                "name": {
                    "value": "os.path.join(MODEL_DIR, 'classify_image_graph_def.pb')",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Session_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "squeeze_95": {
                "input": {
                    "value": "pool3",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sess.graph.get_tensor_by_name('pool_3:0')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_92": {
                "dims": {
                    "value": "new_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/tflib/mnist.py": {
        "tensorflow": {}
    },
    "KerasCIFAR/tflib/ops/batchnorm.py": {
        "tensorflow": {
            "moments_77": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "axes",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_normalization_84": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, axes, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, [2, 3], keep_dims=True)",
                            "Call"
                        ],
                        [
                            "1.0 / batch_size * mean + ((batch_size - 1.0) / batch_size * moving_mean)[None, :, None, None]",
                            "BinOp"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, axes, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, [2, 3], keep_dims=True)",
                            "Call"
                        ],
                        [
                            "1.0 / batch_size * var + ((batch_size - 1.0) / batch_size * moving_variance)[None, :, None, None]",
                            "BinOp"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.offset', np.zeros(inputs.get_shape()[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "lib.param(name + '.offset', np.zeros(shape, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.scale', np.ones(inputs.get_shape()[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "lib.param(name + '.scale', np.ones(shape, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "expand_dims_9": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_33": {
                "variable": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(inputs)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "moments_34": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cond_54": {
                "variable": {
                    "value": "(outputs, batch_mean, batch_var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "_fused_batch_norm_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_fused_batch_norm_training",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "_fused_batch_norm_inference",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_fused_batch_norm_inference",
                            "Call"
                        ]
                    ]
                }
            },
            "fused_batch_norm_30": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.scale', np.ones(inputs.get_shape()[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "lib.param(name + '.scale', np.ones(shape, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.offset', np.zeros(inputs.get_shape()[1], dtype='float32'))",
                            "Call"
                        ],
                        [
                            "lib.param(name + '.offset', np.zeros(shape, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_68": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "_force_updates",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_force_updates",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "no_updates",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambda : outputs",
                            "Lambda"
                        ]
                    ]
                }
            },
            "batch_normalization_37": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, axes, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, [2, 3], keep_dims=True)",
                            "Call"
                        ],
                        [
                            "1.0 / batch_size * mean + ((batch_size - 1.0) / batch_size * moving_mean)[None, :, None, None]",
                            "BinOp"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, axes, keep_dims=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.moments(inputs, [2, 3], keep_dims=True)",
                            "Call"
                        ],
                        [
                            "1.0 / batch_size * var + ((batch_size - 1.0) / batch_size * moving_variance)[None, :, None, None]",
                            "BinOp"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset[None, :, None, None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "scale": {
                    "value": "scale[None, :, None, None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "variance_epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_61": {
                "variable": {
                    "value": "float_stats_iter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stats_iter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_63": {
                "variable": {
                    "value": "update_moving_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.moving_mean', np.zeros(inputs.get_shape()[1], dtype='float32'), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "float_stats_iter / (float_stats_iter + 1) * moving_mean + 1 / (float_stats_iter + 1) * batch_mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "assign_64": {
                "variable": {
                    "value": "update_moving_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.moving_variance', np.ones(inputs.get_shape()[1], dtype='float32'), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "float_stats_iter / (float_stats_iter + 1) * moving_variance + 1 / (float_stats_iter + 1) * batch_var",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_33": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, 3)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "control_dependencies_66": {
                "control_inputs": {
                    "value": "[update_moving_mean, update_moving_variance]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_67": {
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_fused_batch_norm_training()",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, _fused_batch_norm_training, _fused_batch_norm_inference)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_training, _force_updates, no_updates)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/tflib/ops/cond_batchnorm.py": {
        "tensorflow": {
            "moments_10": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "axes",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "embedding_lookup_14": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "offset_m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.offset', np.zeros([n_labels, shape[1]], dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "embedding_lookup_15": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "scale_m",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.scale', np.ones([n_labels, shape[1]], dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "batch_normalization_16": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset[:, :, None, None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "scale": {
                    "value": "scale[:, :, None, None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "variance_epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "KerasCIFAR/tflib/ops/conv1d.py": {
        "tensorflow": {
            "conv1d_88": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ],
                        [
                            "filters * (target_norms / norms)",
                            "BinOp"
                        ],
                        [
                            "filters * mask",
                            "BinOp"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_18": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_104": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=inputs, filters=filters, stride=stride, padding='SAME', data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 3)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "bias_add_105": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=inputs, filters=filters, stride=stride, padding='SAME', data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 3)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Biases', np.zeros([output_dim], dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_106": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=inputs, filters=filters, stride=stride, padding='SAME', data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 3)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_81": {
                "variable": {
                    "value": "norms",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(filters), reduction_indices=[0, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_80": {
                "name": {
                    "value": "weightnorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_85": {
                "name": {
                    "value": "filter_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_81": {
                "input_tensor": {
                    "value": "tf.square(filters)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_81": {
                "x": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ],
                        [
                            "filters * (target_norms / norms)",
                            "BinOp"
                        ],
                        [
                            "filters * mask",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/tflib/ops/conv2d.py": {
        "tensorflow": {
            "conv2d_106": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ],
                        [
                            "filters * (target_norms / norms)",
                            "BinOp"
                        ],
                        [
                            "filters * mask",
                            "BinOp"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, stride, stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_27": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "bias_add_120": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input=inputs, filter=filters, strides=[1, 1, stride, stride], padding='SAME', data_format='NCHW')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NCHW')",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Biases', np.zeros(output_dim, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sqrt_99": {
                "variable": {
                    "value": "norms",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(filters), reduction_indices=[0, 1, 2])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_98": {
                "name": {
                    "value": "weightnorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_103": {
                "name": {
                    "value": "filter_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_99": {
                "input_tensor": {
                    "value": "tf.square(filters)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_99": {
                "x": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ],
                        [
                            "filters * (target_norms / norms)",
                            "BinOp"
                        ],
                        [
                            "filters * mask",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/tflib/ops/deconv2d.py": {
        "tensorflow": {
            "transpose_89": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1], name='NCHW_to_NHWC')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "NCHW_to_NHWC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_91": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1], name='NCHW_to_NHWC')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_transpose_97": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 3, 1], name='NCHW_to_NHWC')",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "filter": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ],
                        [
                            "filters * tf.expand_dims(target_norms / norms, 1)",
                            "BinOp"
                        ]
                    ]
                },
                "output_shape": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pack([input_shape[0], 2 * input_shape[1], 2 * input_shape[2], output_dim])",
                            "Call"
                        ],
                        [
                            "tf.stack([input_shape[0], 2 * input_shape[1], 2 * input_shape[2], output_dim])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 2, 2, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_112": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d_transpose(value=inputs, filter=filters, output_shape=output_shape, strides=[1, 2, 2, 1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases)",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2], name='NHWC_to_NCHW')",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "NHWC_to_NCHW",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_36": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pack_93": {
                "variable": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "bias_add_110": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d_transpose(value=inputs, filter=filters, output_shape=output_shape, strides=[1, 2, 2, 1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases)",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2], name='NHWC_to_NCHW')",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "_biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Biases', np.zeros(output_dim, dtype='float32'))",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_85": {
                "variable": {
                    "value": "norms",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(filters), reduction_indices=[0, 1, 3])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_95": {
                "variable": {
                    "value": "output_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[input_shape[0], 2 * input_shape[1], 2 * input_shape[2], output_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_84": {
                "name": {
                    "value": "weightnorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_85": {
                "input_tensor": {
                    "value": "tf.square(filters)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[0, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_86": {
                "input": {
                    "value": "target_norms / norms",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_85": {
                "x": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ],
                        [
                            "filters * tf.expand_dims(target_norms / norms, 1)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "KerasCIFAR/tflib/ops/layernorm.py": {
        "tensorflow": {
            "moments_7": {
                "variable": {
                    "value": "(mean, var)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "norm_axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "norm_axes",
                            "Method Argument"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_16": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.offset', np.zeros(n_neurons, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.reshape(offset, [-1] + [1 for i in xrange(len(norm_axes) - 1)])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1] + [1 for i in xrange(len(norm_axes) - 1)]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_17": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.scale', np.ones(n_neurons, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.reshape(scale, [-1] + [1 for i in xrange(len(norm_axes) - 1)])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1] + [1 for i in xrange(len(norm_axes) - 1)]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "batch_normalization_19": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, norm_axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.moments(inputs, norm_axes, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.offset', np.zeros(n_neurons, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.reshape(offset, [-1] + [1 for i in xrange(len(norm_axes) - 1)])",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.scale', np.ones(n_neurons, dtype='float32'))",
                            "Call"
                        ],
                        [
                            "tf.reshape(scale, [-1] + [1 for i in xrange(len(norm_axes) - 1)])",
                            "Call"
                        ]
                    ]
                },
                "variance_epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "KerasCIFAR/tflib/ops/linear.py": {
        "tensorflow": {
            "name_scope_37": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "name",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_133": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.W', weight_values)",
                            "Call"
                        ],
                        [
                            "weight * (target_norms / norms)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_135": {
                "variable": {
                    "value": "reshaped_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, input_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_136": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "reshaped_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, input_dim])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.W', weight_values)",
                            "Call"
                        ],
                        [
                            "weight * (target_norms / norms)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_137": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.matmul(reshaped_inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result, tf.pack(tf.unpack(tf.shape(inputs))[:-1] + [output_dim]))",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, lib.param(name + '.b', np.zeros((output_dim,), dtype='float32')))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.pack(tf.unpack(tf.shape(inputs))[:-1] + [output_dim])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_140": {
                "variable": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.matmul(reshaped_inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result, tf.pack(tf.unpack(tf.shape(inputs))[:-1] + [output_dim]))",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, lib.param(name + '.b', np.zeros((output_dim,), dtype='float32')))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "lib.param(name + '.b', np.zeros((output_dim,), dtype='float32'))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_125": {
                "variable": {
                    "value": "norms",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(weight), reduction_indices=[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_124": {
                "name": {
                    "value": "weightnorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_125": {
                "input_tensor": {
                    "value": "tf.square(weight)",
                    "type": "Call",
                    "possible_values": []
                },
                "reduction_indices": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_125": {
                "x": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lib.param(name + '.W', weight_values)",
                            "Call"
                        ],
                        [
                            "weight * (target_norms / norms)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_137": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "KerasMNIST/mnist_inception.py": {
        "tensorflow": {
            "placeholder_174": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 784]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_175": {
                "variable": {
                    "value": "y_",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_176": {
                "variable": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "MODE",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Saver_187": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_190": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_193": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_21": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 28, 28, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_23": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None, 784])",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 28, 28, 1])",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "[5, 5]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "activation_fn": {
                    "value": "tf.nn.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weights_initializer": {
                    "value": "tf.truncated_normal_initializer(stddev=0.01)",
                    "type": "Call",
                    "possible_values": []
                },
                "normalizer_fn": {
                    "value": "slim.batch_norm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "normalizer_params": {
                    "value": "batch_norm_params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'is_training': _is_training, 'decay': 0.9, 'updates_collections': None}",
                            "Dict"
                        ]
                    ]
                },
                "scope": {
                    "value": "conv1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool2d_29": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(x, 32, [5, 5], padding='SAME', activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='conv1')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool1')",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, 64, [5, 5], scope='conv2')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool2')",
                            "Call"
                        ],
                        [
                            "slim.flatten(net, scope='flatten3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, 1024, activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='fc4')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, keep_prob=0.7, is_training=_is_training, scope='dropout4')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[2, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "scope": {
                    "value": "pool1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_30": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(x, 32, [5, 5], padding='SAME', activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='conv1')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool1')",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, 64, [5, 5], scope='conv2')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool2')",
                            "Call"
                        ],
                        [
                            "slim.flatten(net, scope='flatten3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, 1024, activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='fc4')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, keep_prob=0.7, is_training=_is_training, scope='dropout4')",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "[5, 5]",
                    "type": "List",
                    "possible_values": []
                },
                "scope": {
                    "value": "conv2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pool2d_31": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(x, 32, [5, 5], padding='SAME', activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='conv1')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool1')",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, 64, [5, 5], scope='conv2')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool2')",
                            "Call"
                        ],
                        [
                            "slim.flatten(net, scope='flatten3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, 1024, activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='fc4')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, keep_prob=0.7, is_training=_is_training, scope='dropout4')",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[2, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "scope": {
                    "value": "pool2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "flatten_32": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(x, 32, [5, 5], padding='SAME', activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='conv1')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool1')",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, 64, [5, 5], scope='conv2')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool2')",
                            "Call"
                        ],
                        [
                            "slim.flatten(net, scope='flatten3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, 1024, activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='fc4')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, keep_prob=0.7, is_training=_is_training, scope='dropout4')",
                            "Call"
                        ]
                    ]
                },
                "scope": {
                    "value": "flatten3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_39": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": [
                        [
                            "slim.conv2d(x, 32, [5, 5], padding='SAME', activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='conv1')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool1')",
                            "Call"
                        ],
                        [
                            "slim.conv2d(net, 64, [5, 5], scope='conv2')",
                            "Call"
                        ],
                        [
                            "slim.max_pool2d(net, [2, 2], scope='pool2')",
                            "Call"
                        ],
                        [
                            "slim.flatten(net, scope='flatten3')",
                            "Call"
                        ],
                        [
                            "slim.fully_connected(net, 1024, activation_fn=tf.nn.relu, weights_initializer=tf.truncated_normal_initializer(stddev=0.01), normalizer_fn=slim.batch_norm, normalizer_params=batch_norm_params, scope='fc4')",
                            "Call"
                        ],
                        [
                            "slim.dropout(net, keep_prob=0.7, is_training=_is_training, scope='dropout4')",
                            "Call"
                        ]
                    ]
                },
                "keep_prob": {
                    "value": "0.7",
                    "type": "float",
                    "possible_values": []
                },
                "is_training": {
                    "value": "_is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "scope": {
                    "value": "dropout4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_181": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "CNN(x, is_training)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "y_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None, 10])",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_184": {
                "variable": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(y, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(y_, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_185": {
                "variable": {
                    "value": "accuracy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(correct_prediction, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_180": {
                "name": {
                    "value": "LOSS",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_183": {
                "name": {
                    "value": "ACC",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_initializer_194": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "argmax_184": {
                "input": {
                    "value": "y_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, [None, 10])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_185": {
                "x": {
                    "value": "correct_prediction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_25": {
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "truncated_normal_initializer_35": {
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "KerasSVHN/inception.py": {
        "tensorflow": {
            "InteractiveSession_25": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_28": {
                "variable": {
                    "value": "inception_images",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[BATCH_SIZE, 3, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_31": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(images, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(images, [size, size])",
                            "Call"
                        ],
                        [
                            "inception_images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bilinear_33": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(images, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(images, [size, size])",
                            "Call"
                        ],
                        [
                            "inception_images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "[size, size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_34": {
                "variable": {
                    "value": "generated_images_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(images, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(images, [size, size])",
                            "Call"
                        ],
                        [
                            "inception_images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ],
                        [
                            "images",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_splits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "map_fn_36": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "functools.partial(tfgan.eval.run_inception, output_tensor='logits:0')",
                    "type": "Call",
                    "possible_values": []
                },
                "elems": {
                    "value": "array_ops.stack(generated_images_list)",
                    "type": "Call",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "swap_memory": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "RunClassifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_43": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "array_ops.unstack(logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unstack_43": {
                "value": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inception_logits()",
                            "Call"
                        ],
                        [
                            "functional_ops.map_fn(fn=functools.partial(tfgan.eval.run_inception, output_tensor='logits:0'), elems=array_ops.stack(generated_images_list), parallel_iterations=1, back_prop=False, swap_memory=True, name='RunClassifier')",
                            "Call"
                        ],
                        [
                            "array_ops.concat(array_ops.unstack(logits), 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_38": {
                "values": {
                    "value": "generated_images_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "array_ops.split(images, num_or_size_splits=num_splits)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}