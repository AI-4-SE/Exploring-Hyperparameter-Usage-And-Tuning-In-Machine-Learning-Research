{
    "examples/quantization/example_view_quant_weight.py": {
        "tensorflow": {
            "maximum_33": {
                "variable": {
                    "value": "weight_clip_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "clip_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model._encoder._stacking_layers[0][1]._layer._conv1.traced['kernel'].clip_max",
                            "Attribute"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_34": {
                "variable": {
                    "value": "weight_clip_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_clip_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(clip_max, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(weight_clip_max, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "quantize_39": {
                "input": {
                    "value": "model._encoder._stacking_layers[0][1]._layer._conv1.kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_range": {
                    "value": "weight_clip_min",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-weight_clip_max * bits_tmp / (bits_tmp - 1)",
                            "BinOp"
                        ]
                    ]
                },
                "max_range": {
                    "value": "clip_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model._encoder._stacking_layers[0][1]._layer._conv1.traced['kernel'].clip_max",
                            "Attribute"
                        ]
                    ]
                },
                "T": {
                    "value": "tf.qint8",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "examples/translation/download_wmt14en2de.py": {
        "tensorflow": {
            "GFile_86": {
                "name": {
                    "value": "os.path.join(output_dir, 'train.en.txt')",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_87": {
                "name": {
                    "value": "os.path.join(output_dir, 'train.de.txt')",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_107": {
                "name": {
                    "value": "dev_trg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, _DEV_DATA_RESOURCE['TRG'])",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_126": {
                "name": {
                    "value": "test_trg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, _TEST_DATA_RESOURCE['TRG'])",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_89": {
                "name": {
                    "value": "trg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, traindata['TRG'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/cli/avg_checkpoint.py": {
        "tensorflow": {
            "list_variables_71": {
                "variable": {
                    "value": "var_name_shape_list",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "all_checkpoint_paths[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Checkpoint_98": {
                "variable": {
                    "value": "ckpt_saver",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Variable_93": {
                "variable": {
                    "value": "tf_vars[fine_name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "var_values[fine_name]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "fine_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wrapper_var_name(var_name)",
                            "Call"
                        ],
                        [
                            "wrapper_var_name(var_name)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "str(var_values[fine_name].dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "copy_100": {
                "a": {
                    "value": "model_config_yml_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "os.path.join(c, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ]
                    ]
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "exists_35": {
                "path": {
                    "value": "path + '.meta'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exists_36": {
                "path": {
                    "value": "path + '.index'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exists_60": {
                "path": {
                    "value": "os.path.join(c, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "isdir_64": {
                "path": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "checkpoints",
                            "Name"
                        ],
                        [
                            "checkpoints",
                            "Name"
                        ]
                    ]
                }
            },
            "get_checkpoint_state_65": {
                "variable": {
                    "value": "checkpoint_states",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "checkpoints",
                            "Name"
                        ],
                        [
                            "checkpoints",
                            "Name"
                        ]
                    ]
                }
            },
            "load_variable_78": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "all_checkpoint_paths",
                            "Name"
                        ]
                    ]
                },
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "var_values.keys()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/cli/cascade_st.py": {
        "tensorflow": {
            "GFile_116": {
                "name": {
                    "value": "mt_reference_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'ram://mt_reference_file'",
                            "Constant"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_107": {
                "name": {
                    "value": "asr_output_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['asr_output_file']",
                            "Subscript"
                        ],
                        [
                            "'ram://asr_output_file'",
                            "Constant"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/cli/create_tfrecords.py": {
        "tensorflow": {
            "map_structure_52": {
                "variable": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda _x: _x.encode('utf-8')",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda _x: _x.encode('utf-8'), feature)",
                            "Call"
                        ]
                    ]
                }
            },
            "Feature_58": {
                "bytes_list": {
                    "value": "tf.train.BytesList(value=value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TFRecordDataset_111": {
                "filenames": {
                    "value": "file_paths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[output_template % (s, num_output_shards) for s in range(output_range_begin, output_range_end)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "take_111": {
                "a": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Example_112": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Feature_55": {
                "int64_list": {
                    "value": "tf.train.Int64List(value=value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exists_67": {
                "path": {
                    "value": "os.path.dirname(output_template)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "makedirs_68": {
                "path": {
                    "value": "os.path.dirname(output_template)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TFRecordWriter_73": {
                "path": {
                    "value": "_x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "rename_109": {
                "src": {
                    "value": "tmp_f",
                    "type": "variable",
                    "possible_values": []
                },
                "dst": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Feature_57": {
                "float_list": {
                    "value": "tf.train.FloatList(value=value)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_58": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.array(feature).flatten()",
                            "Call"
                        ]
                    ]
                }
            },
            "Example_101": {
                "features": {
                    "value": "tf.train.Features(feature=feature_dict)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Int64List_55": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.array(feature).flatten()",
                            "Call"
                        ]
                    ]
                }
            },
            "FloatList_57": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.array(feature).flatten()",
                            "Call"
                        ]
                    ]
                }
            },
            "Features_101": {
                "feature": {
                    "value": "feature_dict",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/cli/extract_audio_transcripts.py": {
        "tensorflow": {
            "GFile_35": {
                "name": {
                    "value": "output_transcript_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_38": {
                "name": {
                    "value": "output_translation_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/cli/generate_vocab.py": {
        "tensorflow": {
            "GFile_25": {
                "name": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_67": {
                "name": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/cli/inspect_checkpoint.py": {
        "tensorflow": {
            "latest_checkpoint_44": {
                "variable": {
                    "value": "latest_ckpt_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sys.argv[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "list_variables_48": {
                "variable": {
                    "value": "varname_shape_list",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "latest_ckpt_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(model_dir)",
                            "Call"
                        ],
                        [
                            "model_dir",
                            "Name"
                        ]
                    ]
                }
            },
            "load_variable_65": {
                "ckpt_dir_or_file": {
                    "value": "latest_ckpt_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(model_dir)",
                            "Call"
                        ],
                        [
                            "model_dir",
                            "Name"
                        ]
                    ]
                },
                "name": {
                    "value": "clean_varname2ckpt_varname[var_name][0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/cli/text_metric.py": {
        "tensorflow": {
            "GFile_33": {
                "name": {
                    "value": "hypo_file",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_35": {
                "name": {
                    "value": "ref_file",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/cli/view_tfrecord.py": {
        "tensorflow": {
            "TFRecordDataset_29": {
                "filenames": {
                    "value": "glob_tfrecords(sys.argv[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "take_29": {
                "a": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Example_30": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "neurst/criterions/label_smoothed_cross_entropy.py": {
        "tensorflow": {
            "cast_97": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_out",
                            "Name"
                        ],
                        [
                            "model_out['logits']",
                            "Subscript"
                        ],
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_104": {
                "variable": {
                    "value": "soft_target",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.cast(labels, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits.get_shape()[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "on_value": {
                    "value": "confidence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - self._label_smoothing",
                            "BinOp"
                        ]
                    ]
                },
                "off_value": {
                    "value": "low_confidence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._label_smoothing / tf.cast(vocab_size - 1, tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_110": {
                "variable": {
                    "value": "xentropy",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_out",
                            "Name"
                        ],
                        [
                            "model_out['logits']",
                            "Subscript"
                        ],
                        [
                            "tf.cast(logits, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "soft_target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.cast(labels, tf.int32), depth=vocab_size, on_value=confidence, off_value=low_confidence)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_129": {
                "variable": {
                    "value": "nll_sum",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "xentropy * weights",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_130": {
                "variable": {
                    "value": "n_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(tf.shape(labels)[0], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_131": {
                "variable": {
                    "value": "n_tokens",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(1 - model_inp['trg_padding'], tf.float32)",
                            "Call"
                        ],
                        [
                            "input_length_to_nonpadding(model_inp['trg_length'], tf.shape(labels)[1], tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_52": {
                "input_tensor": {
                    "value": "n_tokens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(weights, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_66": {
                "input_tensor": {
                    "value": "_nll_sum",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_67": {
                "input_tensor": {
                    "value": "_nll_samples",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_68": {
                "input_tensor": {
                    "value": "_nll_tokens",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_100": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_126": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 - model_inp['trg_padding']",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_103": {
                "x": {
                    "value": "vocab_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_105": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_inp['trg']",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_130": {
                "input": {
                    "value": "tf.shape(labels)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_128": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_inp['trg']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_130": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_inp['trg']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "log_117": {
                "x": {
                    "value": "confidence",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - self._label_smoothing",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_119": {
                "x": {
                    "value": "low_confidence + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_118": {
                "x": {
                    "value": "vocab_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/dataset_utils.py": {
        "tensorflow": {
            "constant_91": {
                "variable": {
                    "value": "bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size // x // num_replicas_in_sync * num_replicas_in_sync for x in buckets_max]",
                            "ListComp"
                        ],
                        [
                            "tf.constant(bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[bucket_batch_sizes] * cnt",
                            "BinOp"
                        ],
                        [
                            "tf.constant(bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Options_212": {
                "variable": {
                    "value": "options",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parse_single_example_228": {
                "variable": {
                    "value": "parsed",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized_example",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "name_to_features",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Options_314": {
                "variable": {
                    "value": "options",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_510": {
                "variable": {
                    "value": "bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batch_size // x // num_replicas_in_sync * num_replicas_in_sync for x in buckets_max]",
                            "ListComp"
                        ],
                        [
                            "tf.constant(bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[bucket_batch_sizes] * cnt",
                            "BinOp"
                        ],
                        [
                            "tf.constant(bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_95": {
                "variable": {
                    "value": "seq_length",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "example_length_func(examples)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_97": {
                "variable": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less_equal(buckets_min, seq_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(seq_length, buckets_max)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_min_100": {
                "variable": {
                    "value": "bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.where(conditions_c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_all_517": {
                "variable": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[tf.less_equal(v, bucket_boundaries[k]) for (k, v) in seq_length.items()]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_520": {
                "variable": {
                    "value": "bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.where(conditions_c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "isdir_552": {
                "path": {
                    "value": "_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_string_list(data_path)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "Example_564": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "group_by_window_118": {
                "key_func": {
                    "value": "example_to_bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "reduce_func": {
                    "value": "batching_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "window_size": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "window_size_func": {
                    "value": "window_size_fn",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "isdir_197": {
                "path": {
                    "value": "_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "flatten_string_list(file_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_dense_232": {
                "variable": {
                    "value": "elements[k]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_dense_234": {
                "variable": {
                    "value": "elements[name_mapping[k]]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "sp_input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "isdir_247": {
                "path": {
                    "value": "_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "flatten_string_list(file_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "isdir_286": {
                "path": {
                    "value": "_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "flatten_string_list(file_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "Options_303": {
                "variable": {
                    "value": "options",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_511": {
                "value": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_by_window_543": {
                "key_func": {
                    "value": "example_to_bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "reduce_func": {
                    "value": "batching_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "window_size": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "window_size_func": {
                    "value": "window_size_fn",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "exists_554": {
                "path": {
                    "value": "_file_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flatten_string_list(data_path)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "less_equal_98": {
                "x": {
                    "value": "buckets_min",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0] + bucket_boundaries[:-1]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "seq_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(example_length_func(examples), tf.int32)",
                            "Call"
                        ],
                        [
                            "example_length_func(examples)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_99": {
                "x": {
                    "value": "seq_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(example_length_func(examples), tf.int32)",
                            "Call"
                        ],
                        [
                            "example_length_func(examples)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "buckets_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bucket_boundaries",
                            "Name"
                        ]
                    ]
                }
            },
            "where_100": {
                "condition": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.less_equal(buckets_min, seq_length), tf.less(seq_length, buckets_max))",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([tf.less_equal(v, bucket_boundaries[k]) for (k, v) in seq_length.items()], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "exists_199": {
                "path": {
                    "value": "_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "flatten_string_list(file_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "exists_249": {
                "path": {
                    "value": "_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "flatten_string_list(file_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "exists_288": {
                "path": {
                    "value": "_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "_files",
                            "Name"
                        ],
                        [
                            "flatten_string_list(file_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_all_332": {
                "input_tensor": {
                    "value": "[(length == -1 or length is None or tf.less_equal(tf.size(data_sample[k]), length)) and (length == -1 or (length != -1 and tf.size(data_sample[k]) > 1)) for (k, length) in data_max_lengths.items()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "reduce_max_381": {
                "input_tensor": {
                    "value": "[tf.size(examples[k]) for (k, length) in data_max_lengths.items() if length != -1]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "where_520": {
                "condition": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.less_equal(buckets_min, seq_length), tf.less(seq_length, buckets_max))",
                            "Call"
                        ],
                        [
                            "tf.reduce_all([tf.less_equal(v, bucket_boundaries[k]) for (k, v) in seq_length.items()], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "TFRecordDataset_560": {
                "filenames": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "128 * 1024 * 1024",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "glob_248": {
                "pattern": {
                    "value": "os.path.join(_file, '*train*')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_all_408": {
                "input_tensor": {
                    "value": "[length == -1 or length is None or tf.size(data_sample[k]) <= max_length for (k, length) in data_max_lengths.items()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "less_equal_518": {
                "x": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "bucket_boundaries[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "TFRecordDataset_215": {
                "filenames": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "128 * 1024 * 1024",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "glob_252": {
                "pattern": {
                    "value": "_file + '*'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "TFRecordDataset_317": {
                "filenames": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "128 * 1024 * 1024",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "size_382": {
                "input": {
                    "value": "examples[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "less_equal_334": {
                "x": {
                    "value": "tf.size(data_sample[k])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_334": {
                "input": {
                    "value": "data_sample[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "size_409": {
                "input": {
                    "value": "data_sample[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "size_335": {
                "input": {
                    "value": "data_sample[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/audio/audio_dataset.py": {
        "tensorflow": {
            "GFile_139": {
                "variable": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "exists_135": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_306": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_307": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_437": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_438": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_439": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exists_89": {
                "path": {
                    "value": "excluded_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['excluded_file']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "GFile_91": {
                "name": {
                    "value": "excluded_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['excluded_file']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "VarLenFeature_302": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_303": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_304": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_305": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_431": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_432": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_433": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_434": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_435": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_436": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "copy_155": {
                "a": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "rename_156": {
                "src": {
                    "value": "local_path + '.incomplete'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dst": {
                    "value": "local_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._input_tarball",
                            "Attribute"
                        ],
                        [
                            "os.path.join(os.path.dirname(os.path.abspath(__file__)), os.path.basename(self._input_tarball))",
                            "Call"
                        ]
                    ]
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/audio/common_voice.py": {
        "tensorflow": {
            "isdir_109": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "isdir_66": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "isdir_169": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_111": {
                "name": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._input_tarball, f'{self._language}/{self._extraction}.tsv')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/data/datasets/audio/iwslt.py": {
        "tensorflow": {
            "isdir_52": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "isdir_128": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_56": {
                "name": {
                    "value": "en_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._input_tarball, f'parallel/{self._extraction}.en')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_58": {
                "name": {
                    "value": "de_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._input_tarball, f'parallel/{self._extraction}.de')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_60": {
                "name": {
                    "value": "yaml_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._input_tarball, f'parallel/{self._extraction}.yaml')",
                            "Call"
                        ]
                    ]
                }
            },
            "remove_172": {
                "path": {
                    "value": "tmp_wav_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(os.path.dirname(__file__), f'_tmp{time.time()}.wav')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_130": {
                "name": {
                    "value": "f'{self._input_tarball}/wav/{wavname}'",
                    "type": "JoinedStr",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_138": {
                "name": {
                    "value": "tmp_wavname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f'ram://_tmpwav{time.time()}.wav'",
                            "JoinedStr"
                        ]
                    ]
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_140": {
                "name": {
                    "value": "tmp_wavname",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f'ram://_tmpwav{time.time()}.wav'",
                            "JoinedStr"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/audio/librispeech.py": {
        "tensorflow": {
            "isdir_81": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glob_83": {
                "variable": {
                    "value": "level1_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "pattern": {
                    "value": "os.path.join(level0_pathwildcard, '*')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "isdir_156": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glob_158": {
                "variable": {
                    "value": "level1_paths",
                    "type": "variable",
                    "possible_values": []
                },
                "pattern": {
                    "value": "os.path.join(level0_pathwildcard, '*')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "glob_84": {
                "pattern": {
                    "value": "level0_pathwildcard",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._input_tarball, '*')",
                            "Call"
                        ],
                        [
                            "os.path.join(self._input_tarball, '*')",
                            "Call"
                        ]
                    ]
                }
            },
            "glob_87": {
                "pattern": {
                    "value": "os.path.join(path, '*')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "glob_161": {
                "pattern": {
                    "value": "os.path.join(path, '*')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GFile_93": {
                "name": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.io.gfile.glob(os.path.join(path, '*'))",
                            "Call"
                        ],
                        [
                            "tf.io.gfile.glob(os.path.join(path, '*'))",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/audio/mustc.py": {
        "tensorflow": {
            "isdir_78": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "listdir_80": {
                "path": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._input_tarball, f'data/{self._extraction}/txt')",
                            "Call"
                        ]
                    ]
                }
            },
            "isdir_163": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_81": {
                "name": {
                    "value": "os.path.join(path, filename)",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/audio/tedlium.py": {
        "tensorflow": {
            "isdir_81": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glob_83": {
                "pattern": {
                    "value": "os.path.join(input_dir, '*.stm')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "isdir_132": {
                "path": {
                    "value": "self._input_tarball",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glob_134": {
                "pattern": {
                    "value": "os.path.join(input_dir, '*.sph')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GFile_84": {
                "name": {
                    "value": "stm_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.io.gfile.glob(os.path.join(input_dir, '*.stm'))",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_141": {
                "variable": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "sph_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.io.gfile.glob(os.path.join(input_dir, '*.sph'))",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_140": {
                "name": {
                    "value": "tmp_sph_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(os.path.dirname(__file__), f'_tmp{time.time()}.sph')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_182": {
                "name": {
                    "value": "tmp_sph_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(os.path.dirname(__file__), f'_tmp{time.time()}.sph')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "wb",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/cross_modal_multiple_datasets.py": {
        "tensorflow": {
            "VarLenFeature_98": {
                "variable": {
                    "value": "self._datasets[text2text][name][data_field][src_lang]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_99": {
                "variable": {
                    "value": "self._datasets[text2text][name][data_field][f{target_tag}_lang]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TFRecordDataset_70": {
                "filenames": {
                    "value": "glob_tfrecords(dargs['data_path'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "take_70": {
                "a": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Example_71": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "VarLenFeature_90": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_321": {
                "name": {
                    "value": "self._valid_ds_args['tgt_file']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "VarLenFeature_91": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_92": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_93": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_94": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TFRecordDataset_107": {
                "filenames": {
                    "value": "glob_tfrecords(dargs['data_path'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "take_107": {
                "a": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Example_108": {
                "variable": {
                    "value": "example",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "VarLenFeature_123": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_124": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_132": {
                "variable": {
                    "value": "self._datasets[speech2text][name][data_field][f{target_tag}_lang]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_125": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_126": {
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_135": {
                "variable": {
                    "value": "self._datasets[speech2text][name][data_field][src_lang]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/dataset.py": {
        "tensorflow": {
            "Options_54": {
                "variable": {
                    "value": "options",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/mixed_train_dataset.py": {
        "tensorflow": {
            "sample_from_datasets_80": {
                "datasets": {
                    "value": "[v.build(auto_shard, map_func, map_output_dtypes, shuffle) for (_, v) in self._custom_dss.items()]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "[self._data_sampler.normalized_sample_weights[k] for (k, _) in self._custom_dss.items()]",
                            "ListComp"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/data/datasets/multilingual_translation_dataset.py": {
        "tensorflow": {
            "Options_115": {
                "variable": {
                    "value": "options",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "glob_75": {
                "pattern": {
                    "value": "os.path.join(self._path, '*')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exists_72": {
                "path": {
                    "value": "self._path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "isdir_83": {
                "path": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.io.gfile.glob(os.path.join(self._path, '*'))",
                            "Call"
                        ]
                    ]
                }
            },
            "VarLenFeature_88": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_89": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_96": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_97": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/datasets/parallel_text_dataset.py": {
        "tensorflow": {
            "GFile_120": {
                "variable": {
                    "value": "fsrc",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "self._src_file",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_279": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "VarLenFeature_280": {
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_121": {
                "name": {
                    "value": "self._trg_file",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_150": {
                "name": {
                    "value": "self._src_file",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_158": {
                "name": {
                    "value": "self._trg_file",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_233": {
                "name": {
                    "value": "elem['src_file']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "GFile_234": {
                "name": {
                    "value": "elem['trg_file']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/text/bpe.py": {
        "tensorflow": {
            "GFile_37": {
                "name": {
                    "value": "codes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[line.strip() for line in fp][1:]",
                            "Subscript"
                        ],
                        [
                            "codes[1:]",
                            "Subscript"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_26": {
                "name": {
                    "value": "vocabulary",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/data/text/spm.py": {
        "tensorflow": {
            "copy_45": {
                "a": {
                    "value": "codes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._codes",
                            "Attribute"
                        ],
                        [
                            "local_path",
                            "Name"
                        ]
                    ]
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/text/subtokenizer.py": {
        "tensorflow": {
            "GFile_47": {
                "name": {
                    "value": "vocab_file",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "exists_589": {
                "path": {
                    "value": "vocab_file",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_345": {
                "name": {
                    "value": "filepath",
                    "type": "variable",
                    "possible_values": [
                        [
                            "files",
                            "Name"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_438": {
                "name": {
                    "value": "codes",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/data/text/vocab.py": {
        "tensorflow": {
            "GFile_76": {
                "name": {
                    "value": "vocab_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/exps/evaluator.py": {
        "tensorflow": {
            "Model_59": {
                "variable": {
                    "value": "keras_model",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "inps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "task.create_inputs(compat.ModeKeys.EVAL)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "criterion(formatted_inps, model_out)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/exps/sequence_generator.py": {
        "tensorflow": {
            "Model_83": {
                "variable": {
                    "value": "keras_model",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "inps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "task.create_inputs(compat.ModeKeys.INFER)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "generation_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "search_layer(formatted_inps)",
                            "Call"
                        ],
                        [
                            "generation_ops[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "GFile_206": {
                "name": {
                    "value": "self._save_metric",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_156": {
                "name": {
                    "value": "self._output_file",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_147": {
                "name": {
                    "value": "self._output_file[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/exps/sequence_generator_savedmodel.py": {
        "tensorflow": {
            "load_72": {
                "variable": {
                    "value": "loaded",
                    "type": "variable",
                    "possible_values": []
                },
                "export_dir": {
                    "value": "export_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._export_path, str(self._version))",
                            "Call"
                        ]
                    ]
                }
            },
            "save_model_64": {
                "model": {
                    "value": "keras_model",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.build_generation_model(self.task, model, self._search_layer)",
                            "Call"
                        ]
                    ]
                },
                "filepath": {
                    "value": "export_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self._export_path, str(self._version))",
                            "Call"
                        ]
                    ]
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "include_optimizer": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "save_format": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "signatures": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "options": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "copy_73": {
                "a": {
                    "value": "os.path.join(self.model_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                    "type": "Call",
                    "possible_values": []
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/exps/trainer.py": {
        "tensorflow": {
            "Model_206": {
                "variable": {
                    "value": "keras_model",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "inps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.task.create_inputs(compat.ModeKeys.TRAIN)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "model_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.model(formatted_inps, is_training=True)",
                            "Call"
                        ],
                        [
                            "metric_layer([formatted_inps, model_out])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/exps/validation.py": {
        "tensorflow": {
            "create_file_writer_80": {
                "variable": {
                    "value": "file_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "self._tb_log_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_91": {
                "variable": {
                    "value": "ckpt_state",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "self.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flush_125": {
                "writer": {
                    "value": "file_writer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.summary.create_file_writer(self._tb_log_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_checkpoint_state_98": {
                "variable": {
                    "value": "ckpt_state",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "self.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/__init__.py": {
        "tensorflow": {}
    },
    "neurst/layers/attentions/light_convolution_layer.py": {
        "tensorflow": {
            "Dense_60": {
                "variable": {
                    "value": "self._dense2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "input_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_shape[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "dense2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_80": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self._conv_weight_linear(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, timestep, self._num_heads, self._kernel_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_82": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self._conv_weight_linear(x), [batch, timestep, self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(w)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(w, rate=self._weight_dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(self._conv_shared_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_129": {
                "variable": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x_unfold, [batch, timestep, self._num_heads, x_dim // self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.transpose(x, [0, 2, 1]), 1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, timestep, self._num_heads, x_dim // self._num_heads, self._kernel_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_131": {
                "variable": {
                    "value": "conv_out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.einsum('abcde,abce->abcd', x_unfold, w)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, timestep, x_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_162": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_164": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "self._conv_shared_weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_166": {
                "variable": {
                    "value": "filter",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.repeat(tf.transpose(w), repeats=x_dim // self._num_heads)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self._kernel_size, x_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_169": {
                "input": {
                    "value": "filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.repeat(tf.transpose(w), repeats=x_dim // self._num_heads), [self._kernel_size, x_dim])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(filter, 1), 3)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(filter, rate=self._weight_dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "DepthwiseConv2dNative_173": {
                "variable": {
                    "value": "conv_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "filter": {
                    "value": "filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.repeat(tf.transpose(w), repeats=x_dim // self._num_heads), [self._kernel_size, x_dim])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(filter, 1), 3)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(filter, rate=self._weight_dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Constant"
                        ],
                        [
                            "'VALID'",
                            "Constant"
                        ]
                    ]
                }
            },
            "squeeze_175": {
                "variable": {
                    "value": "conv_out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.einsum('abcde,abce->abcd', x_unfold, w), [batch, timestep, x_dim])",
                            "Call"
                        ],
                        [
                            "tf.raw_ops.DepthwiseConv2dNative(input=x, filter=filter, strides=[1, 1, 1, 1], padding=padding_)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(conv_out, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Dense_55": {
                "variable": {
                    "value": "self._dense1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._conv_dim * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "activation": {
                    "value": "glu",
                    "type": "variable",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "dense1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_58": {
                "variable": {
                    "value": "self._dense1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._conv_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "dense1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "extract_patches_116": {
                "variable": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "tf.cast(tf.expand_dims(x, 1), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "sizes": {
                    "value": "[1, 1, self._kernel_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_123": {
                "variable": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_127": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self._conv_weight_linear(x), [batch, timestep, self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(w)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(w, rate=self._weight_dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(self._conv_shared_weight)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._weight_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_171": {
                "variable": {
                    "value": "filter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.repeat(tf.transpose(w), repeats=x_dim // self._num_heads), [self._kernel_size, x_dim])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(filter, 1), 3)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(filter, rate=self._weight_dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._weight_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_68": {
                "variable": {
                    "value": "self._conv_weight_linear",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._num_heads * self._kernel_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "conv_weight_linear",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "shape_77": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_78": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_100": {
                "variable": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.transpose(x, [0, 2, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_102": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [self._kernel_size - 1, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "extract_patches_105": {
                "variable": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "tf.cast(tf.expand_dims(x, 1), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "sizes": {
                    "value": "[1, 1, self._kernel_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "rates": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "transpose_112": {
                "variable": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_131": {
                "equation": {
                    "value": "abcde,abce->abcd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x_unfold, [batch, timestep, self._num_heads, x_dim // self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.transpose(x, [0, 2, 1]), 1)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self._conv_weight_linear(x), [batch, timestep, self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(w)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(w, rate=self._weight_dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(self._conv_shared_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_140": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [self._kernel_size - 1, 0], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "repeat_166": {
                "input": {
                    "value": "tf.transpose(w)",
                    "type": "Call",
                    "possible_values": []
                },
                "repeats": {
                    "value": "x_dim // self._num_heads",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_195": {
                "input": {
                    "value": "1.0 - inputs_padding",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_86": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[cache['conv'], x]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_93": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.one_hot(decode_loop_step + self._kernel_size - 1, size, dtype=x.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_123": {
                "tensor": {
                    "value": "tf.cast(x_unfold, dtype=x.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, timestep, self._kernel_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_144": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[cache['conv'], x]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_151": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.one_hot(decode_loop_step + self._kernel_size - 1, size, dtype=x.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_166": {
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self._conv_weight_linear(x), [batch, timestep, self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(w)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(w, rate=self._weight_dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(self._conv_shared_weight)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_100": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_112": {
                "tensor": {
                    "value": "tf.cast(x_unfold, dtype=x.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, timestep, self._kernel_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_117": {
                "x": {
                    "value": "tf.expand_dims(x, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_123": {
                "x": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x_unfold, [batch, timestep, self._num_heads, x_dim // self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.transpose(x, [0, 2, 1]), 1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_94": {
                "indices": {
                    "value": "decode_loop_step + self._kernel_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_cache.get_shape().as_list()[1]",
                            "Subscript"
                        ],
                        [
                            "_cache.get_shape().as_list()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_106": {
                "x": {
                    "value": "tf.expand_dims(x, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_112": {
                "x": {
                    "value": "x_unfold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.image.extract_patches(images=tf.cast(tf.expand_dims(x, 1), dtype=tf.float32), sizes=[1, 1, self._kernel_size, 1], strides=[1, 1, 1, 1], rates=[1, 1, 1, 1], padding='VALID')",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.reshape(tf.cast(x_unfold, dtype=x.dtype), [batch, timestep, self._kernel_size, -1]), [0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(x_unfold, [batch, timestep, self._num_heads, x_dim // self._num_heads, self._kernel_size])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.transpose(x, [0, 2, 1]), 1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_117": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_152": {
                "indices": {
                    "value": "decode_loop_step + self._kernel_size - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_cache.get_shape().as_list()[1]",
                            "Subscript"
                        ],
                        [
                            "_cache.get_shape().as_list()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_106": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "x[:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[0, 0], [self._kernel_size - 1, 0], [0, 0]], mode='CONSTANT', constant_values=0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([cache['conv'], x], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['conv'][:, -self._kernel_size:, :]",
                            "Subscript"
                        ],
                        [
                            "cache['conv'][:, decode_loop_step:self._kernel_size + decode_loop_step, :]",
                            "Subscript"
                        ],
                        [
                            "self._dense1(inputs)",
                            "Call"
                        ],
                        [
                            "x * tf.expand_dims(1.0 - inputs_padding, 2)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/attentions/multi_head_attention.py": {
        "tensorflow": {
            "einsum_132": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "BTNH,BFNH->BNFT",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([cache['keys'], k], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['keys'][:, :decode_loop_step + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "q",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._q_transform_layer(query)",
                            "Call"
                        ],
                        [
                            "q * (self._attention_key_depth // self._num_heads) ** (-0.5)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_182": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(query, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_193": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.quant(tf.nn.softmax(logits), name='softmax')",
                            "Call"
                        ],
                        [
                            "self.att_fn(q, k, memory_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(weights, rate=self._attention_dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._attention_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_207": {
                "variable": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.quant(tf.einsum('BNFT,BTNH->BFNH', weights, v), name='output')",
                            "Call"
                        ],
                        [
                            "self._output_transform_layer(attention_output)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(attention_output, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "einsum_200": {
                "equation": {
                    "value": "BNFT,BTNH->BFNH",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.quant(tf.nn.softmax(logits), name='softmax')",
                            "Call"
                        ],
                        [
                            "self.att_fn(q, k, memory_bias)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(weights, rate=self._attention_dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([cache['values'], v], axis=1)",
                            "Call"
                        ],
                        [
                            "cache['values'][:, :decode_loop_step + 1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_259": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[cache['keys'], k]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_260": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[cache['values'], v]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_136": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(bias, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_145": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('BTNH,BFNH->BNFT', k, q)",
                            "Call"
                        ],
                        [
                            "logits + bias",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_267": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.one_hot(decode_loop_step, size, dtype=_new_val.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_137": {
                "input": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(bias, axis=1), axis=1)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_267": {
                "indices": {
                    "value": "decode_loop_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "depth": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_cache.get_shape().as_list()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "_new_val.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/auto_pretrained_layer.py": {
        "tensorflow": {}
    },
    "neurst/layers/common_layers.py": {
        "tensorflow": {
            "LayerNormalization_61": {
                "variable": {
                    "value": "self._norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "self._epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "flatten_192": {
                "variable": {
                    "value": "self._flatten_output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "structure": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_255": {
                "variable": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.keras.backend.reshape(self.quant_weight(self._kernel), self.kernel_shape)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_282": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_structure_286": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: self.quant(x, name='output')",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_398": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.sin(scaled_time), tf.cos(scaled_time)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_399": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.sin(scaled_time), tf.cos(scaled_time)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.pad(signal, [[0, 0], [0, tf.math.mod(channels, 2)]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(signal, [1, length, channels])",
                            "Call"
                        ],
                        [
                            "tf.reshape(signal, [1, channels])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, tf.math.mod(channels, 2)]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_151": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_263": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abcd,cde->abe",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.keras.backend.reshape(self.quant_weight(self._kernel), self.kernel_shape), inputs.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_269": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abc,cd->abd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.keras.backend.reshape(self.quant_weight(self._kernel), self.kernel_shape), inputs.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_274": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._flatten_output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "map_structure_277": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self._flatten_output_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_structure_284": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "self._activation_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                }
            },
            "pack_sequence_as_288": {
                "structure": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv1(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._conv2(output)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "tf.split(output, self._flatten_output_units, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: tf.reshape(x, tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)), output, self._flatten_output_units)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x: self.quant(x, name='output'), output)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_385": {
                "variable": {
                    "value": "position",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(length)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.dtype.base_dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "reshape_401": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.sin(scaled_time), tf.cos(scaled_time)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.pad(signal, [[0, 0], [0, tf.math.mod(channels, 2)]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(signal, [1, length, channels])",
                            "Call"
                        ],
                        [
                            "tf.reshape(signal, [1, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, length, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_403": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([tf.sin(scaled_time), tf.cos(scaled_time)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.pad(signal, [[0, 0], [0, tf.math.mod(channels, 2)]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(signal, [1, length, channels])",
                            "Call"
                        ],
                        [
                            "tf.reshape(signal, [1, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_427": {
                "variable": {
                    "value": "position_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.quant(self._position_emb_table, name='weights')",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.convert_to_tensor(time, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_76": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm_layer(inputs)",
                            "Call"
                        ],
                        [
                            "self.quant(y, name='ln')",
                            "Call"
                        ],
                        [
                            "self._layer(y, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "self._layer(inputs, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(y, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(y, rate=self._dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_83": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm_layer(inputs)",
                            "Call"
                        ],
                        [
                            "self.quant(y, name='ln')",
                            "Call"
                        ],
                        [
                            "self._layer(y, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "self._layer(inputs, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(y, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(y, rate=self._dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_255": {
                "tensor": {
                    "value": "self.quant_weight(self._kernel)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.kernel_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_331": {
                "name": {
                    "value": "position_embeddings",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_388": {
                "variable": {
                    "value": "position",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(time, time + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.dtype.base_dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "exp_395": {
                "x": {
                    "value": "tf.cast(tf.range(num_timescales), dtype=dtype) * -log_timescale_increment",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_397": {
                "input": {
                    "value": "inv_timescales",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min_timescale * tf.exp(tf.cast(tf.range(num_timescales), dtype=dtype) * -log_timescale_increment)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "slice_430": {
                "variable": {
                    "value": "position_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "self.quant(self._position_emb_table, name='weights')",
                    "type": "Call",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.shape(emb)[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_434": {
                "input": {
                    "value": "position_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(self.quant(self._position_emb_table, name='weights'), tf.convert_to_tensor(time, dtype=tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.slice(self.quant(self._position_emb_table, name='weights'), [0, 0], [tf.shape(emb)[1], -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_nested_194": {
                "seq": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_384": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_394": {
                "x": {
                    "value": "num_timescales",
                    "type": "variable",
                    "possible_values": [
                        [
                            "channels // 2",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.dtype.base_dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "sin_398": {
                "x": {
                    "value": "scaled_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(position, 1) * tf.expand_dims(inv_timescales, 0)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cos_398": {
                "x": {
                    "value": "scaled_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(position, 1) * tf.expand_dims(inv_timescales, 0)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "convert_to_tensor_428": {
                "value": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_278": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.concat([tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_396": {
                "x": {
                    "value": "tf.range(num_timescales)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.dtype.base_dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mod_399": {
                "x1": {
                    "value": "channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.get_shape().as_list()[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "x2": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_279": {
                "values": {
                    "value": "[tf.shape(x)[:-1], [self._num_heads, num_units // self._num_heads]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_normal_initializer_336": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self._embedding_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_343": {
                "value": {
                    "value": "self.add_sinusoids_timing_signal(tf.zeros([1, self._max_positions, self._embedding_dim]), None).numpy()[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_431": {
                "input": {
                    "value": "emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._embedding_layer(inputs, **kwargs)",
                            "Call"
                        ],
                        [
                            "emb * self._embedding_dim ** 0.5",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_279": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_345": {
                "shape": {
                    "value": "[1, self._max_positions, self._embedding_dim]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/decoders/light_convolution_decoder.py": {
        "tensorflow": {
            "LayerNormalization_121": {
                "variable": {
                    "value": "self._output_norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "params['layer_postprocess_epsilon']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.get_config()",
                            "Call"
                        ],
                        [
                            "self.get_config()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "output_ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_194": {
                "variable": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(decoder_inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_198": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(decoder_inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.get_config()['layer_postprocess_dropout_rate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_224": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._output_norm_layer(x)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(outputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_155": {
                "input": {
                    "value": "encoder_outputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_207": {
                "name": {
                    "value": "layer_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'layer_{}'.format(idx)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_165": {
                "shape": {
                    "value": "[batch_size, init_len, params['conv_hidden_size']]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/decoders/transformer_decoder.py": {
        "tensorflow": {
            "LayerNormalization_119": {
                "variable": {
                    "value": "self._output_norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "params['layer_postprocess_epsilon']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.get_config()",
                            "Call"
                        ],
                        [
                            "self.get_config()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "output_ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_193": {
                "variable": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(decoder_inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dropout_200": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(decoder_inputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.get_config()['layer_postprocess_dropout_rate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "squeeze_230": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Name"
                        ],
                        [
                            "self.quant(self._output_norm_layer(x), name='output_ln')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(outputs, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_152": {
                "input": {
                    "value": "encoder_outputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_197": {
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(decoder_inputs, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_209": {
                "name": {
                    "value": "layer_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'layer_{}'.format(idx)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_160": {
                "shape": {
                    "value": "[batch_size, decode_padded_length or 0, num_heads, num_units_per_head]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_162": {
                "shape": {
                    "value": "[batch_size, decode_padded_length or 0, num_heads, num_units_per_head]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/encoders/light_convolution_encoder.py": {
        "tensorflow": {
            "LayerNormalization_101": {
                "variable": {
                    "value": "self._output_norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "params['layer_postprocess_epsilon']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.get_config()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "output_ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_123": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.nn.dropout(x, rate=self.get_config()['layer_postprocess_dropout_rate'])",
                            "Call"
                        ],
                        [
                            "conv_layer(x, inputs_padding=inputs_padding, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "ffn_layer(x, is_training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.get_config()['layer_postprocess_dropout_rate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "name_scope_128": {
                "name": {
                    "value": "'layer_{}'.format(idx)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/encoders/transformer_encoder.py": {
        "tensorflow": {
            "LayerNormalization_106": {
                "variable": {
                    "value": "self._output_norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "params['layer_postprocess_epsilon']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "self.get_config()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "output_ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_131": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.nn.dropout(x, rate=self.get_config()['layer_postprocess_dropout_rate'])",
                            "Call"
                        ],
                        [
                            "self_attention_layer(x, bias=self_attention_bias, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "ffn_layer(x, is_training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.get_config()['layer_postprocess_dropout_rate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "name_scope_136": {
                "name": {
                    "value": "'layer_{}'.format(idx)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/layer_utils.py": {
        "tensorflow": {
            "shape_72": {
                "variable": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_73": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_76": {
                "variable": {
                    "value": "tiled_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tile_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] * x.shape.ndims",
                            "BinOp"
                        ],
                        [
                            "[1] * tensor.get_shape().ndims",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_77": {
                "variable": {
                    "value": "tiled_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[[-1], original_shape[1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_87": {
                "variable": {
                    "value": "dynamic_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensor, axis=axis)",
                            "Call"
                        ]
                    ]
                }
            },
            "one_hot_128": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[on_entry]",
                    "type": "List",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_entries",
                    "type": "variable",
                    "possible_values": []
                },
                "on_value": {
                    "value": "tf.convert_to_tensor(on_value, dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "off_value": {
                    "value": "tf.convert_to_tensor(off_value, dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_154": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensor, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "transpose_175": {
                "variable": {
                    "value": "batch_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "batch_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tile_tensor(tf.range(batch_size), k)",
                            "Call"
                        ],
                        [
                            "tf.transpose(batch_pos)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_49": {
                "variable": {
                    "value": "lower_triangle",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.linalg.band_part(tf.ones([length, length]), -1, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_51": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "compat.FLOAT_MIN * (1.0 - lower_triangle)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, length, length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_78": {
                "tensor": {
                    "value": "tiled_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(x, tile_dims)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tiled_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([[-1], original_shape[1:]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_96": {
                "dims": {
                    "value": "tensor.get_shape().as_list()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorShape_108": {
                "dims": {
                    "value": "shape_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "static_shape_list(tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_133": {
                "input": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_padding * compat.FLOAT_MIN",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(compat.FLOAT_MIN * (1.0 - lower_triangle), [1, 1, length, length])",
                            "Call"
                        ],
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=tf.convert_to_tensor(on_value, dtype=dtype), off_value=tf.convert_to_tensor(off_value, dtype=dtype), dtype=tf.dtypes.as_dtype(dtype))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_157": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensor, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tile_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] * x.shape.ndims",
                            "BinOp"
                        ],
                        [
                            "[1] * tensor.get_shape().ndims",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_30": {
                "name": {
                    "value": "attention_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_48": {
                "name": {
                    "value": "decoder_self_attention_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "band_part_50": {
                "input": {
                    "value": "tf.ones([length, length])",
                    "type": "Call",
                    "possible_values": []
                },
                "num_lower": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "num_upper": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_130": {
                "value": {
                    "value": "on_value",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_131": {
                "value": {
                    "value": "off_value",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "as_dtype_132": {
                "type_value": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_50": {
                "shape": {
                    "value": "[length, length]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/metric_layers/metric_layer.py": {
        "tensorflow": {
            "Sum_31": {
                "variable": {
                    "value": "self._layer_metrics[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Mean_33": {
                "variable": {
                    "value": "self._layer_metrics[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/metric_layers/token_metric_layers.py": {
        "tensorflow": {
            "reduce_sum_40": {
                "variable": {
                    "value": "x_len",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(input[self._name_prefix + '_length'], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_35": {
                "x": {
                    "value": "tf.shape(x)[0] * tf.shape(x)[1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_62": {
                "x": {
                    "value": "tf.shape(x)[0] * tf.shape(x)[1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_63": {
                "x": {
                    "value": "tf.reduce_sum(x_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_81": {
                "x": {
                    "value": "tf.shape(x)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_37": {
                "x": {
                    "value": "tf.reduce_sum(input[self._name_prefix + '_padding'])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_40": {
                "x": {
                    "value": "input[self._name_prefix + '_length']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_63": {
                "input_tensor": {
                    "value": "x_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ms[self._name_prefix + '_tokens'] - tf.cast(tf.reduce_sum(input[self._name_prefix + '_padding']), tf.float32)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(tf.cast(input[self._name_prefix + '_length'], tf.float32))",
                            "Call"
                        ],
                        [
                            "input[self._name_prefix + '_length']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_38": {
                "input_tensor": {
                    "value": "input[self._name_prefix + '_padding']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_81": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input[self._name_prefix]",
                            "Subscript"
                        ],
                        [
                            "input[self._name_prefix]",
                            "Subscript"
                        ],
                        [
                            "input[self._key]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_35": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input[self._name_prefix]",
                            "Subscript"
                        ],
                        [
                            "input[self._name_prefix]",
                            "Subscript"
                        ],
                        [
                            "input[self._key]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_62": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input[self._name_prefix]",
                            "Subscript"
                        ],
                        [
                            "input[self._name_prefix]",
                            "Subscript"
                        ],
                        [
                            "input[self._key]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/layers/modalities/audio_modalities.py": {
        "tensorflow": {
            "Conv2D_60": {
                "variable": {
                    "value": "self._conv_layer1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "filters": {
                    "value": "self._channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(self._kernel_size, self._kernel_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(self._strides, self._strides)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "conv1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Conv2D_67": {
                "variable": {
                    "value": "self._conv_layer2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "filters": {
                    "value": "self._channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(self._kernel_size, self._kernel_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(self._strides, self._strides)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "conv2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_79": {
                "variable": {
                    "value": "self._dense_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "self._embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "output_dense",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_103": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer1(tf.pad(inputs, manual_padding))",
                            "Call"
                        ],
                        [
                            "self._norm_layer1(conv1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv1)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_107": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer2(tf.pad(conv1, manual_padding))",
                            "Call"
                        ],
                        [
                            "self._norm_layer2(conv2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv2)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_110": {
                "variable": {
                    "value": "conv2_reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer2(tf.pad(conv1, manual_padding))",
                            "Call"
                        ],
                        [
                            "self._norm_layer2(conv2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(conv2)[:2], [new_feature_dim]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Conv1D_218": {
                "variable": {
                    "value": "self._conv_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "filters": {
                    "value": "self._dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self._kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "self._stride",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "self._use_bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.keras.initializers.HeNormal()",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_308": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs * (1.0 - tf.expand_dims(tf.cast(inputs_padding, dtype=inputs.dtype), -1))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "LayerNormalization_424": {
                "variable": {
                    "value": "self._norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_440": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs * (1.0 - tf.expand_dims(tf.cast(inputs_padding, dtype=inputs.dtype), -1))",
                            "BinOp"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [padding_num, padding_num], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "LayerNormalization_75": {
                "variable": {
                    "value": "self._norm_layer1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ln1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LayerNormalization_77": {
                "variable": {
                    "value": "self._norm_layer2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ln2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LayerNormalization_225": {
                "variable": {
                    "value": "self._norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dropout_245": {
                "variable": {
                    "value": "conv_out",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "conv_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(conv_out, rate=self._dropout_rate)",
                            "Call"
                        ],
                        [
                            "self._norm_layer(conv_out)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_445": {
                "variable": {
                    "value": "x_conv",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x_conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._pos_conv(x)[:, :tf.shape(inputs)[1] - self._kernel_size % 2, :]",
                            "Subscript"
                        ],
                        [
                            "gelu(x_conv, non_approximate=True) + inputs",
                            "BinOp"
                        ],
                        [
                            "self._norm_layer(x_conv)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x_conv, self._dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pad_100": {
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs * (1.0 - tf.expand_dims(tf.cast(inputs_padding, dtype=inputs.dtype), -1))",
                            "BinOp"
                        ]
                    ]
                },
                "paddings": {
                    "value": "manual_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [self._kernel_size // 2, self._kernel_size // 2], [self._kernel_size // 2, self._kernel_size // 2], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [self._kernel_sizes[i] // 2, self._kernel_sizes[i] // 2], [0, 0]]",
                            "List"
                        ]
                    ]
                }
            },
            "pad_104": {
                "tensor": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer1(tf.pad(inputs, manual_padding))",
                            "Call"
                        ],
                        [
                            "self._norm_layer1(conv1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv1)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "manual_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [self._kernel_size // 2, self._kernel_size // 2], [self._kernel_size // 2, self._kernel_size // 2], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [self._kernel_sizes[i] // 2, self._kernel_sizes[i] // 2], [0, 0]]",
                            "List"
                        ]
                    ]
                }
            },
            "concat_110": {
                "values": {
                    "value": "[tf.shape(conv2)[:2], [new_feature_dim]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_338": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorShape(input_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "InputSpec_339": {
                "variable": {
                    "value": "self.input_spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None] + input_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_376": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "self._initialized",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_do_nothing",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_update_weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Conv1D_419": {
                "filters": {
                    "value": "self._dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self._kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "groups": {
                    "value": "self._groups",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.initializers.random_normal(mean=0, stddev=math.sqrt(4.0 / (self._kernel_size * self._dim)))",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_178": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "conv(tf.pad(x, manual_padding))",
                            "Call"
                        ],
                        [
                            "layer_norm(x)",
                            "Call"
                        ],
                        [
                            "gelu(x, non_approximate=True)",
                            "Call"
                        ],
                        [
                            "drop_layer(x, training=kwargs.get('is_training', False))",
                            "Call"
                        ],
                        [
                            "tf.pad(inputs, [[0, 0], [padding_num, padding_num], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "manual_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [self._kernel_size // 2, self._kernel_size // 2], [self._kernel_size // 2, self._kernel_size // 2], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [self._kernel_sizes[i] // 2, self._kernel_sizes[i] // 2], [0, 0]]",
                            "List"
                        ]
                    ]
                }
            },
            "HeNormal_221": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_380": {
                "a": {
                    "value": "self.v",
                    "type": "Attribute",
                    "possible_values": []
                },
                "perm": {
                    "value": "[2, 1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_383": {
                "variable": {
                    "value": "update_kernel",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.layer.kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_391": {
                "dims": {
                    "value": "self.layer.compute_output_shape(input_shape).as_list()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_413": {
                "variable": {
                    "value": "v_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.v",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self.layer_depth]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "norm_414": {
                "variable": {
                    "value": "v_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "v_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(self.v, [-1, self.layer_depth])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv1D_151": {
                "filters": {
                    "value": "self._channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self._kernel_sizes[idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "strides": {
                    "value": "self._strides[idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "name": {
                    "value": "f'conv{idx}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "identity_369": {
                "input": {
                    "value": "self.g",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_378": {
                "name": {
                    "value": "compute_weights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "control_dependencies_399": {
                "control_inputs": {
                    "value": "[tf.debugging.assert_equal(self._initialized, False, message='The layer has been initialized.')]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_412": {
                "name": {
                    "value": "init_norm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_438": {
                "input": {
                    "value": "tf.cast(inputs_padding, dtype=inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_110": {
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer2(tf.pad(conv1, manual_padding))",
                            "Call"
                        ],
                        [
                            "self._norm_layer2(conv2)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(conv2)",
                            "Call"
                        ]
                    ]
                }
            },
            "LayerNormalization_159": {
                "epsilon": {
                    "value": "1e-06",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "f'ln{idx}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "Dropout_163": {
                "rate": {
                    "value": "self._layer_dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_373": {
                "control_inputs": {
                    "value": "self._initialize_weights(inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_374": {
                "input": {
                    "value": "self.g",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_386": {
                "control_inputs": {
                    "value": "[update_kernel]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_415": {
                "x": {
                    "value": "tf.reshape(v_norm, (self.layer_depth,))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_438": {
                "x": {
                    "value": "inputs_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "l2_normalize_380": {
                "x": {
                    "value": "tf.transpose(self.v, [2, 1, 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "self.kernel_norm_axes",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assert_equal_401": {
                "x": {
                    "value": "self._initialized",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "message": {
                    "value": "The layer has been initialized.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_415": {
                "tensor": {
                    "value": "v_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.norm(v_flat, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(self.layer_depth,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "shape_441": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs * (1.0 - tf.expand_dims(tf.cast(inputs_padding, dtype=inputs.dtype), -1))",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/layers/modalities/text_modalities.py": {
        "tensorflow": {
            "gather_91": {
                "variable": {
                    "value": "emb",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.quant_weight(self._shared_weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_102": {
                "variable": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_103": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.reshape(x, [-1, self._embedding_dim])",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "tf.cast(self.quant_weight(self._shared_weights), x.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_193": {
                "variable": {
                    "value": "flat_token_type_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_194": {
                "variable": {
                    "value": "one_hot_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_token_type_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tokens_type, [-1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_195": {
                "variable": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.cast(one_hot_ids, self._emb_table.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._emb_table",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_197": {
                "variable": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.cast(one_hot_ids, self._emb_table.dtype), self._emb_table)",
                            "Call"
                        ],
                        [
                            "tf.reshape(token_type_embeddings, tf.concat([tf.shape(inputs), [self.embedding_dim]], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.cast(one_hot_ids, self._token_type_embedding.dtype), self._token_type_embedding)",
                            "Call"
                        ],
                        [
                            "tf.reshape(token_type_embeddings, tf.concat([tf.shape(tokens_type), [self.embedding_dim]], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(inputs), [self.embedding_dim]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "LayerNormalization_256": {
                "variable": {
                    "value": "self._norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "self._epsilon",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ln",
                    "type": "str",
                    "possible_values": []
                }
            },
            "gather_271": {
                "variable": {
                    "value": "embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self._word_embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "tokens",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reshape_276": {
                "variable": {
                    "value": "flat_token_type_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tokens_type",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(tokens, dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_277": {
                "variable": {
                    "value": "one_hot_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "flat_token_type_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tokens_type, [-1])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.token_types",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_278": {
                "variable": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.cast(one_hot_ids, self._token_type_embedding.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._token_type_embedding",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_280": {
                "variable": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "token_type_embeddings",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.cast(one_hot_ids, self._emb_table.dtype), self._emb_table)",
                            "Call"
                        ],
                        [
                            "tf.reshape(token_type_embeddings, tf.concat([tf.shape(inputs), [self.embedding_dim]], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.cast(one_hot_ids, self._token_type_embedding.dtype), self._token_type_embedding)",
                            "Call"
                        ],
                        [
                            "tf.reshape(token_type_embeddings, tf.concat([tf.shape(tokens_type), [self.embedding_dim]], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(tokens_type), [self.embedding_dim]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_282": {
                "variable": {
                    "value": "position_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.slice(self._position_embedding, [0, 0], [tf.shape(tokens)[1], -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_111": {
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.reshape(x, [-1, self._embedding_dim]), tf.cast(self.quant_weight(self._shared_weights), x.dtype), transpose_b=True)",
                            "Call"
                        ],
                        [
                            "logits + self._bias",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([original_shape[:-1], [self._vocab_size]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_275": {
                "variable": {
                    "value": "tokens_type",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tokens",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_286": {
                "variable": {
                    "value": "bert_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bert_emb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm_layer(embeddings + token_type_embeddings + position_embeddings)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(bert_emb, rate=self._dropout_rate)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_67": {
                "name": {
                    "value": "scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'shared'",
                            "Constant"
                        ],
                        [
                            "'emb'",
                            "Constant"
                        ]
                    ]
                }
            },
            "reshape_103": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self._embedding_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_104": {
                "x": {
                    "value": "self.quant_weight(self._shared_weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "x.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_111": {
                "values": {
                    "value": "[original_shape[:-1], [self._vocab_size]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_172": {
                "name": {
                    "value": "token_type_emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_195": {
                "x": {
                    "value": "one_hot_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(flat_token_type_ids, depth=self.vocab_size)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(flat_token_type_ids, depth=self.token_types)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self._emb_table.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_198": {
                "values": {
                    "value": "[tf.shape(inputs), [self.embedding_dim]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_278": {
                "x": {
                    "value": "one_hot_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(flat_token_type_ids, depth=self.vocab_size)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(flat_token_type_ids, depth=self.token_types)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self._token_type_embedding.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_281": {
                "values": {
                    "value": "[tf.shape(tokens_type), [self.embedding_dim]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "slice_282": {
                "input_": {
                    "value": "self._position_embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[tf.shape(tokens)[1], -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_normal_initializer_242": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self._embedding_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_248": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self._embedding_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_253": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self._embedding_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_72": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self._embedding_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_177": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self._embedding_dim ** (-0.5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_198": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_281": {
                "input": {
                    "value": "tokens_type",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(tokens, dtype=tf.int64)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_283": {
                "input": {
                    "value": "tokens",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/quantization/quant_dense_layer.py": {
        "tensorflow": {
            "cast_36": {
                "variable": {
                    "value": "self.kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.quant_weight(self.v)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/quantization/quant_layers.py": {
        "tensorflow": {
            "cast_161": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(inputs, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_164": {
                "variable": {
                    "value": "weight_clip_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.clip_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_165": {
                "variable": {
                    "value": "weight_clip_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight_clip_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "super(QuantLayer, self).add_weight(name=name + '_clip_max', trainable=True, regularizer=tf.keras.regularizers.l2(l=0.001), initializer=tf.constant_initializer(QuantLayer.quant_weight_clip_max), aggregation=tf.VariableAggregation.MEAN)",
                            "Call"
                        ],
                        [
                            "tf.maximum(self.clip_max, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(weight_clip_max, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_171": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_quant_tensor(inputs, weight_clip_min, weight_clip_max)",
                            "Call"
                        ],
                        [
                            "tf.cast(outputs, dtype)",
                            "Call"
                        ],
                        [
                            "_quant_tensor(inputs, activation_clip_min, activation_clip_max)",
                            "Call"
                        ],
                        [
                            "tf.cast(outputs, dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_187": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(inputs, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_205": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_quant_tensor(inputs, weight_clip_min, weight_clip_max)",
                            "Call"
                        ],
                        [
                            "tf.cast(outputs, dtype)",
                            "Call"
                        ],
                        [
                            "_quant_tensor(inputs, activation_clip_min, activation_clip_max)",
                            "Call"
                        ],
                        [
                            "tf.cast(outputs, dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.dtype",
                            "Attribute"
                        ],
                        [
                            "inputs.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "fake_quant_with_min_max_vars_147": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(inputs, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(inputs, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "min": {
                    "value": "min_w",
                    "type": "variable",
                    "possible_values": []
                },
                "max": {
                    "value": "max_w",
                    "type": "variable",
                    "possible_values": []
                },
                "num_bits": {
                    "value": "QuantLayer.quant_bits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_190": {
                "variable": {
                    "value": "activation_clip_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.activation_clip_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_191": {
                "variable": {
                    "value": "activation_clip_max",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "activation_clip_max",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "super(QuantLayer, self).add_weight(name=name + '_clip_max', trainable=True, regularizer=tf.keras.regularizers.l2(l=0.01), initializer=tf.constant_initializer(QuantLayer.quant_act_clip_max), aggregation=tf.VariableAggregation.MEAN)",
                            "Call"
                        ],
                        [
                            "tf.maximum(self.activation_clip_max, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(activation_clip_max, tf.float32)",
                            "Call"
                        ],
                        [
                            "float(2 ** quant_bits - 1) / 2 ** quant_bits",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_75": {
                "value": {
                    "value": "QuantLayer.quant_weight_clip_max",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_96": {
                "value": {
                    "value": "QuantLayer.quant_act_clip_max",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/search/beam_search.py": {
        "tensorflow": {
            "flatten_95": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_117": {
                "variable": {
                    "value": "prev_finished_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "state[_StateKeys.FINISHED_FLAGS]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "log_probs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_182": {
                "tensor": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_probs * tf.expand_dims(penalty_term, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(tf.reshape(scores, [-1]), [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "log_probs * penalty",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_184": {
                "variable": {
                    "value": "scores_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "state[_StateKeys.TIME_STEP] > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : scores",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.slice(scores, [0, 0], [-1, vocab_size])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "top_k_190": {
                "variable": {
                    "value": "(sample_scores, sample_ids)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "scores_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cond(state[_StateKeys.TIME_STEP] > 0, lambda : scores, lambda : tf.slice(scores, [0, 0], [-1, vocab_size]))",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "beam_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_192": {
                "variable": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sample_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "floormod_195": {
                "variable": {
                    "value": "word_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sample_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits[0].get_shape().as_list()[-1]",
                            "Subscript"
                        ],
                        [
                            "log_probs.get_shape().as_list()[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_201": {
                "variable": {
                    "value": "beam_base_pos",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "batch_pos * beam_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_206": {
                "variable": {
                    "value": "next_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "next_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state[_StateKeys.DECODING_LENGTH] + 1 - tf.cast(state[_StateKeys.FINISHED_FLAGS], tf.int32)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "beam_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floordiv(sample_ids, vocab_size) + beam_base_pos",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_210": {
                "variable": {
                    "value": "log_probs_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits[0])",
                            "Call"
                        ],
                        [
                            "tf.math.log(tf.reshape(probs, original_shape))",
                            "Call"
                        ],
                        [
                            "log_probs * tf.expand_dims(1.0 - prev_finished_float, 1) + finished_beam_bias",
                            "BinOp"
                        ],
                        [
                            "log_probs + unk_beam_bias",
                            "BinOp"
                        ],
                        [
                            "log_probs + tf.expand_dims(state[_StateKeys.LOG_PROBS], 1)",
                            "BinOp"
                        ],
                        [
                            "state[_StateKeys.LOG_PROBS]",
                            "Subscript"
                        ],
                        [
                            "_calculate_log_probs(state=state, symbols_to_logits_fn=symbols_to_logits_fn, eos_id=eos_id, unk_id=unk_id, ensemble_weights=ensemble_weights)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : log_probs + eos_beam_bias, lambda : log_probs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_212": {
                "variable": {
                    "value": "next_log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "log_probs_flat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(log_probs, [-1])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "log_probs_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "beam_base_pos * vocab_size + sample_ids",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_241": {
                "variable": {
                    "value": "scores_shaped",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_probs * tf.expand_dims(penalty_term, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(tf.reshape(scores, [-1]), [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "log_probs * penalty",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "top_k_243": {
                "variable": {
                    "value": "(top_scores, top_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "scores_shaped",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(scores, [-1, beam_size])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "top_k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_247": {
                "variable": {
                    "value": "top_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "top_indices + batch_beam_pos",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_249": {
                "variable": {
                    "value": "sorted_hypothesis",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "state[_StateKeys.PREDICTED_IDS]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "top_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(top_indices + batch_beam_pos, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_250": {
                "variable": {
                    "value": "sorted_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "top_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_313": {
                "variable": {
                    "value": "initial_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[False]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size * beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_315": {
                "variable": {
                    "value": "initial_time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_structure_316": {
                "variable": {
                    "value": "initial_cache",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: layer_utils.stack_beam_size(x, beam_size)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "decoding_cache",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['decoder_internal_cache']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "zeros_like_319": {
                "variable": {
                    "value": "initial_log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_decoder_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer_utils.stack_beam_size(decoder_input_ids, beam_size)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "zeros_like_321": {
                "variable": {
                    "value": "initial_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "initial_decoder_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer_utils.stack_beam_size(decoder_input_ids, beam_size)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_366": {
                "variable": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_maxlen + extra_decode_length",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "maximum_decode_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._maximum_decode_length",
                            "Attribute"
                        ],
                        [
                            "self._extra_decode_length + max_data_len",
                            "BinOp"
                        ],
                        [
                            "256",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "maximum_369": {
                "variable": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(encoder_inputs_maxlen + extra_decode_length, maximum_decode_length)",
                            "Call"
                        ],
                        [
                            "tf.maximum(maximum_search_steps, minimum_decode_length)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "minimum_decode_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "while_loop_414": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda state: tf.logical_and(tf.logical_not(tf.reduce_all(state[_StateKeys.FINISHED_FLAGS])), tf.less(state[_StateKeys.TIME_STEP], maximum_search_steps))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "search_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[search_state]",
                    "type": "List",
                    "possible_values": []
                },
                "shape_invariants": {
                    "value": "[search_state_shape_invariants]",
                    "type": "List",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_softmax_100": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "map_structure_102": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: tf.expand_dims(tf.reshape(tf.nn.softmax(x), shape=[-1]), axis=0)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_106": {
                "variable": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_108": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: tf.expand_dims(tf.reshape(tf.nn.softmax(x), shape=[-1]), axis=0), logits)",
                            "Call"
                        ],
                        [
                            "tf.concat(probs, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.matmul(weights, probs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_110": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.convert_to_tensor(ensemble_weights, dtype=probs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_113": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.convert_to_tensor(ensemble_weights, dtype=probs.dtype), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: tf.expand_dims(tf.reshape(tf.nn.softmax(x), shape=[-1]), axis=0), logits)",
                            "Call"
                        ],
                        [
                            "tf.concat(probs, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.matmul(weights, probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_114": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reshape(probs, original_shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_129": {
                "input": {
                    "value": "prev_finished_float",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(state[_StateKeys.FINISHED_FLAGS], log_probs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "as_dtype_311": {
                "variable": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": []
                },
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_324": {
                "variable": {
                    "value": "initial_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size * beam_size, maximum_decode_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_327": {
                "variable": {
                    "value": "initial_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size * beam_size, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_383": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : log_probs + eos_beam_bias",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : log_probs",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "gather_392": {
                "variable": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "state[_StateKeys.PREDICTED_IDS]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "beam_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floordiv(sample_ids, vocab_size) + beam_base_pos",
                            "BinOp"
                        ]
                    ]
                }
            },
            "map_structure_400": {
                "variable": {
                    "value": "next_cache",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: tf.gather(x, beam_ids)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "state[_StateKeys.CACHE]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "equal_402": {
                "variable": {
                    "value": "next_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "eos_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['eos_id']",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sample_ids, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_428": {
                "variable": {
                    "value": "sorted_hypothesis",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sorted_hypothesis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(state[_StateKeys.PREDICTED_IDS], top_indices)",
                            "Call"
                        ],
                        [
                            "tf.pad(sorted_hypothesis, paddings=tf.convert_to_tensor([[0, 0], [0, maximum_decode_length - res[_StateKeys.TIME_STEP]]], dtype=tf.int32), mode='CONSTANT', constant_values=eos_id)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.convert_to_tensor([[0, 0], [0, maximum_decode_length - res[_StateKeys.TIME_STEP]]], dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "eos_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['eos_id']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_97": {
                "input": {
                    "value": "logits[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_166": {
                "input": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits[0])",
                            "Call"
                        ],
                        [
                            "tf.math.log(tf.reshape(probs, original_shape))",
                            "Call"
                        ],
                        [
                            "log_probs * tf.expand_dims(1.0 - prev_finished_float, 1) + finished_beam_bias",
                            "BinOp"
                        ],
                        [
                            "log_probs + unk_beam_bias",
                            "BinOp"
                        ],
                        [
                            "log_probs + tf.expand_dims(state[_StateKeys.LOG_PROBS], 1)",
                            "BinOp"
                        ],
                        [
                            "state[_StateKeys.LOG_PROBS]",
                            "Subscript"
                        ],
                        [
                            "_calculate_log_probs(state=state, symbols_to_logits_fn=symbols_to_logits_fn, eos_id=eos_id, unk_id=unk_id, ensemble_weights=ensemble_weights)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : log_probs + eos_beam_bias, lambda : log_probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_171": {
                "input": {
                    "value": "state[_StateKeys.LOG_PROBS]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_173": {
                "x": {
                    "value": "state[_StateKeys.FINISHED_FLAGS]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_179": {
                "input": {
                    "value": "penalty_term",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_calculate_length_penalty(next_length, length_penalty, dtype=log_probs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "floordiv_203": {
                "x": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sample_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits[0].get_shape().as_list()[-1]",
                            "Subscript"
                        ],
                        [
                            "log_probs.get_shape().as_list()[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_312": {
                "input": {
                    "value": "decoder_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['decoder_input']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_332": {
                "x": {
                    "value": "initial_decoder_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer_utils.stack_beam_size(decoder_input_ids, beam_size)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_394": {
                "variable": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.tensor_scatter_nd_update(tf.transpose(next_predicted_ids), [[state[_StateKeys.TIME_STEP]]], tf.expand_dims(sample_ids, axis=0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_398": {
                "variable": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[next_predicted_ids, tf.expand_dims(sample_ids, axis=1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_39": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cast_39": {
                "x": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_111": {
                "value": {
                    "value": "ensemble_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "probs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_114": {
                "tensor": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: tf.expand_dims(tf.reshape(tf.nn.softmax(x), shape=[-1]), axis=0), logits)",
                            "Call"
                        ],
                        [
                            "tf.concat(probs, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.matmul(weights, probs)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "original_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(logits[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_131": {
                "input": {
                    "value": "1.0 - prev_finished_float",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "slice_187": {
                "input_": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_probs * tf.expand_dims(penalty_term, axis=1)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(tf.reshape(scores, [-1]), [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "log_probs * penalty",
                            "BinOp"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[-1, vocab_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_346": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_347": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_structure_348": {
                "func": {
                    "value": "layer_utils.static_tensorshape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "initial_cache",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: layer_utils.stack_beam_size(x, beam_size), decoding_cache)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_350": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_351": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_352": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_353": {
                "dims": {
                    "value": "[None, maximum_decode_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_357": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_358": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_structure_359": {
                "func": {
                    "value": "layer_utils.dynamic_tensorshape_except_last_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "initial_cache",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: layer_utils.stack_beam_size(x, beam_size), decoding_cache)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_361": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_362": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_363": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_364": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_383": {
                "x": {
                    "value": "state[_StateKeys.TIME_STEP]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "minimum_decode_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_415": {
                "x": {
                    "value": "tf.logical_not(tf.reduce_all(state[_StateKeys.FINISHED_FLAGS]))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(state[_StateKeys.TIME_STEP], maximum_search_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_531": {
                "name": {
                    "value": "beam_search",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_40": {
                "x": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "expand_dims_103": {
                "input": {
                    "value": "tf.reshape(tf.nn.softmax(x), shape=[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_245": {
                "input": {
                    "value": "top_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(top_indices + batch_beam_pos, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_382": {
                "input": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.log_softmax(logits[0])",
                            "Call"
                        ],
                        [
                            "tf.math.log(tf.reshape(probs, original_shape))",
                            "Call"
                        ],
                        [
                            "log_probs * tf.expand_dims(1.0 - prev_finished_float, 1) + finished_beam_bias",
                            "BinOp"
                        ],
                        [
                            "log_probs + unk_beam_bias",
                            "BinOp"
                        ],
                        [
                            "log_probs + tf.expand_dims(state[_StateKeys.LOG_PROBS], 1)",
                            "BinOp"
                        ],
                        [
                            "state[_StateKeys.LOG_PROBS]",
                            "Subscript"
                        ],
                        [
                            "_calculate_log_probs(state=state, symbols_to_logits_fn=symbols_to_logits_fn, eos_id=eos_id, unk_id=unk_id, ensemble_weights=ensemble_weights)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : log_probs + eos_beam_bias, lambda : log_probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_scatter_nd_update_394": {
                "tensor": {
                    "value": "tf.transpose(next_predicted_ids)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[state[_StateKeys.TIME_STEP]]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.expand_dims(sample_ids, axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_401": {
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "beam_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floordiv(sample_ids, vocab_size) + beam_base_pos",
                            "BinOp"
                        ]
                    ]
                }
            },
            "logical_not_416": {
                "x": {
                    "value": "tf.reduce_all(state[_StateKeys.FINISHED_FLAGS])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_417": {
                "x": {
                    "value": "state[_StateKeys.TIME_STEP]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(encoder_inputs_maxlen + extra_decode_length, maximum_decode_length)",
                            "Call"
                        ],
                        [
                            "tf.maximum(maximum_search_steps, minimum_decode_length)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_430": {
                "value": {
                    "value": "[[0, 0], [0, maximum_decode_length - res[_StateKeys.TIME_STEP]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_104": {
                "tensor": {
                    "value": "tf.nn.softmax(x)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_395": {
                "a": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(state[_StateKeys.PREDICTED_IDS], beam_ids)",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.tensor_scatter_nd_update(tf.transpose(next_predicted_ids), [[state[_StateKeys.TIME_STEP]]], tf.expand_dims(sample_ids, axis=0)))",
                            "Call"
                        ],
                        [
                            "tf.concat([next_predicted_ids, tf.expand_dims(sample_ids, axis=1)], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_396": {
                "input": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sample_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_398": {
                "input": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(sample_ids, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_all_416": {
                "input_tensor": {
                    "value": "state[_StateKeys.FINISHED_FLAGS]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_104": {
                "logits": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/search/sampling.py": {
        "tensorflow": {
            "top_k_81": {
                "variable": {
                    "value": "(values, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sort_88": {
                "variable": {
                    "value": "sorted_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                },
                "direction": {
                    "value": "DESCENDING",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cumsum_89": {
                "variable": {
                    "value": "cumulative_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.nn.softmax(sorted_logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_91": {
                "variable": {
                    "value": "min_value",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_92": {
                "variable": {
                    "value": "applyed_sorted_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "t_sorted_indices_to_remove",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cumulative_probs < p",
                            "Compare"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.ones_like(sorted_logits, dtype=sorted_logits.dtype) * min_value",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "sorted_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(logits, direction='DESCENDING')",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_97": {
                "variable": {
                    "value": "threshold",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_max(applyed_sorted_logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_155": {
                "variable": {
                    "value": "initial_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[False]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size * sample_num]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_157": {
                "variable": {
                    "value": "initial_time",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_structure_158": {
                "variable": {
                    "value": "initial_cache",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x: layer_utils.stack_beam_size(x, sample_num)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "decoding_cache",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['decoder_internal_cache']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "minimum_202": {
                "variable": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "encoder_inputs_maxlen + extra_decode_length",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "maximum_decode_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._maximum_decode_length",
                            "Attribute"
                        ],
                        [
                            "self._extra_decode_length + max_data_len",
                            "BinOp"
                        ],
                        [
                            "256",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "maximum_204": {
                "variable": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(encoder_inputs_maxlen + extra_decode_length, maximum_decode_length)",
                            "Call"
                        ],
                        [
                            "tf.maximum(maximum_search_steps, minimum_decode_length)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "minimum_decode_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "while_loop_249": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda state: tf.logical_and(tf.logical_not(tf.reduce_all(state[_StateKeys.FINISHED_FLAGS])), tf.less(state[_StateKeys.TIME_STEP], maximum_search_steps))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "search_step",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[search_state]",
                    "type": "List",
                    "possible_values": []
                },
                "shape_invariants": {
                    "value": "[search_state_shape_invariants]",
                    "type": "List",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_83": {
                "condition": {
                    "value": "logits < min_values",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(logits, dtype=logits.dtype) * compat.FLOAT_MIN",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_98": {
                "condition": {
                    "value": "logits < threshold",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(logits, dtype=logits.dtype) * compat.FLOAT_MIN",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_163": {
                "variable": {
                    "value": "initial_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size * sample_num, maximum_decode_length]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_166": {
                "variable": {
                    "value": "initial_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size * sample_num, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_220": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : eos_coefficient * logits + eos_bias",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : logits",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "categorical_227": {
                "variable": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_238": {
                "variable": {
                    "value": "cur_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "eos_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['eos_id']",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.squeeze(sample_ids, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_239": {
                "variable": {
                    "value": "next_finished",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "pre_finish",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state[_StateKeys.FINISHED_FLAGS]",
                            "Subscript"
                        ]
                    ]
                },
                "x": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "y": {
                    "value": "cur_finished",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(eos_id, tf.squeeze(sample_ids, 1))",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_262": {
                "variable": {
                    "value": "hypothesis",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "hypothesis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "res[_StateKeys.PREDICTED_IDS]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(hypothesis, paddings=tf.convert_to_tensor([[0, 0], [0, maximum_decode_length - res[_StateKeys.TIME_STEP]]], dtype=tf.int32), mode='CONSTANT', constant_values=eos_id)",
                            "Call"
                        ],
                        [
                            "sequence_sampling_search(symbols_to_logits_fn, generation_initializer, sample_next_word_fn=_sample_fn, sample_num=self._sample_num, extra_decode_length=self._extra_decode_length, maximum_decode_length=self._maximum_decode_length, minimum_decode_length=self._minimum_decode_length, padded_decode=self._padded_decode)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "tf.convert_to_tensor([[0, 0], [0, maximum_decode_length - res[_StateKeys.TIME_STEP]]], dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "eos_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['eos_id']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "softmax_89": {
                "logits": {
                    "value": "sorted_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(logits, direction='DESCENDING')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_97": {
                "input_tensor": {
                    "value": "applyed_sorted_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(t_sorted_indices_to_remove, tf.ones_like(sorted_logits, dtype=sorted_logits.dtype) * min_value, sorted_logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_154": {
                "input": {
                    "value": "decoder_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generation_initializer['decoder_input']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_171": {
                "x": {
                    "value": "initial_decoder_input_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer_utils.stack_beam_size(decoder_input_ids, sample_num)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_230": {
                "variable": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.tensor_scatter_nd_update(tf.transpose(next_predicted_ids), [[state[_StateKeys.TIME_STEP]]], tf.transpose(sample_ids))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_234": {
                "variable": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[next_predicted_ids, sample_ids]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_like_84": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "logits.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_94": {
                "input": {
                    "value": "sorted_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sort(logits, direction='DESCENDING')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "sorted_logits.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_99": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "symbols_to_logits_fn(state[_StateKeys.INPUT_IDS], state[_StateKeys.CACHE], state[_StateKeys.TIME_STEP])",
                            "Call"
                        ],
                        [
                            "unk_coefficient * logits + unk_bias",
                            "BinOp"
                        ],
                        [
                            "_calculate_logits(state=state, unk_id=unk_id, symbols_to_logits_fn=symbols_to_logits_fn)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(state[_StateKeys.TIME_STEP], minimum_decode_length - 1), lambda : eos_coefficient * logits + eos_bias, lambda : logits)",
                            "Call"
                        ],
                        [
                            "sample_next_word_fn(logits=logits)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "logits.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_183": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_184": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_structure_185": {
                "func": {
                    "value": "layer_utils.static_tensorshape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "initial_cache",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: layer_utils.stack_beam_size(x, sample_num), decoding_cache)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_188": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_189": {
                "dims": {
                    "value": "[None, maximum_decode_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_193": {
                "dims": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_194": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_structure_195": {
                "func": {
                    "value": "layer_utils.dynamic_tensorshape_except_last_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "initial_cache",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.map_structure(lambda x: layer_utils.stack_beam_size(x, sample_num), decoding_cache)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_198": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_199": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_220": {
                "x": {
                    "value": "state[_StateKeys.TIME_STEP]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "minimum_decode_length - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_238": {
                "input": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.categorical(logits, num_samples=1, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_250": {
                "x": {
                    "value": "tf.logical_not(tf.reduce_all(state[_StateKeys.FINISHED_FLAGS]))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less(state[_StateKeys.TIME_STEP], maximum_search_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_333": {
                "name": {
                    "value": "top_sampling",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tensor_scatter_nd_update_230": {
                "tensor": {
                    "value": "tf.transpose(next_predicted_ids)",
                    "type": "Call",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[state[_StateKeys.TIME_STEP]]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.transpose(sample_ids)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_242": {
                "input": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.categorical(logits, num_samples=1, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_not_251": {
                "x": {
                    "value": "tf.reduce_all(state[_StateKeys.FINISHED_FLAGS])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_252": {
                "x": {
                    "value": "state[_StateKeys.TIME_STEP]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "maximum_search_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.minimum(encoder_inputs_maxlen + extra_decode_length, maximum_decode_length)",
                            "Call"
                        ],
                        [
                            "tf.maximum(maximum_search_steps, minimum_decode_length)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_264": {
                "value": {
                    "value": "[[0, 0], [0, maximum_decode_length - res[_StateKeys.TIME_STEP]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_231": {
                "a": {
                    "value": "next_predicted_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "state[_StateKeys.PREDICTED_IDS]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(tf.tensor_scatter_nd_update(tf.transpose(next_predicted_ids), [[state[_StateKeys.TIME_STEP]]], tf.transpose(sample_ids)))",
                            "Call"
                        ],
                        [
                            "tf.concat([next_predicted_ids, sample_ids], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_232": {
                "a": {
                    "value": "sample_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.categorical(logits, num_samples=1, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_all_251": {
                "input_tensor": {
                    "value": "state[_StateKeys.FINISHED_FLAGS]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/layers/search/sequence_search.py": {
        "tensorflow": {}
    },
    "neurst/models/bert.py": {
        "tensorflow": {
            "Dense_114": {
                "variable": {
                    "value": "pooler",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "args['hidden_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.nn.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "pooler",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_144": {
                "variable": {
                    "value": "first_token_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_outputs[:, 0:1, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_117": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_118": {
                "value": {
                    "value": "[[0, 0.0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/models/encoder_decoder_model.py": {
        "tensorflow": {
            "Dense_65": {
                "variable": {
                    "value": "self._output_linear_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "trg_meta['vocab_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "softmax_linear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_113": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_114": {
                "value": {
                    "value": "[[0, 0.0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_115": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_257": {
                "input": {
                    "value": "encoder_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._encoder(embedded_inputs, src_padding, is_training=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_230": {
                "input": {
                    "value": "embedded_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._src_modality(inputs['src'])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/models/gpt2.py": {
        "tensorflow": {
            "Dense_50": {
                "variable": {
                    "value": "self._output_linear_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "vocab_meta['vocab_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "softmax_linear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_113": {
                "value": {
                    "value": "[[0, 1, 2]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/models/light_convolution_model.py": {
        "tensorflow": {
            "convert_to_tensor_141": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_142": {
                "value": {
                    "value": "[[0, 0.0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_143": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/models/model.py": {
        "tensorflow": {}
    },
    "neurst/models/model_utils.py": {
        "tensorflow": {
            "sequence_mask_56": {
                "lengths": {
                    "value": "tf.cast(lengths, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.cast(max_len, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype or tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "reduce_sum_35": {
                "input_tensor": {
                    "value": "tf.cast(tf.not_equal(data_tensor, pad_id), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_74": {
                "name": {
                    "value": "padding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_35": {
                "x": {
                    "value": "tf.not_equal(data_tensor, pad_id)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_57": {
                "x": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_58": {
                "x": {
                    "value": "max_len",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "not_equal_36": {
                "x": {
                    "value": "data_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "pad_id",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_38": {
                "input_tensor": {
                    "value": "tf.cast(tf.not_equal(data_tensor, pad_id), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "as_dtype_59": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_38": {
                "x": {
                    "value": "tf.not_equal(data_tensor, pad_id)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "not_equal_39": {
                "x": {
                    "value": "data_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "pad_id",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/models/speech_transformer.py": {
        "tensorflow": {
            "convert_to_tensor_170": {
                "value": {
                    "value": "fake_src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, 4, src_meta['audio_feature_dim'], src_meta['audio_feature_channels'])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_171": {
                "value": {
                    "value": "[4]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_172": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_182": {
                "lengths": {
                    "value": "tf.cast(_length_after_conv(inputs['src_length']), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.cast(_length_after_conv(tf.shape(inputs['src'])[1]), tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_183": {
                "x": {
                    "value": "_length_after_conv(inputs['src_length'])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_184": {
                "x": {
                    "value": "_length_after_conv(tf.shape(inputs['src'])[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_185": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_184": {
                "input": {
                    "value": "inputs['src']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/models/transformer.py": {
        "tensorflow": {
            "convert_to_tensor_129": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_130": {
                "value": {
                    "value": "[[0, 0.0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_131": {
                "value": {
                    "value": "[[1, 2, 3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/models/wav2vec2.py": {
        "tensorflow": {
            "LayerNormalization_51": {
                "variable": {
                    "value": "self._feature_extractor_norm_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "feature_extractor_norm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_132": {
                "variable": {
                    "value": "_src",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.rand(1, 5000)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_152": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._feature_extractor_norm_layer(features)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_118": {
                "variable": {
                    "value": "post_extract_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "args['encoder_embed_dim']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "post_extract_proj",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_157": {
                "x": {
                    "value": "tf.reshape(src_padding[:, :extra * feature_frames], [tf.shape(features)[0], feature_frames, -1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_164": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._feature_extractor(src, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.cast(self._feature_extractor_norm_layer(features), compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "self._post_extract_proj(features)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(features, rate=self._dropout_input)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._dropout_input",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_168": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._pos_conv(features, src_padding, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, rate=self._encoder_dropout)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._encoder_dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_133": {
                "input": {
                    "value": "_src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(numpy.random.rand(1, 5000), dtype=compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_154": {
                "input": {
                    "value": "src_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.get('src_padding', None)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reduce_all(tf.cast(tf.reshape(src_padding[:, :extra * feature_frames], [tf.shape(features)[0], feature_frames, -1]), tf.bool), axis=-1), features.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_155": {
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._feature_extractor(src, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.cast(self._feature_extractor_norm_layer(features), compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "self._post_extract_proj(features)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(features, rate=self._dropout_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_all_157": {
                "input_tensor": {
                    "value": "tf.cast(tf.reshape(src_padding[:, :extra * feature_frames], [tf.shape(features)[0], feature_frames, -1]), tf.bool)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_158": {
                "tensor": {
                    "value": "src_padding[:, :extra * feature_frames]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[tf.shape(features)[0], feature_frames, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_159": {
                "input": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._feature_extractor(src, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.cast(self._feature_extractor_norm_layer(features), compat.CUSTOM_GLOBAL_FLOATX)",
                            "Call"
                        ],
                        [
                            "self._post_extract_proj(features)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(features, rate=self._dropout_input)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/models/xstnet.py": {
        "tensorflow": {
            "Dense_58": {
                "variable": {
                    "value": "self._output_logits_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "units": {
                    "value": "text_meta['vocab_size']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "softmax_linear",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_62": {
                "variable": {
                    "value": "self.zero_audio",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 5000]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float16",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_63": {
                "variable": {
                    "value": "self.zero_audio_length",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "[5000]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_216": {
                "variable": {
                    "value": "text_embedded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._text_modality(src_text)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_228": {
                "input": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.pop('audio')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_250": {
                "variable": {
                    "value": "audio_embedded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._audio_modality(audio_src_after_w2v, is_training=is_training)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "repeat_257": {
                "variable": {
                    "value": "audio_tags",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.convert_to_tensor(self._text_meta['tag_dict']['<audio>'], tf.int64), [1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "repeats": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(inputs['trg_input'])[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_260": {
                "variable": {
                    "value": "audio_tags_emb",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._text_modality(audio_tags)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_262": {
                "variable": {
                    "value": "tagged_audio_embedded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[audio_tags_emb, audio_embedded_inputs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_95": {
                "name": {
                    "value": "cross_modal_transformer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "name_scope_172": {
                "name": {
                    "value": "audio_modality",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_209": {
                "input": {
                    "value": "inputs['trg_input']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_239": {
                "x": {
                    "value": "tf.reduce_sum(wav2vec2_out['contextualized_representation_padding'], axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_258": {
                "tensor": {
                    "value": "tf.convert_to_tensor(self._text_meta['tag_dict']['<audio>'], tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sequence_mask_264": {
                "lengths": {
                    "value": "1 + tf.cast(_length_after_conv(audio_src_length_after_w2v), tf.int32)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "1 + tf.cast(_length_after_conv(tf.shape(audio_src_after_w2v)[1]), tf.int32)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_289": {
                "x": {
                    "value": "tf.reduce_sum(audio)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.constant(0.0, tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "normal_148": {
                "shape": {
                    "value": "[2, 10000, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_149": {
                "value": {
                    "value": "[10000, 10000]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_150": {
                "value": {
                    "value": "[[5], [5]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_152": {
                "value": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_153": {
                "value": {
                    "value": "[[1, 2, 3], [3, 4, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_155": {
                "value": {
                    "value": "[[1], [1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_157": {
                "tensor": {
                    "value": "tf.zeros([2, 5000], tf.float16)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2, -1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_158": {
                "value": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_159": {
                "value": {
                    "value": "[[1, 3, 2, 4], [1, 9, 0, 0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_161": {
                "value": {
                    "value": "[4, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_162": {
                "value": {
                    "value": "[[1, 2, 3], [3, 4, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_164": {
                "value": {
                    "value": "[[3], [3]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_217": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_219": {
                "input": {
                    "value": "text_embedded_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(self._text_modality(src_text), dtype=tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX))",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_238": {
                "input": {
                    "value": "wav2vec2_out['contextualized_representation_padding']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_239": {
                "input_tensor": {
                    "value": "wav2vec2_out['contextualized_representation_padding']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "as_dtype_251": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_258": {
                "value": {
                    "value": "self._text_meta['tag_dict']['<audio>']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_261": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_289": {
                "input_tensor": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.pop('audio')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_290": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_294": {
                "input": {
                    "value": "text_encoder_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._transformer_encoder(text_embedded_inputs, text_src_padding, is_training=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_295": {
                "input": {
                    "value": "audio_encoder_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._transformer_encoder(tagged_audio_embedded_inputs, audio_src_padding, is_training=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_157": {
                "shape": {
                    "value": "[2, 5000]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float16",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_231": {
                "lengths": {
                    "value": "tf.cast(audio_length, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.cast(tf.shape(audio_src)[1], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.as_dtype(compat.CUSTOM_GLOBAL_FLOATX)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "floordiv_245": {
                "x": {
                    "value": "ans + self.args['audio_conv.kernel_size'][i] // 2 * 2 - self.args['audio_conv.kernel_size'][i]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self.args['audio_conv.strides'][i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "as_dtype_267": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_290": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_265": {
                "x": {
                    "value": "_length_after_conv(audio_src_length_after_w2v)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_266": {
                "x": {
                    "value": "_length_after_conv(tf.shape(audio_src_after_w2v)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_232": {
                "x": {
                    "value": "audio_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.pop('audio_length')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_233": {
                "x": {
                    "value": "tf.shape(audio_src)[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "as_dtype_234": {
                "type_value": {
                    "value": "compat.CUSTOM_GLOBAL_FLOATX",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_233": {
                "input": {
                    "value": "audio_src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.squeeze(audio, -1), -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_266": {
                "input": {
                    "value": "audio_src_after_w2v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wav2vec2_out['contextualized_representation']",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/optimizers/__init__.py": {
        "tensorflow": {}
    },
    "neurst/optimizers/schedules/__init__.py": {
        "tensorflow": {}
    },
    "neurst/optimizers/schedules/inverse_sqrt_schedule.py": {
        "tensorflow": {
            "convert_to_tensor_35": {
                "variable": {
                    "value": "self._initial_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._initial_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_36": {
                "variable": {
                    "value": "self._lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "args['lr']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_37": {
                "variable": {
                    "value": "self._init_lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "args['init_lr']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_38": {
                "variable": {
                    "value": "self._warmup_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "args['warmup_steps']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_65": {
                "variable": {
                    "value": "is_warmup",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(global_step, self._warmup_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_63": {
                "name": {
                    "value": "learning_rate_schedule",
                    "type": "str",
                    "possible_values": []
                }
            },
            "less_65": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "self._warmup_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_64": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/optimizers/schedules/noam_schedule.py": {
        "tensorflow": {
            "cast_35": {
                "variable": {
                    "value": "self._warmup_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "args['warmup_steps']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_40": {
                "variable": {
                    "value": "self._initial_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self._initial_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_42": {
                "variable": {
                    "value": "self._initial_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "_initial_learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['initial_factor']",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_55": {
                "variable": {
                    "value": "self._end_learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "_end_learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['end_factor']",
                            "Subscript"
                        ],
                        [
                            "_initial_learning_rate",
                            "Name"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_56": {
                "variable": {
                    "value": "self._start_decay_at",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "start_decay_at",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['start_decay_at']",
                            "Subscript"
                        ],
                        [
                            "0",
                            "Constant"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_57": {
                "variable": {
                    "value": "self._decay_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "decay_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args['decay_steps']",
                            "Subscript"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_88": {
                "variable": {
                    "value": "step_factor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.minimum(global_step - self._start_decay_at, self._decay_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "name_scope_86": {
                "name": {
                    "value": "learning_rate_schedule",
                    "type": "str",
                    "possible_values": []
                }
            },
            "minimum_94": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "global_step / self._warmup_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_96": {
                "x": {
                    "value": "tf.maximum(global_step, self._warmup_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "minimum_88": {
                "x": {
                    "value": "global_step - self._start_decay_at",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self._decay_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_96": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "self._warmup_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_87": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/optimizers/schedules/piecewise_schedule.py": {
        "tensorflow": {
            "name_scope_65": {
                "name": {
                    "value": "learning_rate_schedule",
                    "type": "str",
                    "possible_values": []
                }
            },
            "case_72": {
                "pred_fn_pairs": {
                    "value": "pred_fn_pairs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[(tf.less(global_step, self._schedule_steps[0]), lambda : self._schedule_lrs[0] / float(self._schedule_steps[0]) * global_step)]",
                            "List"
                        ]
                    ]
                },
                "default": {
                    "value": "lambda : tf.constant(self._schedule_lrs[-1])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_66": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_67": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "self._schedule_steps[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "less_70": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(global_step, tf.float32) + self._initial_step + 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_72": {
                "value": {
                    "value": "self._schedule_lrs[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_70": {
                "value": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/sparsity/pruning_optimizer.py": {
        "tensorflow": {
            "cond_121": {
                "pred": {
                    "value": "should_update_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._pruning_schedule.should_prune_in_step(self.iterations)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "_update_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_apply_mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Variable_76": {
                "initial_value": {
                    "value": "tf.cast(tf.math.not_equal(weight, 0.0), weight.dtype.base_dtype) if self._keep_prune_property else tf.ones_like(weight)",
                    "type": "IfExp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "weight.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "synchronization": {
                    "value": "tf.VariableSynchronization.ON_READ",
                    "type": "Attribute",
                    "possible_values": []
                },
                "aggregation": {
                    "value": "tf.VariableAggregation.ONLY_FIRST_REPLICA",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_85": {
                "initial_value": {
                    "value": "tf.convert_to_tensor(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "synchronization": {
                    "value": "tf.VariableSynchronization.ON_READ",
                    "type": "Attribute",
                    "possible_values": []
                },
                "aggregation": {
                    "value": "tf.VariableAggregation.ONLY_FIRST_REPLICA",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "abs_109": {
                "variable": {
                    "value": "abs_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_110": {
                "x": {
                    "value": "tf.size(weight)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "top_k_112": {
                "variable": {
                    "value": "(values, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(abs_weight, [-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "k": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.math.round(tf.cast(tf.size(weight), tf.float32) * (1.0 - sparsity)), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_114": {
                "variable": {
                    "value": "current_threshold",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "k - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_115": {
                "variable": {
                    "value": "new_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.greater_equal(abs_weight, current_threshold)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "weight.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_86": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_77": {
                "x": {
                    "value": "tf.math.not_equal(weight, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "weight.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_78": {
                "input": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_103": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "weight.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "round_110": {
                "x": {
                    "value": "tf.cast(tf.size(weight), tf.float32) * (1.0 - sparsity)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_112": {
                "tensor": {
                    "value": "abs_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.abs(weight)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_equal_115": {
                "x": {
                    "value": "abs_weight",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.abs(weight)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "current_threshold",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(values, k - 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "not_equal_77": {
                "x": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cast_119": {
                "x": {
                    "value": "new_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.math.greater_equal(abs_weight, current_threshold), weight.dtype.base_dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "weight.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_110": {
                "input": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/sparsity/pruning_schedule.py": {
        "tensorflow": {
            "logical_and_77": {
                "variable": {
                    "value": "is_in_pruning_range",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.greater_equal(step, self._begin_pruning_step)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.logical_or(tf.math.less_equal(step, self._end_pruning_step), tf.math.less(self._end_pruning_step, 0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_84": {
                "variable": {
                    "value": "is_pruning_turn",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.floormod(tf.math.subtract(step, self._begin_pruning_step), self._pruning_frequency)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "divide_171": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(step - self._begin_pruning_step, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self._decay_pruning_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "minimum_172": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.maximum(0.0, p)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_87": {
                "x": {
                    "value": "is_in_pruning_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.logical_and(tf.math.greater_equal(step, self._begin_pruning_step), tf.math.logical_or(tf.math.less_equal(step, self._end_pruning_step), tf.math.less(self._end_pruning_step, 0)))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "is_pruning_turn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.equal(tf.math.floormod(tf.math.subtract(step, self._begin_pruning_step), self._pruning_frequency), 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_132": {
                "value": {
                    "value": "self.target_sparsity",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_equal_78": {
                "x": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "self._begin_pruning_step",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_or_80": {
                "x": {
                    "value": "tf.math.less_equal(step, self._end_pruning_step)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.less(self._end_pruning_step, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "floormod_85": {
                "x": {
                    "value": "tf.math.subtract(step, self._begin_pruning_step)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "self._pruning_frequency",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_171": {
                "x": {
                    "value": "step - self._begin_pruning_step",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_172": {
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.divide(tf.cast(step - self._begin_pruning_step, tf.float32), self._decay_pruning_steps)",
                            "Call"
                        ],
                        [
                            "tf.math.minimum(1.0, tf.math.maximum(0.0, p))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_equal_81": {
                "x": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "self._end_pruning_step",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_82": {
                "x": {
                    "value": "self._end_pruning_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "subtract_85": {
                "x": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "self._begin_pruning_step",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/tasks/cross_modal_translation.py": {
        "tensorflow": {
            "constant_89": {
                "variable": {
                    "value": "true_trans_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "true_trans_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.constant(true_trans_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_90": {
                "variable": {
                    "value": "true_audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.constant([audio_bucket_boundaries] * 2, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_359": {
                "variable": {
                    "value": "float_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_360": {
                "variable": {
                    "value": "int_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_361": {
                "variable": {
                    "value": "eos",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._text_data_pipeline.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_418": {
                "variable": {
                    "value": "s2t_bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "s2t_bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(s2t_bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_419": {
                "variable": {
                    "value": "audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_audio_bucket_boundaries(args['max_audio_src_len'], args['batch_bucket_min_audio_src_len'])",
                            "Call"
                        ],
                        [
                            "tf.constant(audio_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_423": {
                "variable": {
                    "value": "t2t_bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "t2t_bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(t2t_bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_424": {
                "variable": {
                    "value": "text_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "text_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(text_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_426": {
                "variable": {
                    "value": "t2t_max_trg_len",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "args['max_text_trg_len']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_428": {
                "variable": {
                    "value": "t2t_bucket_num",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "len(t2t_bucket_batch_sizes)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_90": {
                "value": {
                    "value": "[audio_bucket_boundaries] * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_222": {
                "variable": {
                    "value": "input_dict[trg_input]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(target_bos, axis=-1), batch_of_data['tgt_text'][:, :-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_432": {
                "variable": {
                    "value": "is_text2text",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(examples['audio_length'], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.constant(0, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_484": {
                "variable": {
                    "value": "padded_shapes",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(bucket_id, t2t_bucket_num)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "t2t_shapes",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "s2t_shapes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TensorShape_174": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_175": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_176": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_177": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_178": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_201": {
                "input": {
                    "value": "batch_of_data['audio']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_204": {
                "tensor": {
                    "value": "batch_of_data['audio']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, -1, self._audio_feature_dim, self._audio_feature_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "size_436": {
                "variable": {
                    "value": "seq_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "examples['src_text']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "less_equal_437": {
                "variable": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(seq_length, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(text_bucket_boundaries, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_442": {
                "variable": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less_equal(tf.cast(examples['audio_length'], tf.int32), s2t_audio_bucket_boundaries)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less_equal(tf.size(examples['tgt_text']), s2t_trans_bucket_boundries)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_451": {
                "pred": {
                    "value": "is_text2text",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.cast(examples['audio_length'], tf.int32), tf.constant(0, dtype=tf.int32))",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "_to_t2t_bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_to_s2t_bucket_id",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_461": {
                "pred": {
                    "value": "tf.less(bucket_id, t2t_bucket_num)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "t2t_bucket_size",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "s2t_bucket_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "group_by_window_492": {
                "key_func": {
                    "value": "example_to_bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "reduce_func": {
                    "value": "batching_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "window_size": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "window_size_func": {
                    "value": "window_size_fn",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_274": {
                "variable": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less_equal(tf.size(text), max_text_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : text",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.concat([text[:max_text_len - 1], text[-1:]], axis=0)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_301": {
                "x": {
                    "value": "(tf.shape(audio)[0] if isinstance(audio, tf.Tensor) else audio.shape[0]) // self._audio_feature_dim // self._audio_feature_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_314": {
                "value": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_315": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_all_407": {
                "input_tensor": {
                    "value": "[length == -1 or length is None or tf.shape(data_sample[k])[0] <= length for (k, length) in clean_length_dict.items()]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "cast_432": {
                "x": {
                    "value": "examples['audio_length']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_433": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_min_439": {
                "input_tensor": {
                    "value": "tf.where(conditions_c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_461": {
                "x": {
                    "value": "bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "t2t_bucket_num",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(len(t2t_bucket_batch_sizes), tf.int64)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_484": {
                "x": {
                    "value": "bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "t2t_bucket_num",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(len(t2t_bucket_batch_sizes), tf.int64)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_58": {
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dataset.take(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_222": {
                "input": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_of_data['tgt_text'][:, 0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "size_377": {
                "input": {
                    "value": "x['audio']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_382": {
                "value": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_390": {
                "value": {
                    "value": "8000",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_437": {
                "x": {
                    "value": "seq_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.size(examples['src_text'])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_438": {
                "x": {
                    "value": "text_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(text_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_439": {
                "condition": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cast(seq_length, tf.int32), tf.cast(text_bucket_boundaries, tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.less_equal(tf.cast(examples['audio_length'], tf.int32), s2t_audio_bucket_boundaries), tf.less_equal(tf.size(examples['tgt_text']), s2t_trans_bucket_boundries))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_equal_443": {
                "x": {
                    "value": "tf.cast(examples['audio_length'], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "s2t_audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "less_equal_445": {
                "x": {
                    "value": "tf.size(examples['tgt_text'])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "s2t_trans_bucket_boundries",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "where_447": {
                "condition": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cast(seq_length, tf.int32), tf.cast(text_bucket_boundaries, tf.int32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.less_equal(tf.cast(examples['audio_length'], tf.int32), s2t_audio_bucket_boundaries), tf.less_equal(tf.size(examples['tgt_text']), s2t_trans_bucket_boundries))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_equal_275": {
                "x": {
                    "value": "tf.size(text)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "max_text_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max_text_trg_len",
                            "Name"
                        ],
                        [
                            "max_text_src_len",
                            "Name"
                        ],
                        [
                            "10",
                            "Constant"
                        ]
                    ]
                }
            },
            "cast_443": {
                "x": {
                    "value": "examples['audio_length']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_445": {
                "input": {
                    "value": "examples['tgt_text']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_468": {
                "value": {
                    "value": "5000",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_479": {
                "value": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_275": {
                "input": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": [
                        [
                            "text.as_string().decode('utf-8')",
                            "Call"
                        ],
                        [
                            "self._text_data_pipeline.process(text, is_processed=False)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less_equal(tf.size(text), max_text_len), lambda : text, lambda : tf.concat([text[:max_text_len - 1], text[-1:]], axis=0))",
                            "Call"
                        ],
                        [
                            "text[:max_text_len - 1] + text[-1:]",
                            "BinOp"
                        ],
                        [
                            "text.as_string()",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_277": {
                "values": {
                    "value": "[text[:max_text_len - 1], text[-1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_301": {
                "input": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "audio[:max_audio_len * self._audio_feature_dim * self._audio_feature_channels]",
                            "Subscript"
                        ],
                        [
                            "_process_audio(data['audio'])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_409": {
                "input": {
                    "value": "data_sample[k]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/tasks/multilingual_translation.py": {
        "tensorflow": {
            "TensorShape_101": {
                "variable": {
                    "value": "signatures[label]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_217": {
                "variable": {
                    "value": "eos",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._multilingual_dp.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_218": {
                "variable": {
                    "value": "int_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_121": {
                "variable": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(batch_of_data['trg_lang'], axis=1), src]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_123": {
                "variable": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(batch_of_data['src_lang'], axis=1), src]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_131": {
                "variable": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[tf.convert_to_tensor(self._multilingual_dp.meta['bos_id'], dtype=tf.int64)]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(src)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_140": {
                "variable": {
                    "value": "input_dict[trg_input]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(target_bos, axis=1), batch_of_data['label'][:, :-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_95": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_96": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_97": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_174": {
                "variable": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less_equal(tf.size(text), max_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : text",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.concat([text[:max_len - 1], text[-1:]], axis=0)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_121": {
                "input": {
                    "value": "batch_of_data['trg_lang']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_123": {
                "input": {
                    "value": "batch_of_data['src_lang']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_131": {
                "value": {
                    "value": "self._multilingual_dp.meta['bos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_140": {
                "input": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_of_data['trg_lang']",
                            "Subscript"
                        ],
                        [
                            "tf.tile([tf.convert_to_tensor(self._multilingual_dp.meta['bos_id'], dtype=tf.int64)], [tf.shape(src)[0]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_132": {
                "input": {
                    "value": "src",
                    "type": "variable",
                    "possible_values": [
                        [
                            "batch_of_data['feature']",
                            "Subscript"
                        ],
                        [
                            "tf.concat([tf.expand_dims(batch_of_data['trg_lang'], axis=1), src], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.expand_dims(batch_of_data['src_lang'], axis=1), src], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_equal_175": {
                "x": {
                    "value": "tf.size(text)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "max_len",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_175": {
                "input": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._multilingual_dp.process(text, is_processed=data_status == compat.DataStatus.PROCESSED)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less_equal(tf.size(text), max_len), lambda : text, lambda : tf.concat([text[:max_len - 1], text[-1:]], axis=0))",
                            "Call"
                        ],
                        [
                            "text[:max_len - 1] + text[-1:]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_176": {
                "values": {
                    "value": "[text[:max_len - 1], text[-1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_284": {
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_298": {
                "input": {
                    "value": "x['feature']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "size_299": {
                "input": {
                    "value": "x['label']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/tasks/seq2seq.py": {
        "tensorflow": {
            "TensorShape_101": {
                "variable": {
                    "value": "signatures[label]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_125": {
                "variable": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[tf.convert_to_tensor(bosid, dtype=tf.int64)]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(input_dict['src'])[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_208": {
                "variable": {
                    "value": "src_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._src_data_pipeline.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_209": {
                "variable": {
                    "value": "trg_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._trg_data_pipeline.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_134": {
                "variable": {
                    "value": "input_dict[trg_input]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(target_bos, axis=1), batch_of_data['label'][:, :-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_97": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_125": {
                "value": {
                    "value": "bosid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._trg_data_pipeline.meta['eos_id'] if self._target_begin_of_sentence == 'eos' else self._trg_data_pipeline.meta['bos_id']",
                            "IfExp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_167": {
                "variable": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less_equal(tf.size(text), max_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : text",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.concat([text[:max_len - 1], text[-1:]], axis=0)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "shape_126": {
                "input": {
                    "value": "input_dict['src']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_134": {
                "input": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile([tf.convert_to_tensor(bosid, dtype=tf.int64)], [tf.shape(input_dict['src'])[0]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_equal_168": {
                "x": {
                    "value": "tf.size(text)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "max_len",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_168": {
                "input": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dp.process(text, is_processed=data_status == compat.DataStatus.PROCESSED)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less_equal(tf.size(text), max_len), lambda : text, lambda : tf.concat([text[:max_len - 1], text[-1:]], axis=0))",
                            "Call"
                        ],
                        [
                            "text[:max_len - 1] + text[-1:]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_169": {
                "values": {
                    "value": "[text[:max_len - 1], text[-1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "flatten_260": {
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_267": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/tasks/speech2text.py": {
        "tensorflow": {
            "TensorShape_125": {
                "variable": {
                    "value": "signatures[transcript]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_149": {
                "variable": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "[tf.convert_to_tensor(self._trg_data_pipeline.meta['bos_id'], dtype=tf.int64)]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(input_dict['src'])[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_248": {
                "variable": {
                    "value": "float_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_249": {
                "variable": {
                    "value": "int_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_250": {
                "variable": {
                    "value": "trg_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._trg_data_pipeline.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_439": {
                "variable": {
                    "value": "signatures[transcript]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_441": {
                "variable": {
                    "value": "signatures[translation]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_159": {
                "variable": {
                    "value": "input_dict[trg_input]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(target_bos, axis=1), batch_of_data['transcript'][:, :-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_120": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_121": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_144": {
                "input": {
                    "value": "batch_of_data['audio']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_145": {
                "tensor": {
                    "value": "batch_of_data['audio']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch, -1, self._audio_feature_dim, self._audio_feature_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_194": {
                "variable": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "audio[:max_audio_len * self._audio_feature_dim * self._audio_feature_channels]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(audio, [-1, self._audio_feature_dim * self._audio_feature_channels])",
                            "Call"
                        ],
                        [
                            "tf.reshape(self._specaug(audio), [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self._audio_feature_dim * self._audio_feature_channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_196": {
                "variable": {
                    "value": "audio",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self._specaug(audio)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_222": {
                "variable": {
                    "value": "ret[transcript]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "_process_and_truncate_text(data['transcript'])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_333": {
                "variable": {
                    "value": "bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "bucket_batch_sizes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[int(batch_size_per_gpu // bound * num_replicas_in_sync) for bound in audio_bucket_boundaries]",
                            "ListComp"
                        ],
                        [
                            "[int(minimal_multiple(batch_size_per_gpu // bound, 8) * num_replicas_in_sync) for bound in audio_bucket_boundaries]",
                            "ListComp"
                        ],
                        [
                            "tf.constant(bucket_batch_sizes, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_334": {
                "variable": {
                    "value": "audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_audio_bucket_boundaries(max_src_len, args['min_src_bucket_boundary'])",
                            "Call"
                        ],
                        [
                            "tf.constant(audio_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_434": {
                "dims": {
                    "value": "[None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_435": {
                "dims": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_150": {
                "value": {
                    "value": "self._trg_data_pipeline.meta['bos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_206": {
                "variable": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less_equal(tf.size(text), max_trg_len)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : text",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.concat([text[:max_trg_len - 1], text[-1:]], axis=0)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_217": {
                "x": {
                    "value": "(tf.shape(feature)[0] if compat.is_tf_tensor(feature) else feature.shape[0]) // self._audio_feature_dim // self._audio_feature_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_330": {
                "variable": {
                    "value": "true_trans_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "true_trans_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.constant(true_trans_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_331": {
                "variable": {
                    "value": "true_audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.constant([audio_bucket_boundaries] * 2, dtype=tf.int32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_342": {
                "variable": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less_equal(tf.cast(examples['audio_length'], tf.int32), true_audio_bucket_boundaries)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.less_equal(tf.size(examples['transcript']), true_trans_bucket_boundaries)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_151": {
                "input": {
                    "value": "input_dict['src']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_159": {
                "input": {
                    "value": "target_bos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile([tf.convert_to_tensor(self._trg_data_pipeline.meta['bos_id'], dtype=tf.int64)], [tf.shape(input_dict['src'])[0]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_equal_339": {
                "variable": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.cast(examples['audio_length'], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_audio_bucket_boundaries(max_src_len, args['min_src_bucket_boundary'])",
                            "Call"
                        ],
                        [
                            "tf.constant(audio_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_by_window_374": {
                "key_func": {
                    "value": "example_to_bucket_id",
                    "type": "variable",
                    "possible_values": []
                },
                "reduce_func": {
                    "value": "batching_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "window_size": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "window_size_func": {
                    "value": "window_size_fn",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "less_equal_207": {
                "x": {
                    "value": "tf.size(text)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "max_trg_len",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.get('max_trg_len', None)",
                            "Call"
                        ],
                        [
                            "minimal_multiple(args['max_trg_len'], 8)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_331": {
                "value": {
                    "value": "[audio_bucket_boundaries] * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_min_341": {
                "input_tensor": {
                    "value": "tf.where(conditions_c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_equal_343": {
                "x": {
                    "value": "tf.cast(examples['audio_length'], tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "true_audio_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(tf.constant([audio_bucket_boundaries] * 2, dtype=tf.int32))",
                            "Call"
                        ]
                    ]
                }
            },
            "less_equal_344": {
                "x": {
                    "value": "tf.size(examples['transcript'])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "true_trans_bucket_boundaries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.constant(true_trans_bucket_boundaries, dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_345": {
                "condition": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cast(examples['audio_length'], tf.int32), audio_bucket_boundaries)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.less_equal(tf.cast(examples['audio_length'], tf.int32), true_audio_bucket_boundaries), tf.less_equal(tf.size(examples['transcript']), true_trans_bucket_boundaries))",
                            "Call"
                        ]
                    ]
                }
            },
            "size_207": {
                "input": {
                    "value": "text",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._trg_data_pipeline.process(text, is_processed=False)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less_equal(tf.size(text), max_trg_len), lambda : text, lambda : tf.concat([text[:max_trg_len - 1], text[-1:]], axis=0))",
                            "Call"
                        ],
                        [
                            "text[:max_trg_len - 1] + text[-1:]",
                            "BinOp"
                        ],
                        [
                            "dp.process(text, is_processed=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_208": {
                "values": {
                    "value": "[text[:max_trg_len - 1], text[-1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_339": {
                "x": {
                    "value": "examples['audio_length']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_341": {
                "condition": {
                    "value": "conditions_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.less_equal(tf.cast(examples['audio_length'], tf.int32), audio_bucket_boundaries)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.less_equal(tf.cast(examples['audio_length'], tf.int32), true_audio_bucket_boundaries), tf.less_equal(tf.size(examples['transcript']), true_trans_bucket_boundaries))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_343": {
                "x": {
                    "value": "examples['audio_length']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_344": {
                "input": {
                    "value": "examples['transcript']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_218": {
                "input": {
                    "value": "feature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_process_audio(data['audio'])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/tasks/task.py": {
        "tensorflow": {
            "Input_51": {
                "variable": {
                    "value": "inps[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "tuple(signatures[name][1:])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtypes[name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dtypes",
                            "Name"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "'metric'",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/tasks/translation.py": {
        "tensorflow": {
            "constant_80": {
                "value": {
                    "value": "self._src_data_pipeline.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_81": {
                "value": {
                    "value": "self._trg_data_pipeline.meta['eos_id']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_125": {
                "structure": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "size_142": {
                "input": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/callbacks.py": {
        "tensorflow": {
            "create_file_writer_125": {
                "variable": {
                    "value": "self._file_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "self._log_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "graph_144": {
                "graph_data": {
                    "value": "K.get_graph()",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "executing_eagerly_160": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_session_174": {
                "variable": {
                    "value": "reduced_logs[metric]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_174": {
                "variable": {
                    "value": "reduced_logs[metric]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "main": {
                    "value": "self._allreduce_ops[metric]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "executing_eagerly_192": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_session_203": {
                "variable": {
                    "value": "reduced_logs[metric]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_203": {
                "variable": {
                    "value": "reduced_logs[metric]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "main": {
                    "value": "self._allreduce_ops[metric]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "device_161": {
                "device_name": {
                    "value": "self._device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_167": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "metric",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "name_scope_166": {
                "name": {
                    "value": "MetricAverageCallback",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_session_168": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_168": {
                "main": {
                    "value": "var.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_196": {
                "name": {
                    "value": "MetricAverageCallback",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_session_198": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_198": {
                "main": {
                    "value": "var.initializer",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_242": {
                "name": {
                    "value": "compat.GlobalKeys.TBPREFIX_TRAINING + f'/{metric}'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_193": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "metric",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_162": {
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "metric",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/criterion_validator.py": {
        "tensorflow": {
            "scalar_119": {
                "name": {
                    "value": "compat.GlobalKeys.TBPREFIX_VALID + f'/{tb_name}{k}'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/distribution_utils.py": {
        "tensorflow": {
            "TPUClusterResolver_32": {
                "variable": {
                    "value": "cluster_resolver",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "tpu_address",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "initialize_tpu_system_36": {
                "enable_coordination_service": {
                    "value": "cluster_resolver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(tpu=tpu_address)",
                            "Call"
                        ],
                        [
                            "tpu_initialize(tpu_address)",
                            "Call"
                        ]
                    ]
                }
            },
            "MultiWorkerMirroredStrategy_171": {
                "variable": {
                    "value": "strategy",
                    "type": "variable",
                    "possible_values": []
                },
                "communication": {
                    "value": "_collective_communication(all_reduce_alg)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "experimental_connect_to_cluster_35": {
                "cluster_spec_or_resolver": {
                    "value": "cluster_resolver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(tpu=tpu_address)",
                            "Call"
                        ],
                        [
                            "tpu_initialize(tpu_address)",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUStrategy_149": {
                "tpu_cluster_resolver": {
                    "value": "cluster_resolver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(tpu=tpu_address)",
                            "Call"
                        ],
                        [
                            "tpu_initialize(tpu_address)",
                            "Call"
                        ]
                    ]
                }
            },
            "MirroredStrategy_177": {
                "cross_device_ops": {
                    "value": "_mirrored_cross_device_ops(all_reduce_alg, num_packs)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/gradaccum_keras_model.py": {
        "tensorflow": {
            "flatten_34": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(outputs, expand_composites=True)",
                            "Call"
                        ],
                        [
                            "model.distribute_strategy.run(run_step, args=(data,))",
                            "Call"
                        ],
                        [
                            "training.reduce_per_replica(outputs, self.distribute_strategy, reduction='first')",
                            "Call"
                        ],
                        [
                            "model.train_step(data)",
                            "Call"
                        ],
                        [
                            "step_function(self, iterator)",
                            "Call"
                        ]
                    ]
                },
                "expand_composites": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "executing_eagerly_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "convert_to_tensor_59": {
                "value": {
                    "value": "gradient",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._gradients",
                            "Attribute"
                        ]
                    ]
                }
            },
            "unpack_x_y_sample_weight_188": {
                "variable": {
                    "value": "(x, y, sample_weight)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "data": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_adapter.expand_1d(data)",
                            "Call"
                        ],
                        [
                            "next(iterator)",
                            "Call"
                        ],
                        [
                            "next(iterator)",
                            "Call"
                        ]
                    ]
                }
            },
            "IndexedSlices_47": {
                "values": {
                    "value": "gradient.values * tf.convert_to_tensor(scale, dtype=gradient.dtype.base_dtype)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "indices": {
                    "value": "gradient.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dense_shape": {
                    "value": "gradient.dense_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_342": {
                "variable": {
                    "value": "train_function",
                    "type": "variable",
                    "possible_values": []
                },
                "experimental_relax_shapes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unpack_x_y_sample_weight_392": {
                "variable": {
                    "value": "(val_x, val_y, val_sample_weight)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "data": {
                    "value": "validation_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_53": {
                "value": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "gradient.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_190": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "function_345": {
                "variable": {
                    "value": "accum_function",
                    "type": "variable",
                    "possible_values": []
                },
                "experimental_relax_shapes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "CallbackList_415": {
                "variable": {
                    "value": "callbacks",
                    "type": "variable",
                    "possible_values": []
                },
                "callbacks": {
                    "value": "callbacks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "callbacks_module.CallbackList(callbacks, add_history=True, add_progbar=verbose != 0, model=self, verbose=verbose, epochs=epochs, steps=data_handler.inferred_steps)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "add_history": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "add_progbar": {
                    "value": "verbose != 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "model": {
                    "value": "self",
                    "type": "variable",
                    "possible_values": []
                },
                "verbose": {
                    "value": "verbose",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "epochs": {
                    "value": "epochs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "steps": {
                    "value": "data_handler.inferred_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_48": {
                "value": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "gradient.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_109": {
                "input": {
                    "value": "gradient",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._gradients",
                            "Attribute"
                        ]
                    ]
                }
            },
            "control_dependencies_289": {
                "control_inputs": {
                    "value": "_minimum_control_deps(outputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_89": {
                "initial_value": {
                    "value": "tf.zeros_like(gradient)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "gradient.dtype.base_dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "synchronization": {
                    "value": "tf.VariableSynchronization.ON_READ",
                    "type": "Attribute",
                    "possible_values": []
                },
                "aggregation": {
                    "value": "tf.VariableAggregation.ONLY_FIRST_REPLICA",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "print_301": {
                "*inputs": {
                    "value": "traceback.format_exc(e)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "print_331": {
                "*inputs": {
                    "value": "traceback.format_exc(e)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_90": {
                "input": {
                    "value": "gradient",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._gradients",
                            "Attribute"
                        ]
                    ]
                }
            },
            "clip_by_value_229": {
                "t": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-self._clip_value",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "self._clip_value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_norm_232": {
                "t": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "self._clip_norm",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Trace_441": {
                "name": {
                    "value": "TraceContext",
                    "type": "str",
                    "possible_values": []
                },
                "graph_type": {
                    "value": "train",
                    "type": "str",
                    "possible_values": []
                },
                "epoch_num": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": []
                },
                "step_num": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_handler.steps()",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Trace_458": {
                "name": {
                    "value": "train",
                    "type": "str",
                    "possible_values": []
                },
                "epoch_num": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": []
                },
                "step_num": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_handler.steps()",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "_r": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/hvd_utils.py": {
        "tensorflow": {
            "name_scope_69": {
                "name": {
                    "value": "DistributedLossScaleOptimizer_Push_Pull",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_73": {
                "variable": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads",
                            "Name"
                        ],
                        [
                            "tf.convert_to_tensor(grad)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/training/revised_dynamic_loss_scale.py": {
        "tensorflow": {
            "is_finite_41": {
                "variable": {
                    "value": "is_finite",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads",
                            "Name"
                        ]
                    ]
                }
            },
            "equal_42": {
                "variable": {
                    "value": "reduced_is_finite",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.size(g, out_type=tf.int64)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.reduce_sum(tf.cast(is_finite, tf.int64))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_all_45": {
                "input_tensor": {
                    "value": "is_finite_per_grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "flatten_60": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(grads)",
                            "Call"
                        ]
                    ]
                }
            },
            "cond_104": {
                "variable": {
                    "value": "update_op",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_finite",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.is_finite(g)",
                            "Call"
                        ],
                        [
                            "_refactor_is_all_finite(grads)",
                            "Call"
                        ],
                        [
                            "tf.equal(reduced_is_finite_float, distribution.num_replicas_in_sync)",
                            "Call"
                        ],
                        [
                            "_refactor_is_all_finite(grads)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "update_if_finite_grads",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "update_if_not_finite_grads",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "has_strategy_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "equal_77": {
                "variable": {
                    "value": "is_finite",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "reduced_is_finite_float",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distribution.reduce(reduce_util.ReduceOp.SUM, is_finite_float, axis=None)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "distribution.num_replicas_in_sync",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_99": {
                "variable": {
                    "value": "new_loss_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "current_loss_scale / multiplier",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "size_42": {
                "input": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads",
                            "Name"
                        ]
                    ]
                },
                "out_type": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_43": {
                "input_tensor": {
                    "value": "tf.cast(is_finite, tf.int64)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_strategy_65": {
                "variable": {
                    "value": "distribution",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cond_91": {
                "pred": {
                    "value": "counter + 1 >= growth_steps",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "incr_loss_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : _op_in_graph_mode(counter.assign_add(1))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "group_100": {
                "*inputs": {
                    "value": "counter.assign(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "current_loss_scale.assign(new_loss_scale)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_43": {
                "x": {
                    "value": "is_finite",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.is_finite(g)",
                            "Call"
                        ],
                        [
                            "_refactor_is_all_finite(grads)",
                            "Call"
                        ],
                        [
                            "tf.equal(reduced_is_finite_float, distribution.num_replicas_in_sync)",
                            "Call"
                        ],
                        [
                            "_refactor_is_all_finite(grads)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_71": {
                "x": {
                    "value": "is_finite",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.is_finite(g)",
                            "Call"
                        ],
                        [
                            "_refactor_is_all_finite(grads)",
                            "Call"
                        ],
                        [
                            "tf.equal(reduced_is_finite_float, distribution.num_replicas_in_sync)",
                            "Call"
                        ],
                        [
                            "_refactor_is_all_finite(grads)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_87": {
                "*inputs": {
                    "value": "_assign_if_finite(current_loss_scale, new_loss_scale)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "counter.assign(0)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/seq_generation_validator.py": {
        "tensorflow": {
            "scalar_173": {
                "name": {
                    "value": "compat.GlobalKeys.TBPREFIX_VALID + f'/{tb_name}{k}'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "data": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/training/training_utils.py": {
        "tensorflow": {
            "Policy_77": {
                "variable": {
                    "value": "policy",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "mixed_float16",
                    "type": "str",
                    "possible_values": []
                }
            },
            "enable_check_numerics_84": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_experimental_options_88": {
                "options": {
                    "value": "{'pin_to_host_optimization': False}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "list_physical_devices_112": {
                "variable": {
                    "value": "gpus",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_global_policy_80": {
                "policy": {
                    "value": "mixed_float16",
                    "type": "str",
                    "possible_values": []
                }
            },
            "LossScaleOptimizer_391": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "loss_scale": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LossScaleOptimizer_398": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "loss_scale": {
                    "value": "revised_loss_scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "RevisedDynamicLossScale()",
                            "Call"
                        ]
                    ]
                }
            },
            "LossScaleOptimizer_406": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "set_memory_growth_114": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gpus",
                            "Name"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "set_visible_devices_116": {
                "devices": {
                    "value": "gpus[hvd.local_rank()]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/activations.py": {
        "tensorflow": {
            "split_48": {
                "variable": {
                    "value": "(a, b)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_32": {
                "variable": {
                    "value": "fp32_x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_49": {
                "x": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "tanh_41": {
                "x": {
                    "value": "numpy.sqrt(2 / numpy.pi) * (x + 0.044715 * tf.pow(x, 3))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "erf_35": {
                "x": {
                    "value": "fp32_x / numpy.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "saturate_cast_38": {
                "value": {
                    "value": "cdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.5 * (1.0 + tf.tanh(numpy.sqrt(2 / numpy.pi) * (x + 0.044715 * tf.pow(x, 3))))",
                            "BinOp"
                        ],
                        [
                            "0.5 * (1.0 + tf.math.erf(fp32_x / numpy.sqrt(2.0)))",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float16",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pow_42": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/audio_lib.py": {
        "tensorflow": {
            "reduce_any_183": {
                "variable": {
                    "value": "final_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.convert_to_tensor(masks, dtype=tf.bool)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_186": {
                "pred": {
                    "value": "tf.less(num_frames_or_freqs, F)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.zeros([num_frames_or_freqs], dtype=spectrogram.dtype)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : _apply(n, F, p)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "einsum_209": {
                "variable": {
                    "value": "demask",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "M,N->MN",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "1 - time_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "1 - freq_mask",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_169": {
                "input": {
                    "value": "spectrogram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.freq_or_time_masking_numpy(spectrogram, n=self._freq_mask_n, F=self._freq_mask_f, mask_value=mask_value, axis=1)",
                            "Call"
                        ],
                        [
                            "self.freq_or_time_masking_numpy(spectrogram, n=self._time_mask_n, F=self._time_mask_t, mask_value=mask_value, axis=0, p=self._time_mask_p)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_174": {
                "variable": {
                    "value": "F",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "F",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(F, math.floor(num_frames_or_freqs * p))",
                            "Call"
                        ],
                        [
                            "tf.minimum(F, tf.math.floor(num_frames_or_freqs * p))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.math.floor(num_frames_or_freqs * p)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "uniform_178": {
                "variable": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "F",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(F, math.floor(num_frames_or_freqs * p))",
                            "Call"
                        ],
                        [
                            "tf.minimum(F, tf.math.floor(num_frames_or_freqs * p))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "uniform_179": {
                "variable": {
                    "value": "f0",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "maxval": {
                    "value": "num_frames_or_freqs - f",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pad_180": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.ones([f], dtype=tf.bool)",
                    "type": "Call",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[f0, num_frames_or_freqs - f - f0]]",
                    "type": "List",
                    "possible_values": []
                },
                "mode": {
                    "value": "CONSTANT",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_184": {
                "x": {
                    "value": "final_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(tf.convert_to_tensor(masks, dtype=tf.bool), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "spectrogram.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_186": {
                "x": {
                    "value": "num_frames_or_freqs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "spectrogram.shape[axis]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(spectrogram)[axis]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "F",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(F, math.floor(num_frames_or_freqs * p))",
                            "Call"
                        ],
                        [
                            "tf.minimum(F, tf.math.floor(num_frames_or_freqs * p))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_212": {
                "variable": {
                    "value": "mask_value",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "spectrogram",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.freq_or_time_masking_numpy(spectrogram, n=self._freq_mask_n, F=self._freq_mask_f, mask_value=mask_value, axis=1)",
                            "Call"
                        ],
                        [
                            "self.freq_or_time_masking_numpy(spectrogram, n=self._time_mask_n, F=self._time_mask_t, mask_value=mask_value, axis=0, p=self._time_mask_p)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_183": {
                "value": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_187": {
                "shape": {
                    "value": "[num_frames_or_freqs]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "spectrogram.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floor_174": {
                "x": {
                    "value": "num_frames_or_freqs * p",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_180": {
                "shape": {
                    "value": "[f]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/checkpoints.py": {
        "tensorflow": {
            "glob_32": {
                "variable": {
                    "value": "datas",
                    "type": "variable",
                    "possible_values": []
                },
                "pattern": {
                    "value": "prefix + '.data-?????-of-?????'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "latest_checkpoint_336": {
                "variable": {
                    "value": "latest_ckpt_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "latest_checkpoint_170": {
                "variable": {
                    "value": "latest_ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "restore_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.directory",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "latest_checkpoint_381": {
                "variable": {
                    "value": "latest_ckpt_path",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "tmp_ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'ram://tmp_ckpt'",
                            "Constant"
                        ]
                    ]
                }
            },
            "Checkpoint_396": {
                "variable": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "rename_137": {
                "src": {
                    "value": "os.path.join(self.directory, 'checkpoint.incomplete')",
                    "type": "Call",
                    "possible_values": []
                },
                "dst": {
                    "value": "os.path.join(self.directory, 'checkpoint')",
                    "type": "Call",
                    "possible_values": []
                },
                "overwrite": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "remove_35": {
                "path": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "datas + [prefix + '.index']",
                            "BinOp"
                        ]
                    ]
                }
            },
            "exists_107": {
                "path": {
                    "value": "self._directory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GFile_135": {
                "name": {
                    "value": "os.path.join(self.directory, 'checkpoint.incomplete')",
                    "type": "Call",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "OneDeviceStrategy_262": {
                "device": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "list_variables_321": {
                "ckpt_dir_or_file": {
                    "value": "checkpoint_path",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "list_variables_340": {
                "ckpt_dir_or_file": {
                    "value": "latest_ckpt_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(model_dir)",
                            "Call"
                        ],
                        [
                            "model_dir",
                            "Name"
                        ],
                        [
                            "path",
                            "Name"
                        ],
                        [
                            "tf.train.latest_checkpoint(tmp_ckpt)",
                            "Call"
                        ]
                    ]
                }
            },
            "makedirs_109": {
                "path": {
                    "value": "self._directory",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Checkpoint_160": {},
            "Checkpoint_203": {},
            "Checkpoint_267": {},
            "Variable_263": {
                "initial_value": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "v.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "n + '_avg'",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/compat.py": {
        "tensorflow": {
            "isdir_141": {
                "path": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(checkpoint_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_142": {
                "variable": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.latest_checkpoint(checkpoint_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_161": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/configurable.py": {
        "tensorflow": {
            "exists_209": {
                "path": {
                    "value": "config_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config_paths",
                            "Name"
                        ],
                        [
                            "config_path.strip()",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_214": {
                "name": {
                    "value": "config_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "config_paths",
                            "Name"
                        ],
                        [
                            "config_path.strip()",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            },
            "exists_285": {
                "path": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "makedirs_286": {
                "path": {
                    "value": "output_dir",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_288": {
                "name": {
                    "value": "model_config_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ],
                        [
                            "os.path.join(model_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "isdir_300": {
                "path": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.dirname(model_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "exists_303": {
                "path": {
                    "value": "model_config_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ],
                        [
                            "os.path.join(model_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_305": {
                "name": {
                    "value": "model_config_filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(output_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ],
                        [
                            "os.path.join(model_dir, ModelConfigs.MODEL_CONFIG_YAML_FILENAME)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "r",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/converters/converter.py": {
        "tensorflow": {
            "exists_55": {
                "path": {
                    "value": "from_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "path",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "neurst/utils/converters/fairseq_transformer.py": {
        "tensorflow": {
            "Checkpoint_204": {
                "variable": {
                    "value": "ckpt_saver",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_32": {
                "name": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_83": {
                "name": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_205": {
                "initial_value": {
                    "value": "numpy_var",
                    "type": "variable",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "load_33": {
                "variable": {
                    "value": "cp",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_84": {
                "f": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_33": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_84": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/converters/fairseq_transformer2.py": {
        "tensorflow": {
            "Checkpoint_230": {
                "variable": {
                    "value": "ckpt_saver",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_33": {
                "name": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_84": {
                "name": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_231": {
                "initial_value": {
                    "value": "numpy_var",
                    "type": "variable",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "load_34": {
                "variable": {
                    "value": "cp",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_85": {
                "f": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_34": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_85": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/converters/fairseq_wav2vec2.py": {
        "tensorflow": {
            "Checkpoint_167": {
                "variable": {
                    "value": "ckpt_saver",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_42": {
                "name": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_91": {
                "name": {
                    "value": "path",
                    "type": "variable",
                    "possible_values": []
                },
                "mode": {
                    "value": "rb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_168": {
                "initial_value": {
                    "value": "numpy_var",
                    "type": "variable",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "load_43": {
                "variable": {
                    "value": "cp",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_92": {
                "f": {
                    "value": "fp",
                    "type": "variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "torch.device('cpu')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "device_43": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_92": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/converters/google_bert.py": {
        "tensorflow": {
            "Checkpoint_156": {
                "variable": {
                    "value": "ckpt_saver",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "load_variable_120": {
                "variable": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'bert_model.ckpt')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bert_var_names",
                            "Name"
                        ]
                    ]
                }
            },
            "GFile_68": {
                "name": {
                    "value": "os.path.join(path, 'bert_config.json')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "makedirs_105": {
                "path": {
                    "value": "extract_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(this_dir, bert_name)",
                            "Call"
                        ]
                    ]
                }
            },
            "list_variables_116": {
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'bert_model.ckpt')",
                            "Call"
                        ]
                    ]
                }
            },
            "Variable_149": {
                "initial_value": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.load_variable(ckpt, var_name)",
                            "Call"
                        ],
                        [
                            "numpy.concatenate([q_value, k_value, v_value], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "new_var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "_DIRECT_MAPPINGS[var_name]",
                            "Subscript"
                        ],
                        [
                            "f'bert/encoder/layer_{lid}/{_POSTFIX_MAPPINGS[postfix]}'",
                            "JoinedStr"
                        ],
                        [
                            "f'bert/encoder/layer_{lid}/self_attention_prepost_wrapper/self_attention/qkv_transform/{tensor_name}'",
                            "JoinedStr"
                        ]
                    ]
                },
                "dtype": {
                    "value": "str(var_value.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "load_variable_137": {
                "variable": {
                    "value": "q_value",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'bert_model.ckpt')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "f'bert/encoder/layer_{lid}/attention/self/query/{tensor_name}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "load_variable_139": {
                "variable": {
                    "value": "k_value",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'bert_model.ckpt')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "f'bert/encoder/layer_{lid}/attention/self/key/{tensor_name}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "load_variable_141": {
                "variable": {
                    "value": "v_value",
                    "type": "variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'bert_model.ckpt')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "f'bert/encoder/layer_{lid}/attention/self/value/{tensor_name}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/converters/openai_gpt2.py": {
        "tensorflow": {
            "Checkpoint_131": {
                "variable": {
                    "value": "ckpt_saver",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "GFile_63": {
                "name": {
                    "value": "os.path.join(path, 'hparams.json')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "list_variables_104": {
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'model.ckpt')",
                            "Call"
                        ]
                    ]
                }
            },
            "load_variable_108": {
                "ckpt_dir_or_file": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(path, 'model.ckpt')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gpt2_var_names",
                            "Name"
                        ]
                    ]
                }
            },
            "Variable_124": {
                "initial_value": {
                    "value": "var_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.squeeze(tf.train.load_variable(ckpt, var_name))",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "new_var_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "_DIRECT_MAPPINGS[var_name]",
                            "Subscript"
                        ],
                        [
                            "f'gpt2/decoder/layer_{lid}/{_POSTFIX_MAPPINGS[postfix]}'",
                            "JoinedStr"
                        ]
                    ]
                },
                "dtype": {
                    "value": "str(var_value.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst/utils/misc.py": {
        "tensorflow": {
            "map_structure_98": {
                "func": {
                    "value": "_to_single_numpy_or_python_type",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "tensors",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "is_tensor_82": {
                "variable": {
                    "value": "is_tf_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "flatten_46": {
                "structure": {
                    "value": "arg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args",
                            "Name"
                        ]
                    ]
                }
            },
            "map_structure_94": {
                "func": {
                    "value": "lambda _x: _x.decode('utf-8')",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "x.tolist()",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "neurst_pt/layers/common_layers.py": {
        "tensorflow": {
            "flatten_186": {
                "variable": {
                    "value": "self._flatten_output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "structure": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_247": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.layer_norm(input.float(), self.normalized_shape, self.weight.float() if self.weight is not None else None, self.bias.float() if self.bias is not None else None, self.eps)",
                            "Call"
                        ],
                        [
                            "self._activation_fn(self._dense1(inputs))",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._dense2(output)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "torch.split(output, self._flatten_output_units, dim=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]), output, self._flatten_output_units, check_types=False)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output, check_types=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_structure_243": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "*structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.layer_norm(input.float(), self.normalized_shape, self.weight.float() if self.weight is not None else None, self.bias.float() if self.bias is not None else None, self.eps)",
                            "Call"
                        ],
                        [
                            "self._activation_fn(self._dense1(inputs))",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._dense2(output)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "torch.split(output, self._flatten_output_units, dim=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]), output, self._flatten_output_units, check_types=False)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output, check_types=False)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self._flatten_output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "check_types": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "map_structure_249": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "self._activation_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.layer_norm(input.float(), self.normalized_shape, self.weight.float() if self.weight is not None else None, self.bias.float() if self.bias is not None else None, self.eps)",
                            "Call"
                        ],
                        [
                            "self._activation_fn(self._dense1(inputs))",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._dense2(output)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "torch.split(output, self._flatten_output_units, dim=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]), output, self._flatten_output_units, check_types=False)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output, check_types=False)",
                            "Call"
                        ]
                    ]
                },
                "check_types": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pack_sequence_as_250": {
                "structure": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.layer_norm(input.float(), self.normalized_shape, self.weight.float() if self.weight is not None else None, self.bias.float() if self.bias is not None else None, self.eps)",
                            "Call"
                        ],
                        [
                            "self._activation_fn(self._dense1(inputs))",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._dense2(output)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "torch.split(output, self._flatten_output_units, dim=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]), output, self._flatten_output_units, check_types=False)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output, check_types=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nested_188": {
                "seq": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "LayerNorm_46": {
                "normalized_shape": {
                    "value": "normalized_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "eps": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "MethodArgument"
                        ]
                    ]
                },
                "elementwise_affine": {
                    "value": "elementwise_affine",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "layer_norm_54": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "normalized_shape": {
                    "value": "self.normalized_shape",
                    "type": "Attribute",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.weight.float() if self.weight is not None else None",
                    "type": "IfExp",
                    "possible_values": []
                },
                "bias": {
                    "value": "self.bias.float() if self.bias is not None else None",
                    "type": "IfExp",
                    "possible_values": []
                },
                "eps": {
                    "value": "self.eps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_134": {
                "variable": {
                    "value": "self._dense1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "filter_size",
                    "type": "variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_135": {
                "variable": {
                    "value": "self._dense2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "filter_size",
                    "type": "variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "output_size",
                    "type": "variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "dropout_150": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.layer_norm(input.float(), self.normalized_shape, self.weight.float() if self.weight is not None else None, self.bias.float() if self.bias is not None else None, self.eps)",
                            "Call"
                        ],
                        [
                            "self._activation_fn(self._dense1(inputs))",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._dense2(output)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "torch.split(output, self._flatten_output_units, dim=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]), output, self._flatten_output_units, check_types=False)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output, check_types=False)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs['is_training']",
                            "Subscript"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_223": {
                "variable": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self._kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.kernel_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_341": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[torch.sin(scaled_time), torch.cos(scaled_time)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pad_342": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([torch.sin(scaled_time), torch.cos(scaled_time)], dim=1)",
                            "Call"
                        ],
                        [
                            "F.pad(signal, (0, int(math.fmod(channels, 2))))",
                            "Call"
                        ],
                        [
                            "torch.reshape(signal, [1, length, channels])",
                            "Call"
                        ],
                        [
                            "torch.reshape(signal, [1, channels])",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, int(math.fmod(channels, 2)))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "is_available_44": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_102": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm_layer(inputs)",
                            "Call"
                        ],
                        [
                            "self._layer(y, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "F.dropout(y, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._layer(inputs, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "F.dropout(y, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs['is_training']",
                            "Subscript"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dropout_108": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._norm_layer(inputs)",
                            "Call"
                        ],
                        [
                            "self._layer(y, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "F.dropout(y, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._layer(inputs, *args, **kwargs)",
                            "Call"
                        ],
                        [
                            "F.dropout(y, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self._dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "kwargs['is_training']",
                            "Subscript"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Parameter_189": {
                "variable": {
                    "value": "self._kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.nn.init.xavier_normal_(torch.empty(input_size, self._output_units))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_192": {
                "variable": {
                    "value": "self._kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.nn.init.xavier_normal_(torch.empty(input_size, sum(self._flatten_output_units)))",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Parameter_195": {
                "variable": {
                    "value": "self._bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(sum(self._flatten_output_units))",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "einsum_230": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abcd,cde->abe",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "einsum_236": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "abc,cd->abd",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "split_241": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.layer_norm(input.float(), self.normalized_shape, self.weight.float() if self.weight is not None else None, self.bias.float() if self.bias is not None else None, self.eps)",
                            "Call"
                        ],
                        [
                            "self._activation_fn(self._dense1(inputs))",
                            "Call"
                        ],
                        [
                            "F.dropout(output, p=self._dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "self._dense2(output)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abcd,cde->abe', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "torch.einsum('abc,cd->abd', inputs, kernel)",
                            "Call"
                        ],
                        [
                            "output + self._bias",
                            "BinOp"
                        ],
                        [
                            "torch.split(output, self._flatten_output_units, dim=-1)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(lambda x, num_units: torch.reshape(x, list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]), output, self._flatten_output_units, check_types=False)",
                            "Call"
                        ],
                        [
                            "tf.nest.flatten(output)",
                            "Call"
                        ],
                        [
                            "tf.nest.map_structure(self._activation_fn, output, check_types=False)",
                            "Call"
                        ]
                    ]
                },
                "split_size_or_sections": {
                    "value": "self._flatten_output_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Parameter_279": {
                "variable": {
                    "value": "self._position_emb_table",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "nn.init.normal_(torch.empty(self._max_positions, self._embedding_dim), mean=0.0, std=self._embedding_dim ** (-0.5))",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "arange_328": {
                "variable": {
                    "value": "position",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "end": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.size()[1]",
                            "Subscript"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                }
            },
            "reshape_344": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([torch.sin(scaled_time), torch.cos(scaled_time)], dim=1)",
                            "Call"
                        ],
                        [
                            "F.pad(signal, (0, int(math.fmod(channels, 2))))",
                            "Call"
                        ],
                        [
                            "torch.reshape(signal, [1, length, channels])",
                            "Call"
                        ],
                        [
                            "torch.reshape(signal, [1, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, length, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_346": {
                "variable": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "signal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([torch.sin(scaled_time), torch.cos(scaled_time)], dim=1)",
                            "Call"
                        ],
                        [
                            "F.pad(signal, (0, int(math.fmod(channels, 2))))",
                            "Call"
                        ],
                        [
                            "torch.reshape(signal, [1, length, channels])",
                            "Call"
                        ],
                        [
                            "torch.reshape(signal, [1, channels])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Parameter_283": {
                "variable": {
                    "value": "self._position_emb_table",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "self.add_sinusoids_timing_signal(torch.zeros(1, self._max_positions, self._embedding_dim), None)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "arange_331": {
                "variable": {
                    "value": "position",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "end": {
                    "value": "time + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_338": {
                "input": {
                    "value": "torch.arange(0, num_timescales).type(dtype) * -log_timescale_increment",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_195": {
                "*size": {
                    "value": "sum(self._flatten_output_units)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sin_341": {
                "input": {
                    "value": "scaled_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "position.unsqueeze(1) * inv_timescales.unsqueeze(0)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cos_341": {
                "input": {
                    "value": "scaled_time",
                    "type": "variable",
                    "possible_values": [
                        [
                            "position.unsqueeze(1) * inv_timescales.unsqueeze(0)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "device_34": {
                "type": {
                    "value": "x.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "empty_190": {
                "*size": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "out": {
                    "value": "self._output_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "empty_193": {
                "*size": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": []
                },
                "out": {
                    "value": "sum(self._flatten_output_units)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_244": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "list(x.size())[:-1] + [self._num_heads, num_units // self._num_heads]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "empty_280": {
                "*size": {
                    "value": "self._max_positions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out": {
                    "value": "self._embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_339": {
                "start": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "end": {
                    "value": "num_timescales",
                    "type": "variable",
                    "possible_values": [
                        [
                            "channels // 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_285": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "self._max_positions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self._embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/data/text/bpe_test.py": {
        "tensorflow": {
            "GFile_14": {
                "name": {
                    "value": "tmp_file.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/data/text_data_pipeline_test.py": {
        "tensorflow": {
            "GFile_10": {
                "name": {
                    "value": "vocab_file.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_14": {
                "name": {
                    "value": "bpe_codes_file.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/layers/attentions/multi_head_attention_pt_test.py": {
        "tensorflow": {
            "convert_to_tensor_25": {
                "variable": {
                    "value": "tf_query",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, length_q, num_units)",
                            "Call"
                        ],
                        [
                            "numpy.random.rand(1, length_q, num_units)",
                            "Call"
                        ],
                        [
                            "numpy.random.rand(1, 1, num_units)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_26": {
                "variable": {
                    "value": "tf_memory",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "memory",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, length_m, num_units)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_61": {
                "variable": {
                    "value": "tf_query",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, length_q, num_units)",
                            "Call"
                        ],
                        [
                            "numpy.random.rand(1, length_q, num_units)",
                            "Call"
                        ],
                        [
                            "numpy.random.rand(1, 1, num_units)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_62": {
                "variable": {
                    "value": "tf_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, length_q)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_91": {
                "variable": {
                    "value": "tf_query",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, length_q, num_units)",
                            "Call"
                        ],
                        [
                            "numpy.random.rand(1, length_q, num_units)",
                            "Call"
                        ],
                        [
                            "numpy.random.rand(1, 1, num_units)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_110": {
                "tensor": {
                    "value": "tf.convert_to_tensor(cache['keys'], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2, num_heads, num_units // num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_112": {
                "tensor": {
                    "value": "tf.convert_to_tensor(cache['values'], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2, num_heads, num_units // num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_110": {
                "value": {
                    "value": "cache['keys']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_112": {
                "value": {
                    "value": "cache['values']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "reshape_114": {
                "input": {
                    "value": "torch.FloatTensor(cache['keys'])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2, num_heads, num_units // num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_115": {
                "input": {
                    "value": "torch.FloatTensor(cache['values'])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 2, num_heads, num_units // num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/layers/attentions/multi_head_attention_test.py": {
        "tensorflow": {
            "convert_to_tensor_21": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[-1.3010577], [0.79014736]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_23": {
                "variable": {
                    "value": "memory",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[-1.1650294], [-0.88871276]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_77": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[-1.3010577, -2.3010577], [0.79014736, -0.79014736]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_79": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[-0.2276893, 0.11865579]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_132": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[-1.3010577, -2.3010577]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_165": {
                "tensor": {
                    "value": "tf.convert_to_tensor(numpy.array([[[-0.46546218, -1.0054358, 0.42906007, -1.6854379], [1.078194, 1.1625745, -0.25033495, -1.980812]]]), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, already_time, num_heads, num_units // num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_170": {
                "tensor": {
                    "value": "tf.convert_to_tensor(numpy.array([[[-1.2360295, 0.69050753, -1.8204833, 0.23788007], [2.3751693, -1.8772833, -0.2574517, 1.3010416]]]), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, already_time, num_heads, num_units // num_heads]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_165": {
                "value": {
                    "value": "numpy.array([[[-0.46546218, -1.0054358, 0.42906007, -1.6854379], [1.078194, 1.1625745, -0.25033495, -1.980812]]])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_170": {
                "value": {
                    "value": "numpy.array([[[-1.2360295, 0.69050753, -1.8204833, 0.23788007], [2.3751693, -1.8772833, -0.2574517, 1.3010416]]])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_110": {
                "value": {
                    "value": "[[[-0.2276893, 0.11865579]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_180": {
                "tensor": {
                    "value": "cache['keys']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, already_time + 2, num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_186": {
                "tensor": {
                    "value": "cache['keys']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, already_time + 2, num_units]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/layers/common_layers_test.py": {
        "tensorflow": {
            "convert_to_tensor_42": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.randn(2, 3, 6)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_51": {
                "variable": {
                    "value": "manual_out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "manual_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(manual_out, tf.concat([tf.shape(manual_out)[:-1], [num_heads, output_size // num_heads]], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.reshape(inputs, tf.concat([tf.shape(inputs)[:-2], [-1]], 0)), kernel) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel) + bias",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(manual_out)[:-1], [num_heads, output_size // num_heads]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_59": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.randn(1, 2, num_heads, num_inputs_per_head)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_77": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.randn(2, 3, 6)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_86": {
                "variable": {
                    "value": "(manual_out0, manual_out1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "manual_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(manual_out, tf.concat([tf.shape(manual_out)[:-1], [num_heads, output_size // num_heads]], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.reshape(inputs, tf.concat([tf.shape(inputs)[:-2], [-1]], 0)), kernel) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel) + bias",
                            "BinOp"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "[output_size, output_size1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_88": {
                "variable": {
                    "value": "manual_out0",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "manual_out0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(manual_out0, tf.concat([tf.shape(manual_out0)[:-1], [num_heads, output_size // num_heads]], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(manual_out0)[:-1], [num_heads, output_size // num_heads]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_90": {
                "variable": {
                    "value": "manual_out1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "manual_out1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(manual_out1, tf.concat([tf.shape(manual_out1)[:-1], [num_heads, output_size1 // num_heads]], axis=0))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(manual_out1)[:-1], [num_heads, output_size1 // num_heads]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_103": {
                "variable": {
                    "value": "inputs1d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[4, 7, 8]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_104": {
                "variable": {
                    "value": "inputs2d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[3, 1, 1, 1], [8, 1, 6, 4], [6, 6, 0, 5]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_11": {
                "value": {
                    "value": "[[[1, 2.0]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_12": {
                "dims": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_31": {
                "value": {
                    "value": "[[1, 2, 3.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorShape_33": {
                "dims": {
                    "value": "[1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_50": {
                "equation": {
                    "value": "abc,cd->abd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(1, 2, num_heads, num_inputs_per_head), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w",
                            "Name"
                        ],
                        [
                            "w",
                            "Name"
                        ],
                        [
                            "w",
                            "Name"
                        ]
                    ]
                }
            },
            "concat_51": {
                "values": {
                    "value": "[tf.shape(manual_out)[:-1], [num_heads, output_size // num_heads]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_68": {
                "a": {
                    "value": "tf.reshape(inputs, tf.concat([tf.shape(inputs)[:-2], [-1]], 0))",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w",
                            "Name"
                        ],
                        [
                            "w",
                            "Name"
                        ],
                        [
                            "w",
                            "Name"
                        ]
                    ]
                }
            },
            "einsum_85": {
                "equation": {
                    "value": "abc,cd->abd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(1, 2, num_heads, num_inputs_per_head), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w",
                            "Name"
                        ],
                        [
                            "w",
                            "Name"
                        ],
                        [
                            "w",
                            "Name"
                        ]
                    ]
                }
            },
            "concat_88": {
                "values": {
                    "value": "[tf.shape(manual_out0)[:-1], [num_heads, output_size // num_heads]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_90": {
                "values": {
                    "value": "[tf.shape(manual_out1)[:-1], [num_heads, output_size1 // num_heads]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_69": {
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(1, 2, num_heads, num_inputs_per_head), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([tf.shape(inputs)[:-2], [-1]], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorShape_15": {
                "dims": {
                    "value": "[2, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_69": {
                "values": {
                    "value": "[tf.shape(inputs)[:-2], [-1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorShape_17": {
                "dims": {
                    "value": "[4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_52": {
                "input": {
                    "value": "manual_out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(manual_out, tf.concat([tf.shape(manual_out)[:-1], [num_heads, output_size // num_heads]], axis=0))",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.reshape(inputs, tf.concat([tf.shape(inputs)[:-2], [-1]], 0)), kernel) + bias",
                            "BinOp"
                        ],
                        [
                            "tf.einsum('abc,cd->abd', inputs, kernel) + bias",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_89": {
                "input": {
                    "value": "manual_out0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(manual_out0, tf.concat([tf.shape(manual_out0)[:-1], [num_heads, output_size // num_heads]], axis=0))",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_91": {
                "input": {
                    "value": "manual_out1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(manual_out1, tf.concat([tf.shape(manual_out1)[:-1], [num_heads, output_size1 // num_heads]], axis=0))",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_19": {
                "dims": {
                    "value": "[4, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_21": {
                "dims": {
                    "value": "[3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_69": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(1, 2, num_heads, num_inputs_per_head), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(numpy.random.randn(2, 3, 6), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "tests/neurst/layers/decoders/transformer_decoder_test.py": {
        "tensorflow": {
            "convert_to_tensor_41": {
                "variable": {
                    "value": "encoder_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_51": {
                "variable": {
                    "value": "encoder_inputs_padding",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_53": {
                "variable": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[0.86675537, 0.22135425, 1.4054185, -0.42268831], [1.9606155, -1.831841, -1.8158482, -0.37030798], [-0.0011357157, 0.55629879, 0.066107117, -1.7330967]], [[-1.1870812, -0.54499257, -0.86622888, -0.74098641], [0.22233427, 0.53582352, 0.30567116, 0.10201423], [-1.8053315, 0.72125041, 1.0072237, -2.0333264]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_163": {
                "variable": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[1.9606155, -1.831841, -1.8158482, -0.37030798], [-0.0011357157, 0.55629879, 0.066107117, -1.7330967]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_67": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[0.39332086, -0.3676856, -0.50203305, 0.6782059], [-0.41239128, -0.15406412, 0.3964849, -0.79016757], [0.6749844, -0.09548753, 0.16253561, -0.0560202], [-0.4699119, 0.82842, 0.35657936, -0.45770356]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_67": {
                "value": {
                    "value": "[[0.39332086, -0.3676856, -0.50203305, 0.6782059], [-0.41239128, -0.15406412, 0.3964849, -0.79016757], [0.6749844, -0.09548753, 0.16253561, -0.0560202], [-0.4699119, 0.82842, 0.35657936, -0.45770356]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_74": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[0.03949255, 0.32946128, 0.38817757, 0.47047406, 0.07609951, 0.03131855, 0.15958023, 0.3292094, 0.42809182, 0.27969742, 0.39156157, -0.604576], [0.4869359, -0.590637, 0.3092571, 0.10321742, 0.45608515, 0.27015948, 0.2959339, 0.32079375, 0.480197, -0.35878542, 0.04467481, 0.467416], [-0.40064478, -0.05089319, -0.0999378, -0.6048573, 0.4379304, 0.3692366, 0.39103013, 0.24920046, -0.37060317, -0.03119427, 0.25101495, -0.21076846], [0.42842942, 0.48276085, -0.2498649, -0.0978691, -0.01024461, -0.04072392, -0.43499938, -0.09718102, 0.18174142, 0.07100755, -0.6075252, -0.3018506]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_74": {
                "value": {
                    "value": "[[0.03949255, 0.32946128, 0.38817757, 0.47047406, 0.07609951, 0.03131855, 0.15958023, 0.3292094, 0.42809182, 0.27969742, 0.39156157, -0.604576], [0.4869359, -0.590637, 0.3092571, 0.10321742, 0.45608515, 0.27015948, 0.2959339, 0.32079375, 0.480197, -0.35878542, 0.04467481, 0.467416], [-0.40064478, -0.05089319, -0.0999378, -0.6048573, 0.4379304, 0.3692366, 0.39103013, 0.24920046, -0.37060317, -0.03119427, 0.25101495, -0.21076846], [0.42842942, 0.48276085, -0.2498649, -0.0978691, -0.01024461, -0.04072392, -0.43499938, -0.09718102, 0.18174142, 0.07100755, -0.6075252, -0.3018506]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_89": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[-0.31871676, 0.46451026, -0.32600254, -0.42110354], [0.45953768, -0.52176374, -0.47615638, -0.7818449], [0.7724063, -0.25975162, -0.49630436, 0.4681155], [0.7189149, 0.25591546, 0.2100411, -0.3439259]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_89": {
                "value": {
                    "value": "[[-0.31871676, 0.46451026, -0.32600254, -0.42110354], [0.45953768, -0.52176374, -0.47615638, -0.7818449], [0.7724063, -0.25975162, -0.49630436, 0.4681155], [0.7189149, 0.25591546, 0.2100411, -0.3439259]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_96": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[0.27346164, -0.12056953, 0.4617111, 0.3126462], [-0.65311253, 0.24505383, 0.56249744, -0.5582411], [-0.47464705, -0.60553044, 0.3019113, 0.33609575], [-0.24644238, -0.16026068, -0.0945828, -0.05111927]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_96": {
                "value": {
                    "value": "[[0.27346164, -0.12056953, 0.4617111, 0.3126462], [-0.65311253, 0.24505383, 0.56249744, -0.5582411], [-0.47464705, -0.60553044, 0.3019113, 0.33609575], [-0.24644238, -0.16026068, -0.0945828, -0.05111927]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_103": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[-0.4204824, -0.23150605, 0.12045383, -0.6538836, 0.29070246, -0.38376695, 0.65055054, -0.51375425], [0.67025226, 0.0928542, -0.56662744, 0.12781924, -0.6193744, -0.61801594, 0.07964879, 0.16530299], [-0.06940353, -0.08732289, 0.24984497, 0.18489975, 0.5354368, -0.07608587, -0.5801205, -0.17658263], [0.54784423, -0.39817223, -0.11673075, 0.14106786, -0.1637184, 0.00750518, -0.44365695, -0.38458544]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_103": {
                "value": {
                    "value": "[[-0.4204824, -0.23150605, 0.12045383, -0.6538836, 0.29070246, -0.38376695, 0.65055054, -0.51375425], [0.67025226, 0.0928542, -0.56662744, 0.12781924, -0.6193744, -0.61801594, 0.07964879, 0.16530299], [-0.06940353, -0.08732289, 0.24984497, 0.18489975, 0.5354368, -0.07608587, -0.5801205, -0.17658263], [0.54784423, -0.39817223, -0.11673075, 0.14106786, -0.1637184, 0.00750518, -0.44365695, -0.38458544]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_114": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[-0.29522404, -0.1185838, 0.13743329, -0.33782017, -0.38876867, 0.48396683, 0.15062505, -0.37749952, -0.29512924, -0.016212821, -0.0001860857, -0.41960135, 0.53800035, 0.27734953, 0.0055179596, -0.034055352], [0.21051055, 0.36151302, 0.3104564, -0.11510965, 0.46738219, 0.1250459, -0.19454169, 0.41786206, -0.37045652, 0.33854598, -0.5097875, 0.52220762, 0.16077441, -0.39631999, 0.21259248, 0.23286474], [-0.10005751, -0.50858349, 0.36911082, -0.051783592, 0.071038425, -0.11148521, -0.53392905, 0.36009926, 0.079382658, 0.10371411, -0.50254786, 0.17596281, -0.0092926025, -0.00064194202, -0.014125884, 0.47321141], [0.28647327, 0.26127762, 0.45843053, 0.49775457, 0.3805601, -0.40995055, 0.36980593, 0.033520699, -0.0018056035, 0.016578972, 0.16026449, -0.24952739, -0.3143453, -0.1315895, 0.007999897, 0.11293548]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_114": {
                "value": {
                    "value": "[[-0.29522404, -0.1185838, 0.13743329, -0.33782017, -0.38876867, 0.48396683, 0.15062505, -0.37749952, -0.29512924, -0.016212821, -0.0001860857, -0.41960135, 0.53800035, 0.27734953, 0.0055179596, -0.034055352], [0.21051055, 0.36151302, 0.3104564, -0.11510965, 0.46738219, 0.1250459, -0.19454169, 0.41786206, -0.37045652, 0.33854598, -0.5097875, 0.52220762, 0.16077441, -0.39631999, 0.21259248, 0.23286474], [-0.10005751, -0.50858349, 0.36911082, -0.051783592, 0.071038425, -0.11148521, -0.53392905, 0.36009926, 0.079382658, 0.10371411, -0.50254786, 0.17596281, -0.0092926025, -0.00064194202, -0.014125884, 0.47321141], [0.28647327, 0.26127762, 0.45843053, 0.49775457, 0.3805601, -0.40995055, 0.36980593, 0.033520699, -0.0018056035, 0.016578972, 0.16026449, -0.24952739, -0.3143453, -0.1315895, 0.007999897, 0.11293548]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_133": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[0.2794218, 0.29263318, 0.42604703, -0.24461824], [0.32469118, -0.2654639, 0.17872995, 0.06222689], [-0.07604656, -0.29360557, -0.462821, 0.3731665], [0.27989155, 0.53663385, -0.12042063, 0.34913152], [-0.50028926, 0.08958912, 0.50753117, -0.03860039], [0.12980306, -0.47548878, 0.5443562, -0.41777247], [0.16824102, -0.5271052, -0.18454444, 0.2987221], [0.22610295, -0.3761598, 0.4983195, 0.31664205], [-0.36606842, -0.3778124, 0.01393354, 0.23516071], [0.26510388, -0.47218412, 0.42749757, 0.22174352], [0.4139307, 0.09682184, -0.1447433, -0.07231569], [0.01711905, -0.18132755, 0.03224993, 0.2071482], [0.12195373, -0.52764714, 0.48840046, -0.21843264], [0.12467605, -0.45452338, 0.05892056, -0.2852741], [-0.5464495, -0.4856094, -0.29271287, 0.10828984], [0.37080926, 0.01543814, 0.10875225, -0.2678996]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_133": {
                "value": {
                    "value": "[[0.2794218, 0.29263318, 0.42604703, -0.24461824], [0.32469118, -0.2654639, 0.17872995, 0.06222689], [-0.07604656, -0.29360557, -0.462821, 0.3731665], [0.27989155, 0.53663385, -0.12042063, 0.34913152], [-0.50028926, 0.08958912, 0.50753117, -0.03860039], [0.12980306, -0.47548878, 0.5443562, -0.41777247], [0.16824102, -0.5271052, -0.18454444, 0.2987221], [0.22610295, -0.3761598, 0.4983195, 0.31664205], [-0.36606842, -0.3778124, 0.01393354, 0.23516071], [0.26510388, -0.47218412, 0.42749757, 0.22174352], [0.4139307, 0.09682184, -0.1447433, -0.07231569], [0.01711905, -0.18132755, 0.03224993, 0.2071482], [0.12195373, -0.52764714, 0.48840046, -0.21843264], [0.12467605, -0.45452338, 0.05892056, -0.2852741], [-0.5464495, -0.4856094, -0.29271287, 0.10828984], [0.37080926, 0.01543814, 0.10875225, -0.2678996]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/layers/encoders/transformer_encoder_test.py": {
        "tensorflow": {
            "convert_to_tensor_40": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_50": {
                "variable": {
                    "value": "input_padding",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_55": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[-0.04742211, -0.42928827, -0.54485893, -0.7514334], [0.3391741, 0.61141425, -0.23809844, 0.27043575], [-0.7315594, 0.8002729, -0.2958873, 0.698168], [-0.59683925, -0.38270262, -0.59893274, -0.4040773]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_55": {
                "value": {
                    "value": "[[-0.04742211, -0.42928827, -0.54485893, -0.7514334], [0.3391741, 0.61141425, -0.23809844, 0.27043575], [-0.7315594, 0.8002729, -0.2958873, 0.698168], [-0.59683925, -0.38270262, -0.59893274, -0.4040773]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_62": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[0.5907243, -0.5555184, 0.5612393, -0.2724994, 0.23405826, 0.38096863, -0.02200276, -0.26264596, 0.36556423, 0.10351193, -0.1946517, 0.60423344], [0.16057128, -0.4464733, 0.32041794, -0.30858415, 0.26626736, 0.579398, -0.19076341, 0.1072132, -0.43820834, 0.05253071, 0.08801651, -0.4995584], [-0.48593724, 0.1275987, 0.15794194, -0.4632662, 0.54038125, -0.45666856, -0.16076824, 0.43855423, 0.32468224, -0.1931965, -0.42853987, 0.2411524], [-0.32923162, -0.06395793, 0.33392805, -0.46701026, -0.06507087, -0.61020637, 0.545703, -0.23786944, -0.2854141, -0.1698403, -0.1244911, 0.40745395]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_62": {
                "value": {
                    "value": "[[0.5907243, -0.5555184, 0.5612393, -0.2724994, 0.23405826, 0.38096863, -0.02200276, -0.26264596, 0.36556423, 0.10351193, -0.1946517, 0.60423344], [0.16057128, -0.4464733, 0.32041794, -0.30858415, 0.26626736, 0.579398, -0.19076341, 0.1072132, -0.43820834, 0.05253071, 0.08801651, -0.4995584], [-0.48593724, 0.1275987, 0.15794194, -0.4632662, 0.54038125, -0.45666856, -0.16076824, 0.43855423, 0.32468224, -0.1931965, -0.42853987, 0.2411524], [-0.32923162, -0.06395793, 0.33392805, -0.46701026, -0.06507087, -0.61020637, 0.545703, -0.23786944, -0.2854141, -0.1698403, -0.1244911, 0.40745395]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_76": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[-0.14616564, 0.30248666, 0.5319947, 0.5002098, 0.2705282, -0.21612385, -0.3336154, 0.03436899, 0.26958936, 0.26834202, 0.0843057, -0.50728637, 0.19995207, -0.3930181, -0.4985036, 0.33232063], [-0.04522616, -0.20491397, -0.19712418, 0.18106508, 0.33636385, 0.4030161, -0.30252987, 0.11853886, 0.2238034, 0.3744824, -0.28127617, -0.03388816, 0.32239246, -0.25639355, 0.02382994, 0.34818083], [0.4456296, -0.48834273, -0.26576972, 0.28717202, 0.02354515, -0.2434513, -0.26277977, -0.05434859, 0.09830189, 0.08207488, -0.28704825, -0.19418713, 0.47731507, 0.14538354, -0.3832153, -0.5143249], [0.33276683, -0.248025, -0.13612089, -0.15473047, 0.33012676, -0.39191568, -0.32679468, 0.52579904, -0.17942387, -0.39317977, 0.13891649, -0.17397407, -0.19002154, 0.05117792, 0.34706026, 0.11179692]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_76": {
                "value": {
                    "value": "[[-0.14616564, 0.30248666, 0.5319947, 0.5002098, 0.2705282, -0.21612385, -0.3336154, 0.03436899, 0.26958936, 0.26834202, 0.0843057, -0.50728637, 0.19995207, -0.3930181, -0.4985036, 0.33232063], [-0.04522616, -0.20491397, -0.19712418, 0.18106508, 0.33636385, 0.4030161, -0.30252987, 0.11853886, 0.2238034, 0.3744824, -0.28127617, -0.03388816, 0.32239246, -0.25639355, 0.02382994, 0.34818083], [0.4456296, -0.48834273, -0.26576972, 0.28717202, 0.02354515, -0.2434513, -0.26277977, -0.05434859, 0.09830189, 0.08207488, -0.28704825, -0.19418713, 0.47731507, 0.14538354, -0.3832153, -0.5143249], [0.33276683, -0.248025, -0.13612089, -0.15473047, 0.33012676, -0.39191568, -0.32679468, 0.52579904, -0.17942387, -0.39317977, 0.13891649, -0.17397407, -0.19002154, 0.05117792, 0.34706026, 0.11179692]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_94": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.convert_to_tensor([[0.18234771, 0.23902518, 0.4304248, -0.05616844], [-0.01435661, 0.11098373, 0.5370636, -0.5271752], [-0.3239155, 0.5083337, 0.43396413, -0.47642848], [0.31562793, -0.04991594, 0.530545, -0.51263183], [0.10357869, 0.2883237, 0.16929054, 0.18414849], [-0.30361128, -0.2045235, 0.05544132, 0.22116774], [0.05548936, -0.11504656, 0.13726586, -0.13652831], [0.5011635, 0.45315623, -0.35243145, 0.17173672], [-0.52015716, 0.42873853, -0.09965438, -0.45107275], [0.00233686, 0.2797522, 0.2702785, 0.33721972], [0.10216439, -0.14768293, -0.5122431, -0.3882924], [-0.44032216, -0.09983957, -0.41019306, -0.26434696], [0.50977015, -0.18238857, 0.54663074, 0.05787665], [0.3197481, -0.45845133, -0.14075449, -0.33339915], [0.10717738, 0.28995162, 0.47179937, 0.01342988], [0.37111026, -0.31352338, 0.37098122, 0.3895113]], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_94": {
                "value": {
                    "value": "[[0.18234771, 0.23902518, 0.4304248, -0.05616844], [-0.01435661, 0.11098373, 0.5370636, -0.5271752], [-0.3239155, 0.5083337, 0.43396413, -0.47642848], [0.31562793, -0.04991594, 0.530545, -0.51263183], [0.10357869, 0.2883237, 0.16929054, 0.18414849], [-0.30361128, -0.2045235, 0.05544132, 0.22116774], [0.05548936, -0.11504656, 0.13726586, -0.13652831], [0.5011635, 0.45315623, -0.35243145, 0.17173672], [-0.52015716, 0.42873853, -0.09965438, -0.45107275], [0.00233686, 0.2797522, 0.2702785, 0.33721972], [0.10216439, -0.14768293, -0.5122431, -0.3882924], [-0.44032216, -0.09983957, -0.41019306, -0.26434696], [0.50977015, -0.18238857, 0.54663074, 0.05787665], [0.3197481, -0.45845133, -0.14075449, -0.33339915], [0.10717738, 0.28995162, 0.47179937, 0.01342988], [0.37111026, -0.31352338, 0.37098122, 0.3895113]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/layers/search/beam_search_test.py": {
        "tensorflow": {
            "one_hot_74": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[on_entry]",
                    "type": "List",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_entries",
                    "type": "variable",
                    "possible_values": []
                },
                "on_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "off_value": {
                    "value": "compat.FLOAT_MIN",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_100": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[on_entry]",
                    "type": "List",
                    "possible_values": []
                },
                "depth": {
                    "value": "num_entries",
                    "type": "variable",
                    "possible_values": []
                },
                "on_value": {
                    "value": "compat.FLOAT_MIN",
                    "type": "Attribute",
                    "possible_values": []
                },
                "off_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "expand_dims_126": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensor, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_138": {
                "variable": {
                    "value": "tensor_1d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.randint(0, 10, (batch_size,))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_139": {
                "variable": {
                    "value": "tensor_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.rand(batch_size, dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_140": {
                "variable": {
                    "value": "tensor_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.rand(batch_size, time_step, dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_141": {
                "variable": {
                    "value": "tensor_4d_bias",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.rand(batch_size, 1, 1, dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_142": {
                "variable": {
                    "value": "tensor_4d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy.random.rand(batch_size, time_step, num_heads, dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_143": {
                "variable": {
                    "value": "tensor_3d_from_4d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensor_4d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(numpy.random.rand(batch_size, time_step, num_heads, dim), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, time_step, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pack_sequence_as_50": {
                "structure": {
                    "value": "tensors",
                    "type": "variable",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "tf.nest.map_structure(_stack, tf.nest.flatten(tensors))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_78": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=0.0, off_value=compat.FLOAT_MIN)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=compat.FLOAT_MIN, off_value=0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "squeeze_79": {
                "input": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=0.0, off_value=compat.FLOAT_MIN)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=compat.FLOAT_MIN, off_value=0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_104": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=0.0, off_value=compat.FLOAT_MIN)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=compat.FLOAT_MIN, off_value=0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "compat.CUSTOM_GLOBAL_FLOATX",
                            "Attribute"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "squeeze_105": {
                "input": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=0.0, off_value=compat.FLOAT_MIN)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "tf.one_hot([on_entry], num_entries, on_value=compat.FLOAT_MIN, off_value=0.0)",
                            "Call"
                        ],
                        [
                            "tf.cast(bias, dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_129": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tensor, axis=axis)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tile_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] * tensor.get_shape().ndims",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_34": {
                "variable": {
                    "value": "stacked_x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.tile(x, [1, beam_size, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "final_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[beam_size * batch_size, -1, last_dim]",
                            "List"
                        ],
                        [
                            "[batch_size * beam_size, last_dim]",
                            "List"
                        ]
                    ]
                }
            },
            "map_structure_52": {
                "func": {
                    "value": "_stack",
                    "type": "variable",
                    "possible_values": []
                },
                "*structure": {
                    "value": "tf.nest.flatten(tensors)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_27": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "flatten_53": {
                "structure": {
                    "value": "tensors",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_31": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "tile_34": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, beam_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_38": {
                "tensor": {
                    "value": "tf.tile(x, [1, beam_size])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "final_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[beam_size * batch_size, -1, last_dim]",
                            "List"
                        ],
                        [
                            "[batch_size * beam_size, last_dim]",
                            "List"
                        ]
                    ]
                }
            },
            "reshape_153": {
                "tensor": {
                    "value": "tf1codebase_stack_beam_size(tensor_3d_from_4d, beam_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, time_step, num_heads, dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_38": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, beam_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_40": {
                "tensor": {
                    "value": "tf.transpose(tf.tile([x], [beam_size, 1]))",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_41": {
                "a": {
                    "value": "tf.tile([x], [beam_size, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_45": {
                "input": {
                    "value": "_stack(tf.squeeze(x, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_41": {
                "input": {
                    "value": "[x]",
                    "type": "List",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[beam_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_46": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst/models/transformer_test.py": {
        "tensorflow": {
            "convert_to_tensor_32": {
                "value": {
                    "value": "[[0, 1, 1, 7], [1, 7, 7, 7]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_34": {
                "value": {
                    "value": "[[0, 0, 0, 0.0], [0, 0, 1, 1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_35": {
                "value": {
                    "value": "[[3, 0, 1], [3, 2, 4]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_36": {
                "value": {
                    "value": "[[0, 1, 4], [2, 4, 4]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_37": {
                "value": {
                    "value": "[[0, 0, 0.0], [0, 0, 1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_45": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.29354253, -0.23483634, 0.25630027, -0.02696097, -0.5017841, -0.01427859, 0.64076746, 0.10676116], [-0.19711176, -0.20760003, -0.48422408, -0.0074994, -0.31429327, 0.00126553, -0.17251879, 0.29386985], [0.38033593, -0.27076742, 0.2611575, 0.66763735, 0.5333196, -0.52800345, -0.5451049, 0.5960151], [-0.38007882, 0.47841036, 0.11322564, 0.3999585, -0.5566431, -0.6169907, 0.5290351, -0.48975855], [0.24198133, -0.1712935, -0.13487989, 0.03922045, -0.27576318, 0.15308863, 0.18018633, -0.49891895]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_58": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([-0.12844944, 0.70201373, 0.47467923, 0.17776501, -0.57099354])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_63": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.28932106, 0.04174006, 0.32917994, -0.01771283, -0.32744384, 0.4569562, -0.4678616, 0.00129563], [-0.4225411, -0.59086347, -0.0714885, 0.51049083, -0.5401395, 0.3862279, -0.53301275, 0.30440414], [-0.19314134, 0.09168714, -0.5058322, -0.42353332, 0.5074443, 0.03560042, 0.26724458, 0.33088684], [-0.5153856, -0.38528442, -0.20011288, 0.4713922, 0.13764167, -0.18305543, -0.43612635, 0.5469119], [-0.54713076, 0.32743508, 0.38312858, -0.5525645, 0.591134, 0.1707223, 0.15555906, -0.42832434], [-0.5138424, -0.21375301, -0.46360433, -0.6103692, -0.50063866, 0.24583805, -0.5414497, -0.01820809], [0.3424672, -0.38758308, 0.05292654, 0.10646945, -0.09475929, 0.5051289, 0.16801137, 0.03101033], [-0.10960919, 0.20824891, -0.02183038, -0.06829894, 0.48780817, -0.18522224, 0.22240955, -0.21551234]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_83": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.31903958, 0.41097552, 0.35810417, 0.4822548, 0.5416022, 0.02170408, 0.32241964, -0.54333895], [0.5172518, 0.14113712, 0.44610864, -0.43546906, 0.49923056, 0.23127198, 0.310534, 0.3501947], [0.5763511, -0.4778806, 0.3984726, 0.13659805, -0.05111057, 0.4764889, 0.05881822, -0.37829816], [-0.33052838, -0.3291011, -0.59498054, 0.2654276, -0.5715602, 0.01546502, 0.04336095, 0.13782066], [-0.32840976, -0.37728345, -0.49385822, -0.49648887, 0.4832974, 0.07143259, -0.17042065, 0.43592864], [0.31292784, 0.01520997, 0.40785295, -0.12775904, 0.03555053, -0.35662168, -0.5096859, 0.33710766], [-0.36864457, 0.30672514, -0.4093505, -0.4461822, -0.41201153, 0.12536913, -0.3134546, -0.110695], [0.50774044, 0.25777447, -0.18048626, -0.30132556, 0.3435768, 0.49845392, -0.21432358, -0.05989999]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_103": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.24556783, -0.10109329, -0.18614727, -0.35749245, 0.07600775, -0.30707863, 0.11381295, -0.21648653, -0.32361317, 0.04083973, 0.00325903, 0.17453268, -0.38458756, -0.12808836, -0.30286443, -0.28138128, 0.3906658, 0.2981322, 0.1857591, -0.10963717, 0.13652292, -0.42696893, -0.32537884, -0.17609134], [0.00684109, 0.40689567, 0.22115704, -0.22863819, -0.22739726, 0.3783851, -0.37274942, -0.21842214, -0.22557294, -0.07110339, 0.3998916, -0.0190008, 0.27676454, -0.19919433, 0.2616723, -0.41782314, -0.2811813, -0.3239204, 0.13037983, 0.10246852, -0.14516768, -0.13455674, -0.20624177, 0.30381766], [-0.36161476, 0.3910825, 0.11459449, -0.19012608, -0.1930628, -0.09042051, 0.04295725, -0.09732714, -0.27065122, -0.1735073, -0.11896703, -0.2472982, -0.24865237, 0.0597097, -0.23580097, -0.402398, -0.04311767, -0.14832097, 0.25989994, -0.03256506, -0.3376931, 0.35324004, 0.01395121, -0.28511477], [0.33902344, -0.16730174, 0.2059339, -0.0727739, -0.24657604, 0.01062217, -0.21674432, 0.11485538, 0.23314235, -0.30125052, 0.32238856, -0.2450316, 0.03718695, -0.276408, 0.23392966, -0.07773718, 0.3429754, -0.19731745, 0.37889633, 0.34160677, 0.05413216, 0.03037485, -0.3704696, 0.28774682], [-0.41983247, 0.1209394, -0.03301042, 0.20576969, -0.28212637, -0.25600716, -0.09135348, -0.19963133, -0.1577549, -0.13313296, -0.02467829, 0.39583513, -0.21820472, 0.10990372, -0.42987105, -0.3018305, -0.33682942, -0.04609847, -0.0978007, -0.35909522, 0.35906085, -0.38199574, -0.02560577, 0.4065493], [-0.39747363, -0.21786559, 0.4050602, 0.29975984, -0.03308517, -0.05114299, 0.23231843, -0.42908302, -0.09869319, -0.3929163, 0.14195767, -0.04656759, 0.2699246, 0.1801227, 0.14472279, -0.4127182, -0.4004244, -0.10136119, 0.4069151, 0.3895177, -0.15835935, -0.13569432, -0.38402212, -0.16429195], [-0.1027582, 0.02577147, 0.39300737, -0.10241205, -0.4256417, 0.33153847, -0.0325374, -0.13393977, 0.05391803, -0.20058648, -0.25471783, 0.08702543, -0.09722248, 0.02570912, -0.279415, 0.04044545, -0.27716812, 0.19806209, 0.22688219, -0.30685633, 0.00624642, 0.14048973, -0.2722684, 0.39918897], [-0.19335268, 0.38261148, 0.30058286, 0.25313148, 0.27221575, 0.37937936, 0.1745182, 0.14772478, -0.27204615, 0.38106957, 0.36370513, 0.16695651, -0.40864846, -0.14278689, 0.34316894, 0.41350552, -0.42566204, -0.22474506, -0.18263665, 0.11183658, -0.12859318, 0.02102521, -0.1425604, 0.11403349]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_146": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.38400275, 0.11049551, 0.19255298, 0.45194864, -0.02915239, 0.31835914, -0.3630433, 0.11081731, -0.02559841, 0.38685995], [0.42969477, 0.2031151, 0.5144137, -0.07936049, 0.31766498, 0.5058452, 0.44898677, 0.16335446, 0.3953011, 0.4361714], [0.04883695, -0.56701475, 0.09635973, -0.50472724, -0.1245037, -0.37787604, -0.21818402, 0.16247958, -0.14578387, -0.41005552], [0.13449967, 0.05132979, -0.5468524, -0.17919052, 0.01128888, 0.09902984, 0.23214585, -0.08920336, 0.55008626, 0.50717974], [-0.1738911, -0.24616602, 0.18358463, -0.11349753, 0.15567136, -0.45293823, 0.29155105, 0.49324703, 0.01795202, 0.255095], [-0.23427847, -0.47127584, 0.47553408, 0.17752594, -0.4635463, -0.05620468, -0.5232727, 0.39365137, -0.38289946, 0.05879569], [0.25051618, 0.26999742, -0.24446961, 0.03792298, 0.01752973, -0.41537094, 0.44205165, -0.11403576, -0.3807313, -0.23905703], [-0.33319134, -0.47972375, 0.526567, 0.34260195, -0.01981884, -0.02918285, -0.02829635, -0.5294999, 0.563005, 0.05829275]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_165": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.2340402, -0.10299325, 0.03826767, -0.00556576, 0.16777557, -0.48395926, -0.21232244, 0.540642], [-0.5568968, -0.24176422, 0.17467064, 0.3885694, 0.4655552, -0.15393665, -0.4475953, -0.3920542], [0.07647067, 0.2340278, -0.13460535, -0.34944105, 0.0448994, 0.35044646, -0.5451377, -0.39633614], [0.16932797, 0.4503368, -0.48202705, -0.05000919, -0.3586144, 0.07879007, -0.47378975, -0.5153118], [-0.4939471, -0.49206224, 0.33845508, -0.5155843, -0.07823312, 0.30778152, -0.14456016, -0.49705222], [0.23529834, 0.39454746, -0.3392254, -0.31639364, 0.39075094, 0.55396605, 0.03435838, 0.3698709], [-0.01985615, -0.14796564, -0.04773241, 0.1197027, 0.02213496, 0.24299401, 0.23960501, 0.45019186], [-0.1280163, -0.11015153, 0.19618726, -0.55472195, -0.45635638, -0.15839794, 0.28029287, 0.00874251], [-0.18816125, -0.16009945, -0.14088362, 0.41544813, -0.20673174, 0.01065433, 0.03431308, -0.17323837], [-0.30255532, 0.5155908, 0.23801541, 0.46748185, -0.42719585, -0.49111396, 0.3950773, -0.27734205]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_189": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.42618555, -0.09034979, -0.23231441, -0.43777925, 0.45706886, -0.59829664, 0.4076385, 0.23851973], [0.05634236, 0.17002487, -0.08434552, 0.31617373, 0.03625625, 0.5910465, -0.6076178, -0.2687951], [-0.14819229, -0.27034125, 0.2064324, -0.19751346, 0.21064728, 0.29283345, 0.23406833, 0.10519284], [0.31500018, -0.4173568, -0.00893188, -0.26349744, 0.15418595, -0.399687, -0.22666007, -0.6096985], [-0.1316917, -0.36008307, -0.43647486, 0.10060841, -0.16681895, -0.35083786, 0.26369733, -0.12640283], [0.5797457, -0.59191436, -0.57749504, -0.54847366, -0.20692074, 0.4509862, -0.01773721, 0.1577], [0.4081785, 0.5246411, -0.5135473, -0.23788959, -0.26497075, -0.23121881, 0.35329401, 0.42074102], [-0.46347424, 0.56120163, -0.2939334, 0.2747522, 0.56474787, 0.5690356, 0.19718772, -0.09090984]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_209": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.04137263, 0.4122521, 0.07474831, -0.42290825, 0.01918331, -0.0367808, 0.20840707, -0.19495474, -0.36590886, 0.12961635, -0.42065755, 0.21793994, 0.15142605, 0.05064282, 0.3728448, 0.4305556, -0.19640265, -0.13260049, 0.41600618, -0.30270132, 0.28347465, -0.2972833, -0.22339822, -0.4168277], [-0.42739302, 0.0618836, 0.30369553, -0.01105291, -0.2725063, 0.18827173, -0.07787129, 0.29560563, 0.11015823, -0.2556733, 0.3800684, 0.20649257, -0.03591421, 0.35618058, -0.39821273, 0.0430806, -0.37791556, -0.05824929, 0.29839876, 0.06364432, -0.28479278, 0.37887844, -0.19407392, -0.24432379], [-0.2754909, 0.21458694, 0.2540948, -0.06881586, 0.2752199, -0.42529625, -0.18034342, -0.2641306, 0.08662507, -0.19239433, -0.01936874, -0.42879313, 0.2515919, 0.05828688, -0.35050425, 0.19613442, 0.10595468, -0.06380415, 0.14495179, -0.26701403, 0.33381835, 0.11836699, 0.10901466, -0.19060831], [-0.08439368, -0.1435681, -0.38354927, 0.29710206, 0.39372167, 0.29005793, 0.22486511, 0.10090873, -0.27392572, 0.12495866, -0.38597837, 0.37385282, -0.15801638, 0.34403047, 0.05333185, -0.19141418, -0.43146238, -0.09826642, 0.39207748, 0.02903318, -0.0447951, -0.140995, 0.12605539, -0.27343658], [-0.14746845, 0.26028237, -0.14068425, -0.02098277, -0.34208745, -0.36879313, 0.3709258, -0.18287906, -0.38343272, 0.01450509, 0.33475187, 0.19835839, -0.02770916, -0.19535396, 0.24291894, 0.40508488, 0.1228393, 0.35743287, -0.31064862, -0.2738737, -0.08634344, 0.17820784, 0.2404854, -0.21379128], [0.32416382, 0.23761937, -0.2714734, 0.01659575, 0.12218228, 0.08210799, 0.39640966, 0.04924238, -0.10259542, -0.42907375, -0.0455032, -0.04837993, -0.25596887, -0.16206014, -0.40621698, 0.10435715, 0.2919118, -0.3757009, 0.12669042, -0.06276929, 0.08691922, 0.01388359, 0.2609237, 0.14391366], [-0.37109214, 0.08338836, 0.41613457, 0.09220138, 0.14755598, -0.3846822, -0.32047546, -0.11989969, 0.04941088, 0.3733643, -0.22359593, 0.01040426, -0.13329476, 0.03873777, 0.25831434, 0.04679212, -0.34217292, -0.23983024, 0.36969563, 0.35033616, 0.05077001, 0.32096437, 0.2942368, -0.06438693], [0.04559416, 0.3110021, 0.10469446, -0.09112707, -0.21549596, -0.08703595, 0.19566664, -0.27119064, -0.31012705, -0.3460493, 0.20034257, 0.34390983, -0.30513322, 0.30294558, 0.15193626, -0.13466576, -0.15653265, -0.04085603, -0.04187199, -0.3818181, 0.35413423, -0.11948714, 0.12659273, 0.33491793]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_252": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.16969907, 0.538725, -0.47220635, -0.39862955, 0.5590445, -0.57381415, 0.55189013, -0.1241096, -0.1750552, 0.07282209], [-0.04967839, -0.29894733, 0.48699057, -0.26354527, -0.11624891, 0.00518572, 0.06982511, 0.21453673, 0.52487314, 0.50849414], [-0.29642364, -0.1552884, 0.37976956, -0.09915912, 0.21726537, 0.09865189, -0.3579256, 0.2882828, -0.5435448, 0.34120053], [-0.16734263, -0.30591854, -0.48299694, 0.36032963, 0.3083346, 0.32025862, -0.0323239, -0.03540909, 0.19812691, 0.56041396], [0.08146846, -0.4032659, 0.43548548, -0.505157, 0.29625255, 0.20229155, -0.2784496, -0.16810659, 0.00465661, -0.46176454], [0.25855982, -0.44527876, -0.05630809, 0.44814825, 0.4672327, 0.07238638, 0.23067313, -0.31218028, 0.5251508, -0.46993703], [0.36020505, 0.48421, 0.04297256, 0.07937276, 0.39654619, 0.08334208, -0.44477332, 0.15238297, -0.14505252, 0.5653666], [0.17023551, 0.05648631, -0.5590816, -0.4013535, 0.00587964, -0.41224653, -0.5178517, -0.44671488, -0.13213646, -0.16264695]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_271": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.08363676, 0.443043, -0.20048293, 0.5397774, -0.08774236, 0.51563346, 0.44048393, 0.05069989], [-0.39923793, 0.27010256, 0.3120396, 0.15755522, 0.09888685, 0.09209388, 0.23463911, -0.20073885], [0.39725387, 0.3083284, 0.04398292, -0.5214203, 0.1661511, 0.32843602, 0.535144, -0.30733716], [-0.52302945, 0.09949869, -0.20001906, -0.4563232, 0.10634673, -0.0867821, 0.2130729, 0.15544009], [-0.16209882, 0.47079623, -0.36366975, -0.39391387, -0.13728681, 0.36896384, -0.1279692, -0.24792987], [0.4540763, 0.43117046, 0.34526706, -0.44267043, -0.2801833, 0.09091371, 0.31143135, -0.46842438], [-0.3841617, 0.3537798, -0.456631, -0.07963607, 0.18825197, 0.34253138, 0.00311643, -0.39619297], [0.19681883, 0.02538323, 0.49230504, -0.54670614, -0.16814995, 0.26320857, -0.2583875, -0.45845556], [0.10035574, -0.33199033, -0.06377029, -0.38322705, 0.18576187, 0.30481344, 0.30165493, -0.56413436], [0.13095653, 0.5693759, -0.34928244, -0.00579017, 0.45523894, 0.45559692, -0.4755445, -0.5578483]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_295": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.41402858, -0.2655511, 0.21687216, -0.05976683, -0.24678236, -0.55986947, -0.10050869, 0.36443913], [-0.31218863, -0.08026814, -0.3503775, -0.2830528, 0.19764078, 0.07665694, -0.22002375, 0.58338326], [0.36593944, 0.47826117, -0.3155697, 0.22407556, -0.2367759, 0.5582003, -0.01308447, 0.02416301], [-0.5932773, 0.54228276, 0.07887, -0.36850107, -0.57571995, 0.52597564, -0.12966257, -0.06494093], [-0.5416004, -0.4324838, 0.5738513, 0.23318034, -0.5079873, 0.44698435, 0.1884408, -0.4100449], [-0.41715717, -0.47995192, 0.27436692, 0.45396346, -0.32279193, -0.52322745, -0.22139937, 0.46218258], [0.04606843, -0.48210734, -0.09731799, 0.1566211, 0.3348605, 0.53798, 0.2066397, 0.17096424], [0.5118193, -0.26824263, 0.0513528, -0.22810039, -0.02520913, -0.25055912, -0.21125275, 0.01200509]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_315": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.24635717, -0.35896713, 0.39586702, -0.03602478, 0.27512792, 0.23269245, 0.29596278, -0.13523233, 0.3122929, 0.01758271, 0.19535479, 0.42010358, 0.3058509, -0.27858323, -0.09621406, -0.28900337, -0.13637415, 0.2554522, -0.13693246, 0.23890129, 0.22502461, -0.00342193, -0.37178487, 0.04001474], [-0.06197342, 0.28338936, 0.10876206, 0.21770415, -0.2445885, -0.37382, 0.24960616, -0.28366768, 0.33277413, 0.24190459, 0.28501043, 0.2390792, -0.21722354, -0.09839588, -0.07514569, 0.08434585, -0.17455393, -0.39285085, 0.3604456, -0.04403484, 0.17325982, 0.266789, 0.27641353, 0.2629675], [0.31777444, -0.18994613, 0.07876977, 0.19285682, -0.3603885, -0.07359949, 0.39663008, 0.12972179, 0.32373634, -0.28222823, 0.07523808, 0.06840143, 0.2784874, -0.32616594, -0.37903282, 0.11678198, -0.2441357, -0.15710688, -0.00175741, -0.40035915, -0.09226942, 0.08680966, 0.25157234, 0.00786397], [-0.06718335, -0.21293627, 0.23377934, -0.07398105, -0.04577821, 0.4012753, -0.36116257, 0.27832034, 0.20620236, -0.15069339, 0.16214707, -0.42465132, 0.25478825, -0.08184978, 0.35768852, -0.12693104, -0.1273953, -0.3078432, 0.33522883, 0.34014687, -0.08295268, -0.36013618, -0.08690733, -0.07324457], [-0.0609462, 0.06251469, -0.04659629, 0.3167083, -0.02005619, 0.32234064, 0.35482922, -0.0772118, 0.3867505, 0.3833268, -0.2319926, -0.417385, -0.38126078, 0.37261078, 0.0596388, 0.09162065, -0.23212992, -0.25532508, -0.3144799, 0.28181675, 0.01341996, 0.19811288, -0.21834192, -0.39427295], [-0.13712531, 0.2572454, 0.2866812, 0.10211042, 0.06285053, -0.3894317, -0.04404226, -0.39091605, -0.16874191, 0.08648756, -0.30481267, 0.16437915, -0.23644, 0.07409009, -0.39548072, 0.35895494, 0.03730175, 0.4324384, -0.2938407, 0.38754657, -0.3012539, -0.11363283, -0.28678095, -0.1598432], [0.00581551, 0.14337441, -0.04939786, 0.11189356, 0.31094417, 0.01152644, 0.27642164, -0.09637818, -0.09211436, -0.16248363, 0.39744857, -0.4116622, -0.05383742, 0.36805126, 0.14875862, 0.1099014, 0.371321, -0.41085994, -0.18536153, 0.20604655, -0.13384223, -0.14118773, -0.1283133, -0.39778396], [-0.01566258, -0.4047187, -0.37664068, -0.19478449, 0.09347895, -0.36023095, 0.21561489, -0.33089578, -0.2711009, -0.03610542, -0.3796572, 0.306676, 0.27266768, 0.22641936, -0.30573982, -0.18740533, -0.34311372, -0.22143514, -0.41552392, 0.42686227, -0.1086936, 0.03383243, -0.15354112, -0.26625448]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_359": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.1279256, -0.2419937, -0.5854874, 0.57889825, -0.5364065, 0.23631936, -0.49949092, -0.30174196], [0.00957078, -0.49736997, -0.4237002, 0.0218854, -0.17279565, -0.5768471, -0.18963015, 0.10355526], [0.11799914, -0.292151, -0.36201292, -0.266887, 0.15741825, -0.11333472, -0.03553617, 0.0177772], [-0.39861536, 0.17891657, -0.22581154, 0.07609612, -0.34631196, 0.26317436, 0.41848058, 0.27004486], [-0.37255478, -0.20311174, 0.5176136, -0.54658747, 0.23746693, -0.03754926, 0.04889613, -0.41350323], [0.2125783, -0.536155, -0.19549471, 0.36943835, 0.24639928, 0.07458866, 0.28700095, -0.36578485], [-0.2657523, -0.2433975, -0.56110847, -0.2861476, -0.19445652, 0.21033949, -0.30730212, 0.40339154], [0.31910568, 0.0055629, 0.03742898, -0.5246967, 0.35341913, 0.3554458, 0.5315719, 0.13093019]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_379": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.51545686, 0.0990485, 0.29777205, -0.28110617, -0.26308733, 0.2853282, -0.31212774, 0.30727994], [0.5417524, 0.12922692, 0.3285774, -0.02031326, 0.08855647, -0.00454164, 0.02288318, 0.39679402], [-0.09431475, -0.2857204, -0.29803967, 0.28193474, 0.26423824, -0.31383288, -0.25300246, -0.01376557], [0.12011659, 0.55608934, -0.01549584, -0.48516896, -0.44164532, -0.16531923, 0.44081384, -0.54160094], [-0.3235532, 0.55393785, 0.2136209, 0.08658487, 0.02760661, -0.24593821, 0.23313332, -0.03452164], [-0.3659288, -0.55161166, -0.5393511, -0.08154327, 0.47045785, -0.2545886, 0.603108, 0.17091894], [-0.41575676, -0.24764174, 0.33940715, -0.49895483, 0.14083397, 0.05251276, 0.09940594, 0.30034548], [-0.5737393, -0.45933425, -0.02393657, -0.12469256, -0.24861848, 0.48773366, -0.38281965, 0.06820959]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_399": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.3608706, -0.16985774, 0.04648876, 0.17727554, -0.32050753, 0.15797412, 0.32923543, -0.19890809, -0.09514797, 0.09165347, -0.08939207, 0.1240828, 0.12936771, -0.48354328, 0.09154546, 0.06640613], [0.26706707, -0.07982218, -0.28840077, -0.15964293, 0.44048142, 0.10202003, -0.19224763, 0.4643935, -0.49145675, 0.28452814, -0.28381097, -0.1886301, 0.3626212, 0.48149836, -0.40126383, 0.01182055], [0.48325312, 0.13339198, 0.08147466, 0.01886415, 0.410465, -0.24456823, -0.04810286, 0.3934772, -0.42655325, -0.12829137, 0.47660065, -0.3516115, -0.11145651, -0.02882326, -0.38462532, 0.16618061], [0.28752756, -0.09809136, -0.06697667, -0.22326052, 0.33962095, -0.06639445, -0.06673455, 0.03969002, 0.03658247, 0.2047621, 0.41957307, -0.27317607, -0.1286192, -0.1504153, -0.08790445, -0.27503848], [0.40700352, -0.13340664, 0.48895872, 0.2091173, -0.4158994, 0.42262292, 0.45204484, 0.31661832, -0.16831684, -0.43958127, 0.40800595, 0.4231466, 0.2662462, 0.4360491, -0.05090606, 0.41579437], [-0.1475159, 0.05631268, 0.43667984, 0.22322762, 0.24188244, -0.2558658, 0.05513358, -0.44220436, 0.47696745, 0.30288208, 0.35236907, -0.46022415, -0.2354449, -0.2824862, 0.1728853, 0.00242376], [-0.19901407, -0.17316806, 0.34936786, 0.05637395, -0.08862174, 0.15412652, 0.14734995, -0.02360725, 0.20836592, 0.10715961, 0.21128082, -0.01028705, 0.27915657, 0.00645471, 0.34993672, 0.46311176], [0.40358865, -0.12622762, 0.11518359, 0.18501854, 0.01984668, 0.45133805, 0.1628021, -0.17971015, -0.16342247, -0.22245312, -0.26478374, 0.160591, 0.4486302, -0.19825566, 0.04753971, 0.12643707]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_434": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.06720757, 0.55263114, -0.37820417, -0.18817183, 0.4967841, 0.5301496, 0.44765162, 0.17229474, 0.02037746, -0.38267606], [0.22507912, 0.08319503, -0.42931908, 0.21395624, 0.4883101, 0.02807504, -0.10768619, -0.47498938, 0.04546309, 0.51695967], [-0.32582825, -0.15555033, -0.35707173, -0.00528497, 0.11157733, -0.4079039, -0.20309281, -0.2786939, -0.00143158, -0.45975608], [0.0592798, -0.297385, 0.35483736, 0.2347272, -0.3477485, 0.26017946, -0.17936438, 0.44473732, -0.28609666, -0.14807671], [-0.3869655, -0.5571348, -0.38598603, -0.41803488, 0.43944812, -0.3425563, 0.25616652, -0.0285089, -0.0508908, -0.54111296], [-0.44107342, -0.5042058, 0.5217055, -0.34677118, 0.475623, 0.18002027, -0.44467062, 0.05279869, -0.30962384, -0.45696396], [-0.11149651, 0.3705026, -0.5126401, 0.06722903, 0.22575969, -0.23028824, 0.2056027, -0.39192414, -0.25298402, 0.4379238], [0.14971024, 0.42451167, 0.37757248, -0.3726549, -0.17506334, -0.46460786, -0.02499455, 0.13482589, -0.12902525, -0.19523734]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_453": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.44042823, 0.45197666, -0.23344472, 0.45998847, -0.17414865, 0.4641745, 0.4826498, -0.1315352], [0.41060203, -0.211938, 0.08441406, 0.2431289, -0.38785285, 0.35918987, 0.07967973, -0.19248444], [0.17039984, 0.01675391, -0.19650468, 0.10323095, -0.02209324, -0.24919105, 0.16697949, 0.11663049], [0.17856616, -0.20257097, 0.3182906, 0.1157276, -0.45809188, -0.13065588, -0.5293646, -0.04682791], [-0.19376227, -0.5453018, -0.0328182, -0.5452718, 0.26869357, 0.13249546, 0.08024281, 0.11003381], [-0.23756227, -0.29575357, -0.50909173, -0.05765748, -0.0089184, 0.489527, 0.0540911, -0.20290643], [-0.43088597, -0.03776497, -0.07004839, 0.3612193, 0.2700277, 0.3630551, -0.35514504, 0.0078786], [-0.3577707, 0.5772364, -0.45408776, 0.04695731, 0.12955356, 0.08641922, -0.06749266, -0.22854668], [0.3447554, -0.50018543, -0.4450423, -0.345627, 0.4853915, -0.38487256, -0.23583022, 0.41968864], [0.5223309, 0.34582454, 0.24228495, 0.4505279, 0.00524783, 0.33739161, 0.1729073, 0.46376586]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_477": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.446121, 0.3940925, 0.49132103, 0.17713946, 0.5267928, 0.33675808, 0.44058722, -0.43157172], [-0.23504972, 0.1617412, 0.2769773, -0.26133326, 0.24745297, -0.0520584, 0.07277727, -0.5577672], [-0.29327726, 0.2514521, 0.32843417, 0.5675153, -0.5442774, -0.24685362, -0.3434327, 0.29523093], [0.25270784, -0.20233193, -0.13284832, 0.28228354, -0.4794641, 0.12789321, -0.39262465, 0.04397899], [-0.60009784, 0.45697302, -0.32597286, -0.03012645, 0.01654047, -0.3432645, -0.52298236, -0.45876426], [-0.19784635, 0.01058447, -0.58458495, -0.5126084, -0.5655494, -0.41740847, -0.19458848, -0.10731643], [-0.5258043, -0.61217636, -0.47019628, -0.3324889, -0.39158016, 0.36343306, -0.36333203, -0.22256723], [0.24401158, -0.13122407, 0.5713683, -0.6086697, 0.12495714, 0.25823617, -0.09232122, 0.5900312]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_496": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.27481452, 0.0116879, 0.36719075, -0.40440372, -0.1954606, -0.2300574, -0.04979965, 0.15613547, 0.32280543, 0.3273132, 0.3912786, 0.4046168, -0.30568987, -0.33408988, 0.15435639, -0.08106208, 0.32937118, -0.34070706, 0.0546439, -0.24983734, 0.0207603, 0.08601627, -0.27549195, 0.20412138], [0.14348724, 0.18185094, 0.167887, -0.3021682, 0.2971051, 0.07907161, -0.37291273, -0.26329404, 0.24814805, -0.00783703, -0.1134795, 0.25298938, -0.0403159, 0.09382078, -0.25310278, 0.42588016, -0.0232923, -0.23894715, 0.26872233, -0.3017637, 0.35517278, 0.4123756, 0.35715845, -0.2612683], [0.251209, 0.30718777, -0.09743929, 0.37868705, -0.3782806, -0.10440734, -0.20695278, -0.42843944, 0.11033848, 0.4274877, 0.21334943, 0.3301848, 0.31885192, 0.3971382, -0.09676668, 0.22961542, 0.28164133, 0.28870395, 0.24603716, 0.13049194, -0.26271415, 0.3598245, 0.17889282, -0.09679371], [0.18480167, -0.423978, 0.28147706, 0.20233068, 0.07700345, 0.3950176, 0.16953233, -0.2767653, -0.0351927, -0.3871778, -0.10333872, -0.38401458, 0.08614203, -0.09418231, 0.1258482, 0.41503003, -0.23736389, 0.3829991, 0.20315519, -0.0506267, 0.02750155, 0.18088666, 0.32316545, 0.07156941], [-0.3365289, 0.07633492, 0.18811491, 0.12218675, -0.01712888, 0.11047456, 0.36789885, 0.07453135, 0.35507998, 0.32413712, 0.06988475, -0.316629, -0.09560555, -0.3577586, 0.11743674, -0.1154238, 0.40550312, -0.28373045, -0.28391486, 0.22130796, 0.19461158, 0.34828517, 0.3402731, 0.42168418], [0.22959384, -0.09466672, 0.13875905, 0.06585011, -0.08454975, -0.25139913, 0.24867311, -0.19710684, -0.38250047, 0.05279905, 0.09058633, 0.05691019, -0.43189391, -0.00754103, -0.42296854, -0.17274147, -0.1439153, -0.16499841, 0.4218262, 0.27872702, 0.269519, -0.284347, 0.00676736, -0.24074432], [-0.43105984, -0.18570966, -0.25307292, -0.19746126, 0.11514279, 0.101432, -0.12518859, 0.10440406, -0.42490405, 0.05715063, -0.2929991, 0.2661244, -0.12404522, 0.06171378, -0.15130952, 0.29441395, -0.41733328, 0.08141616, -0.34677923, -0.05524972, 0.18937346, -0.41702378, -0.06657425, 0.27120963], [0.07061633, 0.23987249, 0.22944674, 0.08817294, 0.22188488, -0.37523416, -0.3636308, 0.26619443, 0.05310896, -0.3865527, -0.0594418, 0.10325739, 0.14090309, -0.02832022, 0.09751496, -0.0530881, -0.04750797, -0.32113245, 0.25775167, -0.2249531, 0.17214248, -0.20723793, 0.05858463, -0.1042015]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_539": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.07463336, 0.0563764, 0.26746285, 0.58845574, 0.37224877, 0.22249967, -0.24321106, -0.48173416], [-0.30540833, 0.24408221, -0.06326765, -0.11097288, 0.10069352, -0.04288429, -0.44742495, 0.166543], [0.14135772, -0.26862615, -0.50849557, 0.5784133, -0.40443277, 0.51631385, -0.07799548, 0.28732932], [-0.09749961, 0.40039545, -0.06118071, -0.15212688, 0.34009832, 0.5772465, 0.48222512, -0.25559646], [-0.37269944, -0.15007514, 0.11866188, -0.0120635, -0.0109489, -0.60186726, -0.28244707, 0.32835752], [0.559184, 0.29157156, -0.35879636, 0.24650383, 0.5976046, -0.15556344, -0.11127496, -0.3011105], [0.5442193, -0.20431828, 0.36724424, -0.4528572, 0.10426587, 0.11822385, -0.05441982, 0.07673579], [-0.37118763, -0.24179482, -0.47427145, -0.17455658, 0.46202105, 0.24439615, -0.40861088, 0.2468313]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_558": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.527518, -0.12114212, -0.40808892, 0.56731755, 0.2572146, 0.31378293, 0.20443302, -0.5630253], [0.6023007, -0.08801287, -0.55323726, -0.49235207, 0.18328917, -0.30462766, 0.4235236, -0.14947698], [0.05836785, -0.32457548, -0.5583779, 0.17587304, 0.13842088, -0.06220692, 0.05683714, -0.08522952], [0.11454928, 0.57845205, 0.40677744, -0.32356766, -0.10824966, 0.5729895, 0.09953862, -0.49825168], [-0.1325807, -0.5300193, -0.09281999, 0.23173773, -0.6103119, -0.17548105, -0.40918946, -0.6055349], [-0.26868924, -0.3843334, -0.14497796, 0.27963597, 0.38890153, -0.36425418, 0.13343394, -0.17070243], [-0.333827, 0.16035432, 0.17401373, -0.27310547, -0.23915032, -0.3207253, -0.00749028, 0.4876346], [0.3249125, -0.29519892, 0.49359602, -0.601942, -0.2753108, -0.39890692, 0.04002428, 0.41897768]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_577": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[-0.00709212, -0.4091934, 0.26065922, 0.40150464, 0.26608098, -0.3953911, -0.34422696, -0.06396389, -0.42655826, 0.35439622, -0.20109999, -0.18769062, 0.0049336, -0.06693316, -0.4382484, 0.00183201], [-0.02701962, 0.41023743, 0.02444375, 0.25569785, 0.04378641, -0.37053585, 0.06267512, -0.06767642, -0.44424844, 0.2922008, -0.44157362, -0.17749298, 0.17760682, -0.23238945, 0.3380952, 0.3164295], [0.20117998, -0.13788939, 0.14445269, -0.31664026, 0.49193084, 0.08778274, -0.17864335, 0.16035259, -0.17492938, -0.04081237, -0.4904747, -0.44932437, -0.19341111, -0.24871266, 0.38286912, -0.06130087], [0.2936057, -0.40730655, 0.18446267, 0.4097544, -0.0082581, 0.4734217, -0.46421993, -0.12871945, 0.22802174, 0.11106157, 0.26079726, -0.15126705, 0.40684378, -0.10213089, -0.24696314, -0.02051508], [-0.39994586, 0.16061008, 0.39812696, -0.3340621, -0.2076987, 0.20246327, -0.35409093, -0.4005847, -0.14170253, -0.21880937, 0.4408716, 0.22332358, -0.05699933, 0.17266095, 0.12294924, 0.38497412], [-0.09543967, -0.34888685, -0.42740452, 0.1517607, -0.00862324, -0.14572752, 0.47876465, -0.20919883, 0.32560217, 0.4249189, -0.3933282, -0.22128391, -0.34623587, 0.14449048, -0.3857503, -0.27833867], [0.11869216, 0.05883706, -0.21212506, 0.49957561, 0.15783632, -0.13721228, -0.21416295, -0.24007809, -0.294443, -0.16767824, 0.32042253, -0.31908023, 0.19871199, -0.43558514, -0.15620553, 0.11092794], [-0.04378927, 0.35632384, 0.20292461, -0.27540374, 0.22871876, -0.3632071, -0.40689313, 0.23316133, 0.37361324, -0.01663148, -0.12638855, -0.32248807, -0.20867753, 0.2503358, -0.39324427, -0.42774928]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_611": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.24261475, -0.18643704, -0.01811624, 0.50356495, 0.01885831, -0.2399435, 0.23692662, -0.10759905, -0.38264602, 0.1351049], [0.21200335, -0.38962328, 0.29363745, 0.33583325, -0.24011764, 0.3635068, 0.4376179, 0.22551686, 0.5667083, -0.32501143], [-0.49261767, 0.1927172, -0.0046156, -0.56056315, 0.47630668, -0.31453356, 0.42453694, -0.32902807, 0.14415932, -0.5471806], [-0.3316853, 0.13726503, -0.40464914, 0.28158778, 0.47430885, -0.2569832, -0.5204258, -0.06528652, -0.5178821, 0.14735901], [0.5328666, -0.12720194, 0.5184237, 0.411116, -0.3576244, 0.34368336, 0.16382056, -0.33515644, 0.17608005, 0.26269817], [0.15965605, -0.25152162, -0.14534956, -0.2822171, 0.21284288, 0.05559379, 0.00327557, -0.4569926, -0.41969606, -0.56579554], [-0.43731868, 0.32843924, 0.29003292, 0.1792146, -0.33100158, -0.14961275, 0.12364352, -0.24879637, -0.39719564, 0.18711275], [0.05891687, 0.47468245, -0.20260152, -0.3408, 0.5017748, 0.1640119, 0.22170597, -0.34292257, -0.31018573, -0.07051545]])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "assign_629": {
                "ref": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._src_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ],
                        [
                            "model._trg_modality.trainable_weights",
                            "Attribute"
                        ]
                    ]
                },
                "value": {
                    "value": "numpy.array([[0.01111823, -0.50019276, -0.33186796, 0.52229214, -0.4700832, 0.5457233, -0.21241191, 0.37699038], [-0.28677762, -0.51243806, 0.52265644, -0.29745945, -0.35470137, -0.5047183, 0.18846446, -0.17220777], [-0.46509957, -0.00087285, -0.22127637, 0.4205513, -0.46209753, -0.11040562, -0.0872128, 0.34856063], [0.33827233, -0.31306413, -0.49311733, -0.49154714, -0.43418467, 0.11416692, 0.46271265, -0.1998105], [0.05865157, -0.19406608, 0.2172538, -0.2894684, 0.2942767, 0.19267291, -0.31736228, -0.04036039], [-0.49561584, -0.22174796, 0.15456653, -0.3632484, -0.4434304, -0.30227244, -0.4071117, 0.4257239], [0.2923094, 0.52523994, 0.22059155, 0.22125322, -0.30496007, -0.20421728, -0.5533153, 0.28908247], [-0.01375407, -0.42056724, -0.42731434, 0.14045459, -0.10852379, -0.14693105, 0.3797375, 0.5360898], [0.01416886, 0.2641362, -0.55372095, -0.17806509, -0.43746334, -0.39878494, -0.5338729, -0.50196886], [0.5125271, -0.31531927, -0.4611238, 0.38278532, -0.05637842, 0.23722917, -0.11141762, 0.44730043]])",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst_pt/decoders/transformer_decoder_test.py": {
        "tensorflow": {
            "convert_to_tensor_66": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_68": {
                "variable": {
                    "value": "tf_inppad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_70": {
                "variable": {
                    "value": "tf_decinp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "decoder_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[[0.86675537, 0.22135425, 1.4054185, -0.42268831], [1.9606155, -1.831841, -1.8158482, -0.37030798], [-0.0011357157, 0.55629879, 0.066107117, -1.7330967]], [[-1.1870812, -0.54499257, -0.86622888, -0.74098641], [0.22233427, 0.53582352, 0.30567116, 0.10201423], [-1.8053315, 0.72125041, 1.0072237, -2.0333264]]]",
                            "List"
                        ],
                        [
                            "[[1.9606155, -1.831841, -1.8158482, -0.37030798], [-0.0011357157, 0.55629879, 0.066107117, -1.7330967]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_131": {
                "variable": {
                    "value": "tf_decinp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "decoder_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[[0.86675537, 0.22135425, 1.4054185, -0.42268831], [1.9606155, -1.831841, -1.8158482, -0.37030798], [-0.0011357157, 0.55629879, 0.066107117, -1.7330967]], [[-1.1870812, -0.54499257, -0.86622888, -0.74098641], [0.22233427, 0.53582352, 0.30567116, 0.10201423], [-1.8053315, 0.72125041, 1.0072237, -2.0333264]]]",
                            "List"
                        ],
                        [
                            "[[1.9606155, -1.831841, -1.8158482, -0.37030798], [-0.0011357157, 0.55629879, 0.066107117, -1.7330967]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {}
    },
    "tests/neurst_pt/encoders/transformer_encoder_test.py": {
        "tensorflow": {
            "convert_to_tensor_61": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                            "List"
                        ],
                        [
                            "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_63": {
                "variable": {
                    "value": "tf_inppad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                            "List"
                        ],
                        [
                            "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_138": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                            "List"
                        ],
                        [
                            "[[[-0.37282175, 0.62301564, -2.0221813, -0.00875833], [0.31516594, -1.117763, -1.0697726, 0.80373234], [-0.717022, 0.3300997, -0.44306225, 1.550383], [-1.5516962, 0.6025011, 1.8262954, 0.42469704]], [[-0.98617625, 2.2856202, -1.3063533, 0.4174998], [1.5724765, 1.2201295, 1.1479746, 0.7810888], [0.8343642, -1.073388, 1.2718492, -0.7290778], [-1.4126722, 1.8000795, -2.118672, -0.1366007]]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_140": {
                "variable": {
                    "value": "tf_inppad",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "input_padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                            "List"
                        ],
                        [
                            "[[0, 0, 0, 0], [0, 0, 1.0, 1.0]]",
                            "List"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {}
    },
    "tests/neurst_pt/layers/common_layers_test.py": {
        "tensorflow": {
            "convert_to_tensor_31": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy_inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(3, 5)",
                            "Call"
                        ],
                        [
                            "numpy.array([[1, 2, 3.0]])",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(2, 3, input_size)",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(1, 2, num_heads, num_inputs_per_head)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_56": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy_inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(3, 5)",
                            "Call"
                        ],
                        [
                            "numpy.array([[1, 2, 3.0]])",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(2, 3, input_size)",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(1, 2, num_heads, num_inputs_per_head)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_71": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy_inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(3, 5)",
                            "Call"
                        ],
                        [
                            "numpy.array([[1, 2, 3.0]])",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(2, 3, input_size)",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(1, 2, num_heads, num_inputs_per_head)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_88": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "numpy_inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(3, 5)",
                            "Call"
                        ],
                        [
                            "numpy.array([[1, 2, 3.0]])",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(2, 3, input_size)",
                            "Call"
                        ],
                        [
                            "numpy.random.randn(1, 2, num_heads, num_inputs_per_head)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_115": {
                "variable": {
                    "value": "tf_inp_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inp_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.randint(0, 9, [2, 5])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_116": {
                "variable": {
                    "value": "tf_inp_1d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inp_1d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.randint(0, 9, [3])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_117": {
                "variable": {
                    "value": "tf_logits_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "logits_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(2, 5)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_118": {
                "variable": {
                    "value": "tf_logits_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "logits_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(2, 4, 5)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_104": {
                "shape": {
                    "value": "[1, 10, 10]",
                    "type": "List",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "Tensor_125": {
                "variable": {
                    "value": "pt_emb._shared_weights.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_105": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst_pt/modalities/audio_modalities_test.py": {
        "tensorflow": {
            "convert_to_tensor_26": {
                "variable": {
                    "value": "tf_inp",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, 19, 80, 1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {}
    },
    "tests/neurst_pt/modalities/text_modalities_test.py": {
        "tensorflow": {
            "convert_to_tensor_32": {
                "variable": {
                    "value": "tf_inp_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inp_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.randint(0, 9, [2, 5])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_33": {
                "variable": {
                    "value": "tf_inp_1d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inp_1d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.randint(0, 9, [3])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_34": {
                "variable": {
                    "value": "tf_logits_2d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "logits_2d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(2, 5)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_35": {
                "variable": {
                    "value": "tf_logits_3d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "logits_3d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(2, 4, 5)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "Tensor_42": {
                "variable": {
                    "value": "pt_emb._shared_weights.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Tensor_43": {
                "variable": {
                    "value": "pt_emb._bias.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "tests/neurst_pt/models/speech_transformer_test.py": {
        "tensorflow": {
            "convert_to_tensor_47": {
                "value": {
                    "value": "fake_audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numpy.random.rand(1, 11, 80, 1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_48": {
                "value": {
                    "value": "[11]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_49": {
                "value": {
                    "value": "[[3, 0, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {}
    },
    "tests/neurst_pt/models/transformer_test.py": {
        "tensorflow": {
            "convert_to_tensor_47": {
                "value": {
                    "value": "[[0, 1, 1, 7], [1, 7, 7, 7]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_49": {
                "value": {
                    "value": "[[0, 0, 0, 0.0], [0, 0, 1, 1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_50": {
                "value": {
                    "value": "[[3, 0, 1], [3, 2, 4]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_51": {
                "value": {
                    "value": "[[0, 1, 4], [2, 4, 4]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_52": {
                "value": {
                    "value": "[[0, 0, 0.0], [0, 0, 1.0]]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "torch": {}
    },
    "neurst_pt/layers/__init__.py": {
        "torch": {}
    },
    "neurst_pt/layers/attentions/multi_head_attention.py": {
        "torch": {
            "dropout_184": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(logits, -1)",
                            "Call"
                        ],
                        [
                            "self.att_fn(q, k, memory_bias)",
                            "Call"
                        ],
                        [
                            "F.dropout(weights, p=self._attention_dropout_rate, training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self._attention_dropout_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "einsum_191": {
                "variable": {
                    "value": "attention_output",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bnft,btnh->bfnh",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(logits, -1)",
                            "Call"
                        ],
                        [
                            "self.att_fn(q, k, memory_bias)",
                            "Call"
                        ],
                        [
                            "F.dropout(weights, p=self._attention_dropout_rate, training=is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_126": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "btnh,bfnh->bnft",
                    "type": "str",
                    "possible_values": []
                },
                "*operands": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.cat([cache['keys'], k], dim=1)",
                            "Call"
                        ],
                        [
                            "cache['keys'][:, :decode_loop_step + 1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "softmax_137": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.einsum('btnh,bfnh->bnft', k, q)",
                            "Call"
                        ],
                        [
                            "logits + bias",
                            "BinOp"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_246": {
                "variable": {
                    "value": "k",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[cache['keys'], k]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_247": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[cache['values'], v]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_254": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.one_hot(decode_loop_step, size).to(_new_val.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_254": {
                "tensor": {
                    "value": "decode_loop_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "num_classes": {
                    "value": "size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_cache.size()[1]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "neurst_pt/layers/decoders/decoder.py": {
        "torch": {}
    },
    "neurst_pt/layers/decoders/transformer_decoder.py": {
        "torch": {
            "dropout_191": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "decoder_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder_inputs.unsqueeze(1)",
                            "Call"
                        ]
                    ]
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "p": {
                    "value": "self._params['layer_postprocess_dropout_rate']",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_153": {
                "*size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_outputs.size()[0]",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "decode_padded_length or 0",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layout": {
                    "value": "num_units_per_head",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._params['hidden_size'] // num_heads",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_155": {
                "*size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "encoder_outputs.size()[0]",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "decode_padded_length or 0",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layout": {
                    "value": "num_units_per_head",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._params['hidden_size'] // num_heads",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "neurst_pt/layers/encoders/encoder.py": {
        "torch": {}
    },
    "neurst_pt/layers/encoders/transformer_encoder.py": {
        "torch": {
            "dropout_121": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "p": {
                    "value": "self._params['layer_postprocess_dropout_rate']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "neurst_pt/layers/layer_utils.py": {
        "torch": {
            "reshape_45": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "compat.FLOAT_MIN * torch.ones(length, length).triu(1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, length, length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_45": {
                "*size": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                },
                "out": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "triu_45": {
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "neurst_pt/layers/modalities/audio_modalities.py": {
        "torch": {
            "Conv2d_56": {
                "variable": {
                    "value": "self._conv_layer1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "self._input_channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "self._channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(self._kernel_size, self._kernel_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "stride": {
                    "value": "(self._strides, self._strides)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "(num_pad, num_pad)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Conv2d_61": {
                "variable": {
                    "value": "self._conv_layer2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_channels": {
                    "value": "self._channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "self._channels",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(self._kernel_size, self._kernel_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "stride": {
                    "value": "(self._strides, self._strides)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "(num_pad, num_pad)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Linear_69": {
                "variable": {
                    "value": "self._dense_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "((input_dimension + self._strides - 1) // self._strides + self._strides - 1) // self._strides * self._channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self._embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_93": {
                "variable": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer1(inputs)",
                            "Call"
                        ],
                        [
                            "self._norm_layer1(conv1.transpose(1, 3)).transpose(1, 3)",
                            "Call"
                        ],
                        [
                            "F.relu(conv1)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_97": {
                "variable": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer2(conv1).permute(0, 2, 3, 1)",
                            "Call"
                        ],
                        [
                            "self._norm_layer2(conv2)",
                            "Call"
                        ],
                        [
                            "F.relu(conv2)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_98": {
                "variable": {
                    "value": "conv2_reshape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._conv_layer2(conv1).permute(0, 2, 3, 1)",
                            "Call"
                        ],
                        [
                            "self._norm_layer2(conv2)",
                            "Call"
                        ],
                        [
                            "F.relu(conv2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "conv2.size()[:2] + (-1,)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "neurst_pt/layers/modalities/text_modalities.py": {
        "torch": {
            "Parameter_46": {
                "variable": {
                    "value": "self._shared_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "nn.init.normal_(torch.empty(vocab_size, embedding_dim), mean=0.0, std=embedding_dim ** (-0.5))",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_83": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.reshape(x, [-1, self._embedding_dim])",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "self._shared_weights.transpose(1, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_51": {
                "variable": {
                    "value": "self._bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(vocab_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "requires_grad": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_88": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.matmul(torch.reshape(x, [-1, self._embedding_dim]), self._shared_weights.transpose(1, 0))",
                            "Call"
                        ],
                        [
                            "logits + self._bias",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "original_shape[:-1] + [self._vocab_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_83": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self._embedding_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "empty_47": {
                "*size": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": []
                },
                "out": {
                    "value": "embedding_dim",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_51": {
                "*size": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "neurst_pt/models/encoder_decoder_model.py": {
        "torch": {
            "Linear_63": {
                "variable": {
                    "value": "self._output_linear_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self._trg_modality.embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "trg_meta['vocab_size']",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "neurst_pt/models/model.py": {
        "torch": {}
    },
    "neurst_pt/models/model_utils.py": {
        "torch": {
            "arange_29": {
                "variable": {
                    "value": "row_vector",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "end": {
                    "value": "max_len",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unsqueeze_30": {
                "variable": {
                    "value": "matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "neurst_pt/models/speech_transformer.py": {
        "torch": {}
    },
    "neurst_pt/models/transformer.py": {
        "torch": {}
    },
    "neurst_pt/utils/activations.py": {
        "torch": {
            "glu_29": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    }
}