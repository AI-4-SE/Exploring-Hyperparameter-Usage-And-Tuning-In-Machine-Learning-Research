{
    "dann_model.py": {
        "tensorflow": {
            "placeholder_40": {
                "variable": {
                    "value": "self.x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 28, 28, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_42": {
                "variable": {
                    "value": "self.label",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, self.args.num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_43": {
                "variable": {
                    "value": "self.mag",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_45": {
                "variable": {
                    "value": "self.domain",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_46": {
                "variable": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_47": {
                "variable": {
                    "value": "self.lr",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_90": {
                "variable": {
                    "value": "self.classify_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cross_ent_loss",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=self.classify_label)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_92": {
                "variable": {
                    "value": "self.domain_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "cross_ent_loss_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits(logits=logits_d, labels=self.domain)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_95": {
                "variable": {
                    "value": "self.regular_train_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.args.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_96": {
                "variable": {
                    "value": "self.dann_train_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_100": {
                "variable": {
                    "value": "self.label_accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(self.classify_label, axis=1), tf.argmax(prob, axis=1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_101": {
                "variable": {
                    "value": "self.domain_accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(self.domain, axis=1), tf.argmax(prob_d, axis=1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_103": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_156": {
                "variable": {
                    "value": "ckpt",
                    "type": "Variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_path",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "os.path.join(self.args.checkpoint_dir, self.model_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_57": {
                "variable": {
                    "value": "flatten",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv3",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.conv2d(conv2, output_dim=48, filter_len=3, stride=1, name='conv3', activation=tf.nn.relu)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, np.prod(conv2.get_shape().as_list()[1:])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_66": {
                "variable": {
                    "value": "classify_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "source_features",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "lambda : tf.slice(self.feature, [0, 0], [self.args.batch_size / 2, -1])",
                            "Lambda"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : self.feature",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_68": {
                "variable": {
                    "value": "self.classify_label",
                    "type": "Attribute",
                    "possible_values": []
                },
                "pred": {
                    "value": "self.is_training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "source_label",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "lambda : tf.slice(self.label, [0, 0], [self.args.batch_size / 2, -1])",
                            "Lambda"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : self.label",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "softmax_74": {
                "variable": {
                    "value": "prob",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.fc(fc2, output_dim=self.args.num_classes, name='fc3', activation=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_76": {
                "variable": {
                    "value": "cross_ent_loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.fc(fc2, output_dim=self.args.num_classes, name='fc3', activation=None)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.classify_label",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_86": {
                "variable": {
                    "value": "prob_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.fc(fc2_d, output_dim=2, name='fc3', activation=None)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_87": {
                "variable": {
                    "value": "cross_ent_loss_d",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.fc(fc2_d, output_dim=2, name='fc3', activation=None)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.domain",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_53": {
                "name_or_scope": {
                    "value": "Feature_Extractor",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_60": {
                "name_or_scope": {
                    "value": "Label_Classify",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_78": {
                "name_or_scope": {
                    "value": "Domain_Discriminator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_100": {
                "x": {
                    "value": "tf.equal(tf.argmax(self.classify_label, axis=1), tf.argmax(prob, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_101": {
                "x": {
                    "value": "tf.equal(tf.argmax(self.domain, axis=1), tf.argmax(prob_d, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_106": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "slice_65": {
                "input_": {
                    "value": "self.feature",
                    "type": "Attribute",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[self.args.batch_size / 2, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "slice_67": {
                "input_": {
                    "value": "self.label",
                    "type": "Attribute",
                    "possible_values": []
                },
                "begin": {
                    "value": "[0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[self.args.batch_size / 2, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_100": {
                "x": {
                    "value": "tf.argmax(self.classify_label, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(prob, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_101": {
                "x": {
                    "value": "tf.argmax(self.domain, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(prob_d, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_100": {
                "input": {
                    "value": "prob",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_101": {
                "input": {
                    "value": "prob_d",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits_d)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "main.py": {
        "tensorflow": {
            "ConfigProto_35": {
                "variable": {
                    "value": "run_config",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_43": {
                "config": {
                    "value": "run_config",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "utils.py": {
        "tensorflow": {}
    },
    "wgan_model.py": {
        "tensorflow": {
            "placeholder_35": {
                "variable": {
                    "value": "self.source_x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 28, 28, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "source_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_36": {
                "variable": {
                    "value": "self.target_x",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 28, 28, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "target_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_37": {
                "variable": {
                    "value": "self.label",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, self.args.num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_38": {
                "variable": {
                    "value": "self.is_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_46": {
                "variable": {
                    "value": "self.classifier_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "pred": {
                    "value": "self.is_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : self.classifier(self.source_features, reuse=False)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : self.classifier(self.target_features, reuse=True)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "softmax_47": {
                "variable": {
                    "value": "self.classify_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.classifier_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_49": {
                "variable": {
                    "value": "self.d_param",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "discriminator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_50": {
                "variable": {
                    "value": "self.g_param",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "generator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_51": {
                "variable": {
                    "value": "self.c_param",
                    "type": "Attribute",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "classifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_63": {
                "variable": {
                    "value": "self.classify_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits(logits=self.classifier_logits, labels=self.label)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "AdamOptimizer_66": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.args.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_74": {
                "variable": {
                    "value": "self.label_accuracy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(tf.equal(tf.argmax(self.label, axis=1), tf.argmax(self.classify_prob, axis=1)), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_79": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_198": {
                "variable": {
                    "value": "ckpt",
                    "type": "Variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "os.path.join(self.args.checkpoint_dir, self.model_dir)",
                            "Call"
                        ],
                        [
                            "os.path.join(self.args.checkpoint_dir, self.model_dir)",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_56": {
                "variable": {
                    "value": "self.gradient",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ys": {
                    "value": "tf.reduce_mean(self.discriminator(self.penalty_point, reuse=True))",
                    "type": "Call",
                    "possible_values": []
                },
                "xs": {
                    "value": "self.d_param",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_57": {
                "variable": {
                    "value": "self.gradient_norm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(self.gradient))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_61": {
                "variable": {
                    "value": "self.discriminator_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.discriminator_fake - self.discriminator_real",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_63": {
                "logits": {
                    "value": "self.classifier_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "labels": {
                    "value": "self.label",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_74": {
                "x": {
                    "value": "tf.equal(tf.argmax(self.label, axis=1), tf.argmax(self.classify_prob, axis=1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_82": {
                "name_or_scope": {
                    "value": "generator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_100": {
                "variable": {
                    "value": "flatten",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "conv3",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "utils.conv2d(conv2, output_dim=64, filter_len=3, stride=1, name='gen_wo_batch3', activation=tf.nn.relu)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, np.prod(conv3.get_shape().as_list()[1:])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_107": {
                "name_or_scope": {
                    "value": "discriminator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_118": {
                "name_or_scope": {
                    "value": "classifier",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_initializer_129": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_56": {
                "input_tensor": {
                    "value": "self.discriminator(self.penalty_point, reuse=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_57": {
                "input_tensor": {
                    "value": "tf.square(self.gradient)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_58": {
                "input_tensor": {
                    "value": "self.discriminator_fake - self.discriminator_real",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_74": {
                "x": {
                    "value": "tf.argmax(self.label, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(self.classify_prob, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_75": {
                "t": {
                    "value": "disc_param",
                    "type": "Variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "-self.args.clip",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "self.args.clip",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_95": {
                "x": {
                    "value": "de4",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "deconv2d(de3_result, output_shape=[self.args.batch_size, self.args.target_size, self.args.target_size, self.args.num_channels], name='gen_batch4')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "generator_result",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_57": {
                "x": {
                    "value": "self.gradient",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_74": {
                "input": {
                    "value": "self.classify_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    }
}