{
    "Estimate_Sources.py": {
        "tensorflow": {
            "Session_51": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_56": {
                "variable": {
                    "value": "restorer",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "write_version": {
                    "value": "tf.train.SaverDef.V2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reset_default_graph_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_52": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_57": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Input/Input.py": {
        "tensorflow": {
            "placeholder_20": {
                "variable": {
                    "value": "mix",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape",
                            "variable"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'mix_input' + name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "placeholder_24": {
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "'source_' + str(i) + '_input' + name",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "Models/OutputLayer.py": {
        "tensorflow": {
            "conv1d_13": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "featuremap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "featuremap",
                            "Method Argument"
                        ],
                        [
                            "featuremap",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_channels",
                            "Method Argument"
                        ],
                        [
                            "num_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv1d_6": {
                "input": {
                    "value": "featuremap",
                    "type": "variable",
                    "possible_values": [
                        [
                            "featuremap",
                            "Method Argument"
                        ],
                        [
                            "featuremap",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "num_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "num_channels",
                            "Method Argument"
                        ],
                        [
                            "num_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "tf.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "Models/UnetAudioSeparator.py": {
        "tensorflow": {
            "conv1d_89": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "self.num_initial_filters + self.num_initial_filters * self.num_layers",
                    "type": "BinOp",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.filter_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_79": {
                "name_or_scope": {
                    "value": "separator",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv1d_85": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "self.num_initial_filters + self.num_initial_filters * i",
                    "type": "BinOp",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.filter_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_96": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_107": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv1d_111": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "stride": {
                    "value": "self.merge_filter_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "resize_bilinear_103": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[1, current_layer.get_shape().as_list()[2] * 2 - 1]",
                    "type": "List",
                    "possible_values": []
                },
                "align_corners": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "resize_bilinear_105": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * i, self.filter_size, strides=1, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "current_layer[:, ::2, :]",
                            "Subscript"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * self.num_layers, self.filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(input, current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "Utils.learned_interpolation_layer(current_layer, self.padding, i)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(current_layer, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2 - 1], align_corners=True)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bilinear(current_layer, [1, current_layer.get_shape().as_list()[2] * 2])",
                            "Call"
                        ],
                        [
                            "Utils.crop_and_concat(enc_outputs[-i - 1], current_layer, match_feature_dim=False)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv1d(current_layer, self.num_initial_filters + self.num_initial_filters * (self.num_layers - i - 1), self.merge_filter_size, activation=LeakyReLU, padding=self.padding)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[1, current_layer.get_shape().as_list()[2] * 2]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "Training.py": {
        "tensorflow": {
            "get_variable_73": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_74": {
                "variable": {
                    "value": "increment_global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('global_step', [], initializer=tf.constant_initializer(0), trainable=False, dtype=tf.int64)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "global_step + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_collection_81": {
                "variable": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "merge_all_88": {
                "variable": {
                    "value": "sup_summaries",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "sup",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ConfigProto_91": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_93": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            },
            "FileWriter_95": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "model_config['log_dir'] + os.path.sep + str(experiment_id)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_105": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                },
                "write_version": {
                    "value": "tf.train.SaverDef.V2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_87": {
                "name": {
                    "value": "sep_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "separator_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "separator_loss + tf.reduce_mean(tf.square(real_source - sep_source))",
                            "BinOp"
                        ],
                        [
                            "separator_loss / float(len(sources))",
                            "BinOp"
                        ]
                    ]
                },
                "collections": {
                    "value": "['sup']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Saver_100": {
                "variable": {
                    "value": "restorer",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                },
                "write_version": {
                    "value": "tf.train.SaverDef.V2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reset_default_graph_136": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_69": {
                "input_tensor": {
                    "value": "tf.square(real_source - sep_source)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_82": {
                "control_inputs": {
                    "value": "update_ops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "AdamOptimizer_84": {
                "variable": {
                    "value": "separator_solver",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "model_config['init_sup_sep_lr']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "cfg['model_config']",
                            "Subscript"
                        ],
                        [
                            "model_config",
                            "Method Argument"
                        ],
                        [
                            "model_config",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "global_variables_initializer_94": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "square_69": {
                "x": {
                    "value": "real_source - sep_source",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_73": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_83": {
                "name_or_scope": {
                    "value": "separator_solver",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_100": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_101": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "Utils.py": {
        "tensorflow": {
            "get_variable_83": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'interp_' + str(level)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[features]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_84": {
                "variable": {
                    "value": "weights_scaled",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('interp_' + str(level), shape=[features], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_86": {
                "input": {
                    "value": "tf.diag(counter_weights)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "conv2d_87": {
                "variable": {
                    "value": "intermediate_vals",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                },
                "filters": {
                    "value": "conv_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.concat([tf.expand_dims(tf.diag(weights_scaled), axis=0), tf.expand_dims(tf.diag(counter_weights), axis=0)], axis=0), axis=0)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding.upper()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_90": {
                "variable": {
                    "value": "intermediate_vals",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "intermediate_vals",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(input, conv_weights, strides=[1, 1, 1, 1], padding=padding.upper())",
                            "Call"
                        ],
                        [
                            "tf.transpose(intermediate_vals, [2, 0, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_91": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_93": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[out, intermediate_vals]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_103": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(input, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.concat([out, intermediate_vals], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list()",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_104": {
                "variable": {
                    "value": "current_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(input, [2, 0, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.concat([out, intermediate_vals], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 0, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_31": {
                "values": {
                    "value": "[x1, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_108": {
                "x": {
                    "value": "alpha * x",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pad_64": {
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tensor",
                            "Method Argument"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[(diff / 2, diff / 2)]",
                            "List"
                        ],
                        [
                            "[(diff // 2, diff // 2 + 1)]",
                            "List"
                        ],
                        [
                            "pad + [(0, 0)]",
                            "BinOp"
                        ],
                        [
                            "[(0, 0)] + pad + [(0, 0), (0, 0)]",
                            "BinOp"
                        ]
                    ]
                },
                "mode": {
                    "value": "constant",
                    "type": "str",
                    "possible_values": []
                },
                "constant_values": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_86": {
                "values": {
                    "value": "[tf.expand_dims(tf.diag(weights_scaled), axis=0), tf.expand_dims(tf.diag(counter_weights), axis=0)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "trainable_variables_16": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "diag_86": {
                "diagonal": {
                    "value": "counter_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - weights_scaled",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "Validation.py": {
        "tensorflow": {
            "get_variable_46": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Session_49": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "FileWriter_51": {
                "variable": {
                    "value": "writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "model_config['log_dir'] + os.path.sep + model_folder",
                    "type": "BinOp",
                    "possible_values": []
                },
                "graph": {
                    "value": "sess.graph",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Saver_55": {
                "variable": {
                    "value": "restorer",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.global_variables()",
                    "type": "Call",
                    "possible_values": []
                },
                "write_version": {
                    "value": "tf.train.SaverDef.V2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_60": {
                "variable": {
                    "value": "input_audio",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stft_62": {
                "variable": {
                    "value": "stft",
                    "type": "variable",
                    "possible_values": []
                },
                "signals": {
                    "value": "tf.squeeze(input_audio, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "frame_length": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "frame_step": {
                    "value": "768",
                    "type": "int",
                    "possible_values": []
                },
                "fft_length": {
                    "value": "1024",
                    "type": "int",
                    "possible_values": []
                },
                "window_fn": {
                    "value": "window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "functools.partial(window_ops.hann_window, periodic=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_64": {
                "variable": {
                    "value": "mag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "stft",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.signal.stft(tf.squeeze(input_audio, 1), frame_length=1024, frame_step=768, fft_length=1024, window_fn=window)",
                            "Call"
                        ]
                    ]
                }
            },
            "Summary_97": {
                "variable": {
                    "value": "summary",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[tf.Summary.Value(tag='test_loss', simple_value=mean_mse_loss)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reset_default_graph_107": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_50": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_55": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "squeeze_62": {
                "input": {
                    "value": "input_audio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.float32, shape=[None, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_46": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_56": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}