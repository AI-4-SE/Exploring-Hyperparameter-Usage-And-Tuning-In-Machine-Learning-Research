{
    "tflib/figures.py": {
        "sklearn": {
            "roc_curve_903": {
                "variable": {
                    "value": "(fpr, tpr, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "y_true": {
                    "value": "y_true",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.round(np.concatenate((packet1_or.flatten(), packet2_or.flatten())))",
                            "Call"
                        ]
                    ]
                },
                "y_score": {
                    "value": "all_stim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.concatenate((packet1.flatten(), packet2.flatten()))",
                            "Call"
                        ]
                    ]
                }
            },
            "auc_904": {
                "variable": {
                    "value": "roc_auc",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "fpr",
                    "type": "Name",
                    "possible_values": []
                },
                "y": {
                    "value": "tpr",
                    "type": "Name",
                    "possible_values": []
                }
            }
        }
    },
    "main_conv.py": {
        "tensorflow": {
            "ConfigProto_143": {
                "variable": {
                    "value": "run_config",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_236": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_146": {
                "config": {
                    "value": "run_config",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.ConfigProto()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "model_conv.py": {
        "tensorflow": {
            "reset_default_graph_33": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_75": {
                "variable": {
                    "value": "self.inputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "real_data",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.batch_size, self.num_neurons * self.num_bins]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_94": {
                "variable": {
                    "value": "slopes",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(gradients), axis=[1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_95": {
                "variable": {
                    "value": "gradient_penalty",
                    "type": "Name",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "(slopes - 1.0) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Saver_99": {
                "variable": {
                    "value": "self.saver",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "1000",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "AdamOptimizer_104": {
                "variable": {
                    "value": "self.g_optim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "config.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta1": {
                    "value": "config.beta1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta2": {
                    "value": "config.beta2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AdamOptimizer_106": {
                "variable": {
                    "value": "self.d_optim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "config.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta1": {
                    "value": "config.beta1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "beta2": {
                    "value": "config.beta2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_222": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self.num_neurons, self.num_bins]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_239": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, int(num_features * self.num_bins)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_257": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self.num_neurons, self.num_bins]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_274": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, int(num_features * self.num_bins)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_300": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_316": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_321": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.output_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_357": {
                "variable": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_370": {
                "variable": {
                    "value": "noise",
                    "type": "Name",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.normal(size=(num_samples, self.output_dim)).astype('float32')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_checkpoint_state_389": {
                "variable": {
                    "value": "ckpt",
                    "type": "Name",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "self.checkpoint_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_initializer_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_109": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_117": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reshape_249": {
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_334": {
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_43": {
                "value": {
                    "value": ".",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_mean_85": {
                "input_tensor": {
                    "value": "self.disc_fake",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_86": {
                "input_tensor": {
                    "value": "self.disc_real",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gradients_93": {
                "ys": {
                    "value": "aux",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.Discriminator(interpolates)",
                            "Call"
                        ],
                        [
                            "time.time() - start_time",
                            "BinOp"
                        ]
                    ]
                },
                "xs": {
                    "value": "[interpolates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_94": {
                "input_tensor": {
                    "value": "tf.square(gradients)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_282": {
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_345": {
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), self.num_neurons, int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "conv1d_II.Conv1D('Discriminator.' + str(ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l + 1)), int(kernel_width), output, stride=self.stride)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, self.num_neurons, self.num_bins])",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * self.num_bins)])",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Output', int(num_features * self.num_bins), 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Input', 128, int(num_features * self.num_bins), noise)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, int(num_features * 2 ** self.num_layers), int(self.num_bins / 2 ** self.num_layers)])",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [-1, self.output_dim])",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(self.num_neurons), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "deconv1d_II.Deconv1D('Generator.' + str(self.num_layers - ind_l + 1), int(num_features * 2 ** ind_l), int(num_features * 2 ** (ind_l - 1)), int(kernel_width), output, num_bins=int(2 ** (self.num_layers - ind_l + 1) * self.num_bins / 2 ** self.num_layers))",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLU(output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.Input', self.output_dim, self.num_units, inputs)",
                            "Call"
                        ],
                        [
                            "act_funct.LeakyReLULayer('Discriminator.{}'.format(i), self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Discriminator.Out', self.num_units, 1, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.1', 128, self.num_units, noise)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.2', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.3', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "act_funct.ReLULayer('Generator.4', self.num_units, self.num_units, output)",
                            "Call"
                        ],
                        [
                            "linear.Linear('Generator.Out', self.num_units, self.output_dim, output)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(output)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_94": {
                "x": {
                    "value": "gradients",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.gradients(aux, [interpolates])[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "tflib/__init__.py": {
        "tensorflow": {
            "Variable_24": {
                "variable": {
                    "value": "param",
                    "type": "Name",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "*args",
                    "type": "Starred",
                    "possible_values": []
                }
            }
        }
    },
    "tflib/ops/act_funct.py": {
        "tensorflow": {
            "transpose_37": {
                "variable": {
                    "value": "aux",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "aux",
                    "type": "Name",
                    "possible_values": [
                        [
                            "ReLULayer('test', 512, 512, inputs)",
                            "Call"
                        ],
                        [
                            "tf.transpose(aux, [0, 2, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Session_39": {
                "variable": {
                    "value": "sess",
                    "type": "Name",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "maximum_12": {
                "x": {
                    "value": "alpha * x",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "x",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "relu_15": {
                "features": {
                    "value": "x",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "relu_19": {
                "features": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "linear.Linear(name + '.Linear', n_in, n_out, inputs, initialization='he')",
                            "Call"
                        ],
                        [
                            "linear.Linear(name + '.Linear', n_in, n_out, inputs, initialization='he')",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_initializer_40": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "tflib/ops/conv1d_II.py": {
        "tensorflow": {
            "transpose_65": {
                "variable": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv1d_66": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "stride",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "Constant",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NWC",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bias_add_73": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=inputs, filters=filters, stride=stride, padding='SAME', data_format='NWC')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "_biases",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.Biases', np.zeros([output_dim], dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "NHWC",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_74": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=inputs, filters=filters, stride=stride, padding='SAME', data_format='NWC')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_75": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "input": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=inputs, filters=filters, stride=stride, padding='SAME', data_format='NWC')",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_37": {
                "name": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": []
                }
            }
        }
    },
    "tflib/ops/deconv1d_II.py": {
        "tensorflow": {
            "stack_72": {
                "variable": {
                    "value": "output_shape",
                    "type": "Name",
                    "possible_values": []
                },
                "values": {
                    "value": "[1, num_bins]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_76": {
                "variable": {
                    "value": "aux_input",
                    "type": "Name",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_79": {
                "variable": {
                    "value": "aux_input",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "aux_input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inputs, axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(aux_input, [0, 2, 3, 1], name='NCHW_to_NHWC')",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "NCHW_to_NHWC",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "conv1d_84": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "value": {
                    "value": "resized_image",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.image.resize_images(images=aux_input, size=output_shape, method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "resized_image[:, 0, :, :]",
                            "Subscript"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.Filters', filter_values)",
                            "Call"
                        ]
                    ]
                },
                "stride": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_90": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "input": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=resized_image, filters=filters, stride=1, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2], name='NHWC_to_NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bias_add_93": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=resized_image, filters=filters, stride=1, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2], name='NHWC_to_NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "_biases",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.Biases', np.zeros(output_dim, dtype='float32'))",
                            "Call"
                        ]
                    ]
                },
                "data_format": {
                    "value": "NHWC",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_96": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=resized_image, filters=filters, stride=1, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2], name='NHWC_to_NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "NHWC_to_NCHW",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_99": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "input": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.conv1d(value=resized_image, filters=filters, stride=1, padding='SAME')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(result, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, _biases, data_format='NHWC')",
                            "Call"
                        ],
                        [
                            "tf.transpose(result, [0, 3, 1, 2], name='NHWC_to_NCHW')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(result)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_41": {
                "name": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": []
                }
            }
        }
    },
    "tflib/ops/linear.py": {
        "tensorflow": {
            "name_scope_37": {
                "name": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": []
                }
            },
            "matmul_130": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "b": {
                    "value": "weight",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.W', weight_values)",
                            "Call"
                        ],
                        [
                            "weight * (target_norms / norms)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_132": {
                "variable": {
                    "value": "reshaped_inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, input_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_133": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "a": {
                    "value": "reshaped_inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, input_dim])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weight",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.W', weight_values)",
                            "Call"
                        ],
                        [
                            "weight * (target_norms / norms)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_134": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "tensor": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.matmul(reshaped_inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result, tf.stack(tf.unstack(tf.shape(inputs))[:-1] + [output_dim]))",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, lib.param(name + '.b', np.zeros((output_dim,), dtype='float32')))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack(tf.unstack(tf.shape(inputs))[:-1] + [output_dim])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bias_add_137": {
                "variable": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": []
                },
                "value": {
                    "value": "result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.matmul(inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.matmul(reshaped_inputs, weight)",
                            "Call"
                        ],
                        [
                            "tf.reshape(result, tf.stack(tf.unstack(tf.shape(inputs))[:-1] + [output_dim]))",
                            "Call"
                        ],
                        [
                            "tf.nn.bias_add(result, lib.param(name + '.b', np.zeros((output_dim,), dtype='float32')))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "lib.param(name + '.b', np.zeros((output_dim,), dtype='float32'))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_125": {
                "variable": {
                    "value": "norms",
                    "type": "Name",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(tf.square(weight), axis=[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_124": {
                "name": {
                    "value": "weightnorm",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_134": {
                "values": {
                    "value": "tf.unstack(tf.shape(inputs))[:-1] + [output_dim]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_125": {
                "input_tensor": {
                    "value": "tf.square(weight)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_125": {
                "x": {
                    "value": "weight",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lib.param(name + '.W', weight_values)",
                            "Call"
                        ],
                        [
                            "weight * (target_norms / norms)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "unstack_134": {
                "value": {
                    "value": "tf.shape(inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_134": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                }
            }
        }
    },
    "tflib/spike_relevance_analysis.py": {
        "tensorflow": {
            "placeholder_158": {
                "variable": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "inputs_to_discriminator",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, FLAGS.num_neurons * FLAGS.num_bins]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "run_270": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_112": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    }
}